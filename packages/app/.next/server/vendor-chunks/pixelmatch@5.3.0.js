"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/pixelmatch@5.3.0";
exports.ids = ["vendor-chunks/pixelmatch@5.3.0"];
exports.modules = {

/***/ "(ssr)/../../node_modules/.pnpm/pixelmatch@5.3.0/node_modules/pixelmatch/index.js":
/*!**********************************************************************************!*\
  !*** ../../node_modules/.pnpm/pixelmatch@5.3.0/node_modules/pixelmatch/index.js ***!
  \**********************************************************************************/
/***/ ((module) => {

eval("\n\nmodule.exports = pixelmatch;\n\nconst defaultOptions = {\n    threshold: 0.1,         // matching threshold (0 to 1); smaller is more sensitive\n    includeAA: false,       // whether to skip anti-aliasing detection\n    alpha: 0.1,             // opacity of original image in diff output\n    aaColor: [255, 255, 0], // color of anti-aliased pixels in diff output\n    diffColor: [255, 0, 0], // color of different pixels in diff output\n    diffColorAlt: null,     // whether to detect dark on light differences between img1 and img2 and set an alternative color to differentiate between the two\n    diffMask: false         // draw the diff over a transparent background (a mask)\n};\n\nfunction pixelmatch(img1, img2, output, width, height, options) {\n\n    if (!isPixelData(img1) || !isPixelData(img2) || (output && !isPixelData(output)))\n        throw new Error('Image data: Uint8Array, Uint8ClampedArray or Buffer expected.');\n\n    if (img1.length !== img2.length || (output && output.length !== img1.length))\n        throw new Error('Image sizes do not match.');\n\n    if (img1.length !== width * height * 4) throw new Error('Image data size does not match width/height.');\n\n    options = Object.assign({}, defaultOptions, options);\n\n    // check if images are identical\n    const len = width * height;\n    const a32 = new Uint32Array(img1.buffer, img1.byteOffset, len);\n    const b32 = new Uint32Array(img2.buffer, img2.byteOffset, len);\n    let identical = true;\n\n    for (let i = 0; i < len; i++) {\n        if (a32[i] !== b32[i]) { identical = false; break; }\n    }\n    if (identical) { // fast path if identical\n        if (output && !options.diffMask) {\n            for (let i = 0; i < len; i++) drawGrayPixel(img1, 4 * i, options.alpha, output);\n        }\n        return 0;\n    }\n\n    // maximum acceptable square distance between two colors;\n    // 35215 is the maximum possible value for the YIQ difference metric\n    const maxDelta = 35215 * options.threshold * options.threshold;\n    let diff = 0;\n\n    // compare each pixel of one image against the other one\n    for (let y = 0; y < height; y++) {\n        for (let x = 0; x < width; x++) {\n\n            const pos = (y * width + x) * 4;\n\n            // squared YUV distance between colors at this pixel position, negative if the img2 pixel is darker\n            const delta = colorDelta(img1, img2, pos, pos);\n\n            // the color difference is above the threshold\n            if (Math.abs(delta) > maxDelta) {\n                // check it's a real rendering difference or just anti-aliasing\n                if (!options.includeAA && (antialiased(img1, x, y, width, height, img2) ||\n                                           antialiased(img2, x, y, width, height, img1))) {\n                    // one of the pixels is anti-aliasing; draw as yellow and do not count as difference\n                    // note that we do not include such pixels in a mask\n                    if (output && !options.diffMask) drawPixel(output, pos, ...options.aaColor);\n\n                } else {\n                    // found substantial difference not caused by anti-aliasing; draw it as such\n                    if (output) {\n                        drawPixel(output, pos, ...(delta < 0 && options.diffColorAlt || options.diffColor));\n                    }\n                    diff++;\n                }\n\n            } else if (output) {\n                // pixels are similar; draw background as grayscale image blended with white\n                if (!options.diffMask) drawGrayPixel(img1, pos, options.alpha, output);\n            }\n        }\n    }\n\n    // return the number of different pixels\n    return diff;\n}\n\nfunction isPixelData(arr) {\n    // work around instanceof Uint8Array not working properly in some Jest environments\n    return ArrayBuffer.isView(arr) && arr.constructor.BYTES_PER_ELEMENT === 1;\n}\n\n// check if a pixel is likely a part of anti-aliasing;\n// based on \"Anti-aliased Pixel and Intensity Slope Detector\" paper by V. Vysniauskas, 2009\n\nfunction antialiased(img, x1, y1, width, height, img2) {\n    const x0 = Math.max(x1 - 1, 0);\n    const y0 = Math.max(y1 - 1, 0);\n    const x2 = Math.min(x1 + 1, width - 1);\n    const y2 = Math.min(y1 + 1, height - 1);\n    const pos = (y1 * width + x1) * 4;\n    let zeroes = x1 === x0 || x1 === x2 || y1 === y0 || y1 === y2 ? 1 : 0;\n    let min = 0;\n    let max = 0;\n    let minX, minY, maxX, maxY;\n\n    // go through 8 adjacent pixels\n    for (let x = x0; x <= x2; x++) {\n        for (let y = y0; y <= y2; y++) {\n            if (x === x1 && y === y1) continue;\n\n            // brightness delta between the center pixel and adjacent one\n            const delta = colorDelta(img, img, pos, (y * width + x) * 4, true);\n\n            // count the number of equal, darker and brighter adjacent pixels\n            if (delta === 0) {\n                zeroes++;\n                // if found more than 2 equal siblings, it's definitely not anti-aliasing\n                if (zeroes > 2) return false;\n\n            // remember the darkest pixel\n            } else if (delta < min) {\n                min = delta;\n                minX = x;\n                minY = y;\n\n            // remember the brightest pixel\n            } else if (delta > max) {\n                max = delta;\n                maxX = x;\n                maxY = y;\n            }\n        }\n    }\n\n    // if there are no both darker and brighter pixels among siblings, it's not anti-aliasing\n    if (min === 0 || max === 0) return false;\n\n    // if either the darkest or the brightest pixel has 3+ equal siblings in both images\n    // (definitely not anti-aliased), this pixel is anti-aliased\n    return (hasManySiblings(img, minX, minY, width, height) && hasManySiblings(img2, minX, minY, width, height)) ||\n           (hasManySiblings(img, maxX, maxY, width, height) && hasManySiblings(img2, maxX, maxY, width, height));\n}\n\n// check if a pixel has 3+ adjacent pixels of the same color.\nfunction hasManySiblings(img, x1, y1, width, height) {\n    const x0 = Math.max(x1 - 1, 0);\n    const y0 = Math.max(y1 - 1, 0);\n    const x2 = Math.min(x1 + 1, width - 1);\n    const y2 = Math.min(y1 + 1, height - 1);\n    const pos = (y1 * width + x1) * 4;\n    let zeroes = x1 === x0 || x1 === x2 || y1 === y0 || y1 === y2 ? 1 : 0;\n\n    // go through 8 adjacent pixels\n    for (let x = x0; x <= x2; x++) {\n        for (let y = y0; y <= y2; y++) {\n            if (x === x1 && y === y1) continue;\n\n            const pos2 = (y * width + x) * 4;\n            if (img[pos] === img[pos2] &&\n                img[pos + 1] === img[pos2 + 1] &&\n                img[pos + 2] === img[pos2 + 2] &&\n                img[pos + 3] === img[pos2 + 3]) zeroes++;\n\n            if (zeroes > 2) return true;\n        }\n    }\n\n    return false;\n}\n\n// calculate color difference according to the paper \"Measuring perceived color difference\n// using YIQ NTSC transmission color space in mobile applications\" by Y. Kotsarenko and F. Ramos\n\nfunction colorDelta(img1, img2, k, m, yOnly) {\n    let r1 = img1[k + 0];\n    let g1 = img1[k + 1];\n    let b1 = img1[k + 2];\n    let a1 = img1[k + 3];\n\n    let r2 = img2[m + 0];\n    let g2 = img2[m + 1];\n    let b2 = img2[m + 2];\n    let a2 = img2[m + 3];\n\n    if (a1 === a2 && r1 === r2 && g1 === g2 && b1 === b2) return 0;\n\n    if (a1 < 255) {\n        a1 /= 255;\n        r1 = blend(r1, a1);\n        g1 = blend(g1, a1);\n        b1 = blend(b1, a1);\n    }\n\n    if (a2 < 255) {\n        a2 /= 255;\n        r2 = blend(r2, a2);\n        g2 = blend(g2, a2);\n        b2 = blend(b2, a2);\n    }\n\n    const y1 = rgb2y(r1, g1, b1);\n    const y2 = rgb2y(r2, g2, b2);\n    const y = y1 - y2;\n\n    if (yOnly) return y; // brightness difference only\n\n    const i = rgb2i(r1, g1, b1) - rgb2i(r2, g2, b2);\n    const q = rgb2q(r1, g1, b1) - rgb2q(r2, g2, b2);\n\n    const delta = 0.5053 * y * y + 0.299 * i * i + 0.1957 * q * q;\n\n    // encode whether the pixel lightens or darkens in the sign\n    return y1 > y2 ? -delta : delta;\n}\n\nfunction rgb2y(r, g, b) { return r * 0.29889531 + g * 0.58662247 + b * 0.11448223; }\nfunction rgb2i(r, g, b) { return r * 0.59597799 - g * 0.27417610 - b * 0.32180189; }\nfunction rgb2q(r, g, b) { return r * 0.21147017 - g * 0.52261711 + b * 0.31114694; }\n\n// blend semi-transparent color with white\nfunction blend(c, a) {\n    return 255 + (c - 255) * a;\n}\n\nfunction drawPixel(output, pos, r, g, b) {\n    output[pos + 0] = r;\n    output[pos + 1] = g;\n    output[pos + 2] = b;\n    output[pos + 3] = 255;\n}\n\nfunction drawGrayPixel(img, i, alpha, output) {\n    const r = img[i + 0];\n    const g = img[i + 1];\n    const b = img[i + 2];\n    const val = blend(rgb2y(r, g, b), alpha * img[i + 3] / 255);\n    drawPixel(output, i, val, val, val);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3BpeGVsbWF0Y2hANS4zLjAvbm9kZV9tb2R1bGVzL3BpeGVsbWF0Y2gvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7O0FBRUE7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLDhCQUE4Qjs7QUFFOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsU0FBUztBQUM3QixpQ0FBaUMsbUJBQW1CO0FBQ3BEO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsNEJBQTRCLFNBQVM7QUFDckM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLFlBQVk7QUFDaEMsd0JBQXdCLFdBQVc7O0FBRW5DOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBOztBQUVBLGtCQUFrQjtBQUNsQixpRkFBaUY7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjO0FBQ2QsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCLFNBQVM7QUFDOUIseUJBQXlCLFNBQVM7QUFDbEM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsU0FBUztBQUM5Qix5QkFBeUIsU0FBUztBQUNsQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUI7O0FBRXpCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDBCQUEwQjtBQUMxQiwwQkFBMEI7QUFDMUIsMEJBQTBCOztBQUUxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9taWtld2VzdGhhZC9EZXNrdG9wL1JlcG9zL3Nwb3JhZGljLWxhYnMtdGlsZS1leHRydWRlci9ub2RlX21vZHVsZXMvLnBucG0vcGl4ZWxtYXRjaEA1LjMuMC9ub2RlX21vZHVsZXMvcGl4ZWxtYXRjaC9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gcGl4ZWxtYXRjaDtcblxuY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgdGhyZXNob2xkOiAwLjEsICAgICAgICAgLy8gbWF0Y2hpbmcgdGhyZXNob2xkICgwIHRvIDEpOyBzbWFsbGVyIGlzIG1vcmUgc2Vuc2l0aXZlXG4gICAgaW5jbHVkZUFBOiBmYWxzZSwgICAgICAgLy8gd2hldGhlciB0byBza2lwIGFudGktYWxpYXNpbmcgZGV0ZWN0aW9uXG4gICAgYWxwaGE6IDAuMSwgICAgICAgICAgICAgLy8gb3BhY2l0eSBvZiBvcmlnaW5hbCBpbWFnZSBpbiBkaWZmIG91dHB1dFxuICAgIGFhQ29sb3I6IFsyNTUsIDI1NSwgMF0sIC8vIGNvbG9yIG9mIGFudGktYWxpYXNlZCBwaXhlbHMgaW4gZGlmZiBvdXRwdXRcbiAgICBkaWZmQ29sb3I6IFsyNTUsIDAsIDBdLCAvLyBjb2xvciBvZiBkaWZmZXJlbnQgcGl4ZWxzIGluIGRpZmYgb3V0cHV0XG4gICAgZGlmZkNvbG9yQWx0OiBudWxsLCAgICAgLy8gd2hldGhlciB0byBkZXRlY3QgZGFyayBvbiBsaWdodCBkaWZmZXJlbmNlcyBiZXR3ZWVuIGltZzEgYW5kIGltZzIgYW5kIHNldCBhbiBhbHRlcm5hdGl2ZSBjb2xvciB0byBkaWZmZXJlbnRpYXRlIGJldHdlZW4gdGhlIHR3b1xuICAgIGRpZmZNYXNrOiBmYWxzZSAgICAgICAgIC8vIGRyYXcgdGhlIGRpZmYgb3ZlciBhIHRyYW5zcGFyZW50IGJhY2tncm91bmQgKGEgbWFzaylcbn07XG5cbmZ1bmN0aW9uIHBpeGVsbWF0Y2goaW1nMSwgaW1nMiwgb3V0cHV0LCB3aWR0aCwgaGVpZ2h0LCBvcHRpb25zKSB7XG5cbiAgICBpZiAoIWlzUGl4ZWxEYXRhKGltZzEpIHx8ICFpc1BpeGVsRGF0YShpbWcyKSB8fCAob3V0cHV0ICYmICFpc1BpeGVsRGF0YShvdXRwdXQpKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbWFnZSBkYXRhOiBVaW50OEFycmF5LCBVaW50OENsYW1wZWRBcnJheSBvciBCdWZmZXIgZXhwZWN0ZWQuJyk7XG5cbiAgICBpZiAoaW1nMS5sZW5ndGggIT09IGltZzIubGVuZ3RoIHx8IChvdXRwdXQgJiYgb3V0cHV0Lmxlbmd0aCAhPT0gaW1nMS5sZW5ndGgpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ltYWdlIHNpemVzIGRvIG5vdCBtYXRjaC4nKTtcblxuICAgIGlmIChpbWcxLmxlbmd0aCAhPT0gd2lkdGggKiBoZWlnaHQgKiA0KSB0aHJvdyBuZXcgRXJyb3IoJ0ltYWdlIGRhdGEgc2l6ZSBkb2VzIG5vdCBtYXRjaCB3aWR0aC9oZWlnaHQuJyk7XG5cbiAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnMpO1xuXG4gICAgLy8gY2hlY2sgaWYgaW1hZ2VzIGFyZSBpZGVudGljYWxcbiAgICBjb25zdCBsZW4gPSB3aWR0aCAqIGhlaWdodDtcbiAgICBjb25zdCBhMzIgPSBuZXcgVWludDMyQXJyYXkoaW1nMS5idWZmZXIsIGltZzEuYnl0ZU9mZnNldCwgbGVuKTtcbiAgICBjb25zdCBiMzIgPSBuZXcgVWludDMyQXJyYXkoaW1nMi5idWZmZXIsIGltZzIuYnl0ZU9mZnNldCwgbGVuKTtcbiAgICBsZXQgaWRlbnRpY2FsID0gdHJ1ZTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYgKGEzMltpXSAhPT0gYjMyW2ldKSB7IGlkZW50aWNhbCA9IGZhbHNlOyBicmVhazsgfVxuICAgIH1cbiAgICBpZiAoaWRlbnRpY2FsKSB7IC8vIGZhc3QgcGF0aCBpZiBpZGVudGljYWxcbiAgICAgICAgaWYgKG91dHB1dCAmJiAhb3B0aW9ucy5kaWZmTWFzaykge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykgZHJhd0dyYXlQaXhlbChpbWcxLCA0ICogaSwgb3B0aW9ucy5hbHBoYSwgb3V0cHV0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICAvLyBtYXhpbXVtIGFjY2VwdGFibGUgc3F1YXJlIGRpc3RhbmNlIGJldHdlZW4gdHdvIGNvbG9ycztcbiAgICAvLyAzNTIxNSBpcyB0aGUgbWF4aW11bSBwb3NzaWJsZSB2YWx1ZSBmb3IgdGhlIFlJUSBkaWZmZXJlbmNlIG1ldHJpY1xuICAgIGNvbnN0IG1heERlbHRhID0gMzUyMTUgKiBvcHRpb25zLnRocmVzaG9sZCAqIG9wdGlvbnMudGhyZXNob2xkO1xuICAgIGxldCBkaWZmID0gMDtcblxuICAgIC8vIGNvbXBhcmUgZWFjaCBwaXhlbCBvZiBvbmUgaW1hZ2UgYWdhaW5zdCB0aGUgb3RoZXIgb25lXG4gICAgZm9yIChsZXQgeSA9IDA7IHkgPCBoZWlnaHQ7IHkrKykge1xuICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHdpZHRoOyB4KyspIHtcblxuICAgICAgICAgICAgY29uc3QgcG9zID0gKHkgKiB3aWR0aCArIHgpICogNDtcblxuICAgICAgICAgICAgLy8gc3F1YXJlZCBZVVYgZGlzdGFuY2UgYmV0d2VlbiBjb2xvcnMgYXQgdGhpcyBwaXhlbCBwb3NpdGlvbiwgbmVnYXRpdmUgaWYgdGhlIGltZzIgcGl4ZWwgaXMgZGFya2VyXG4gICAgICAgICAgICBjb25zdCBkZWx0YSA9IGNvbG9yRGVsdGEoaW1nMSwgaW1nMiwgcG9zLCBwb3MpO1xuXG4gICAgICAgICAgICAvLyB0aGUgY29sb3IgZGlmZmVyZW5jZSBpcyBhYm92ZSB0aGUgdGhyZXNob2xkXG4gICAgICAgICAgICBpZiAoTWF0aC5hYnMoZGVsdGEpID4gbWF4RGVsdGEpIHtcbiAgICAgICAgICAgICAgICAvLyBjaGVjayBpdCdzIGEgcmVhbCByZW5kZXJpbmcgZGlmZmVyZW5jZSBvciBqdXN0IGFudGktYWxpYXNpbmdcbiAgICAgICAgICAgICAgICBpZiAoIW9wdGlvbnMuaW5jbHVkZUFBICYmIChhbnRpYWxpYXNlZChpbWcxLCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCBpbWcyKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFudGlhbGlhc2VkKGltZzIsIHgsIHksIHdpZHRoLCBoZWlnaHQsIGltZzEpKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBvbmUgb2YgdGhlIHBpeGVscyBpcyBhbnRpLWFsaWFzaW5nOyBkcmF3IGFzIHllbGxvdyBhbmQgZG8gbm90IGNvdW50IGFzIGRpZmZlcmVuY2VcbiAgICAgICAgICAgICAgICAgICAgLy8gbm90ZSB0aGF0IHdlIGRvIG5vdCBpbmNsdWRlIHN1Y2ggcGl4ZWxzIGluIGEgbWFza1xuICAgICAgICAgICAgICAgICAgICBpZiAob3V0cHV0ICYmICFvcHRpb25zLmRpZmZNYXNrKSBkcmF3UGl4ZWwob3V0cHV0LCBwb3MsIC4uLm9wdGlvbnMuYWFDb2xvcik7XG5cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBmb3VuZCBzdWJzdGFudGlhbCBkaWZmZXJlbmNlIG5vdCBjYXVzZWQgYnkgYW50aS1hbGlhc2luZzsgZHJhdyBpdCBhcyBzdWNoXG4gICAgICAgICAgICAgICAgICAgIGlmIChvdXRwdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRyYXdQaXhlbChvdXRwdXQsIHBvcywgLi4uKGRlbHRhIDwgMCAmJiBvcHRpb25zLmRpZmZDb2xvckFsdCB8fCBvcHRpb25zLmRpZmZDb2xvcikpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGRpZmYrKztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAob3V0cHV0KSB7XG4gICAgICAgICAgICAgICAgLy8gcGl4ZWxzIGFyZSBzaW1pbGFyOyBkcmF3IGJhY2tncm91bmQgYXMgZ3JheXNjYWxlIGltYWdlIGJsZW5kZWQgd2l0aCB3aGl0ZVxuICAgICAgICAgICAgICAgIGlmICghb3B0aW9ucy5kaWZmTWFzaykgZHJhd0dyYXlQaXhlbChpbWcxLCBwb3MsIG9wdGlvbnMuYWxwaGEsIG91dHB1dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyByZXR1cm4gdGhlIG51bWJlciBvZiBkaWZmZXJlbnQgcGl4ZWxzXG4gICAgcmV0dXJuIGRpZmY7XG59XG5cbmZ1bmN0aW9uIGlzUGl4ZWxEYXRhKGFycikge1xuICAgIC8vIHdvcmsgYXJvdW5kIGluc3RhbmNlb2YgVWludDhBcnJheSBub3Qgd29ya2luZyBwcm9wZXJseSBpbiBzb21lIEplc3QgZW52aXJvbm1lbnRzXG4gICAgcmV0dXJuIEFycmF5QnVmZmVyLmlzVmlldyhhcnIpICYmIGFyci5jb25zdHJ1Y3Rvci5CWVRFU19QRVJfRUxFTUVOVCA9PT0gMTtcbn1cblxuLy8gY2hlY2sgaWYgYSBwaXhlbCBpcyBsaWtlbHkgYSBwYXJ0IG9mIGFudGktYWxpYXNpbmc7XG4vLyBiYXNlZCBvbiBcIkFudGktYWxpYXNlZCBQaXhlbCBhbmQgSW50ZW5zaXR5IFNsb3BlIERldGVjdG9yXCIgcGFwZXIgYnkgVi4gVnlzbmlhdXNrYXMsIDIwMDlcblxuZnVuY3Rpb24gYW50aWFsaWFzZWQoaW1nLCB4MSwgeTEsIHdpZHRoLCBoZWlnaHQsIGltZzIpIHtcbiAgICBjb25zdCB4MCA9IE1hdGgubWF4KHgxIC0gMSwgMCk7XG4gICAgY29uc3QgeTAgPSBNYXRoLm1heCh5MSAtIDEsIDApO1xuICAgIGNvbnN0IHgyID0gTWF0aC5taW4oeDEgKyAxLCB3aWR0aCAtIDEpO1xuICAgIGNvbnN0IHkyID0gTWF0aC5taW4oeTEgKyAxLCBoZWlnaHQgLSAxKTtcbiAgICBjb25zdCBwb3MgPSAoeTEgKiB3aWR0aCArIHgxKSAqIDQ7XG4gICAgbGV0IHplcm9lcyA9IHgxID09PSB4MCB8fCB4MSA9PT0geDIgfHwgeTEgPT09IHkwIHx8IHkxID09PSB5MiA/IDEgOiAwO1xuICAgIGxldCBtaW4gPSAwO1xuICAgIGxldCBtYXggPSAwO1xuICAgIGxldCBtaW5YLCBtaW5ZLCBtYXhYLCBtYXhZO1xuXG4gICAgLy8gZ28gdGhyb3VnaCA4IGFkamFjZW50IHBpeGVsc1xuICAgIGZvciAobGV0IHggPSB4MDsgeCA8PSB4MjsgeCsrKSB7XG4gICAgICAgIGZvciAobGV0IHkgPSB5MDsgeSA8PSB5MjsgeSsrKSB7XG4gICAgICAgICAgICBpZiAoeCA9PT0geDEgJiYgeSA9PT0geTEpIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAvLyBicmlnaHRuZXNzIGRlbHRhIGJldHdlZW4gdGhlIGNlbnRlciBwaXhlbCBhbmQgYWRqYWNlbnQgb25lXG4gICAgICAgICAgICBjb25zdCBkZWx0YSA9IGNvbG9yRGVsdGEoaW1nLCBpbWcsIHBvcywgKHkgKiB3aWR0aCArIHgpICogNCwgdHJ1ZSk7XG5cbiAgICAgICAgICAgIC8vIGNvdW50IHRoZSBudW1iZXIgb2YgZXF1YWwsIGRhcmtlciBhbmQgYnJpZ2h0ZXIgYWRqYWNlbnQgcGl4ZWxzXG4gICAgICAgICAgICBpZiAoZGVsdGEgPT09IDApIHtcbiAgICAgICAgICAgICAgICB6ZXJvZXMrKztcbiAgICAgICAgICAgICAgICAvLyBpZiBmb3VuZCBtb3JlIHRoYW4gMiBlcXVhbCBzaWJsaW5ncywgaXQncyBkZWZpbml0ZWx5IG5vdCBhbnRpLWFsaWFzaW5nXG4gICAgICAgICAgICAgICAgaWYgKHplcm9lcyA+IDIpIHJldHVybiBmYWxzZTtcblxuICAgICAgICAgICAgLy8gcmVtZW1iZXIgdGhlIGRhcmtlc3QgcGl4ZWxcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZGVsdGEgPCBtaW4pIHtcbiAgICAgICAgICAgICAgICBtaW4gPSBkZWx0YTtcbiAgICAgICAgICAgICAgICBtaW5YID0geDtcbiAgICAgICAgICAgICAgICBtaW5ZID0geTtcblxuICAgICAgICAgICAgLy8gcmVtZW1iZXIgdGhlIGJyaWdodGVzdCBwaXhlbFxuICAgICAgICAgICAgfSBlbHNlIGlmIChkZWx0YSA+IG1heCkge1xuICAgICAgICAgICAgICAgIG1heCA9IGRlbHRhO1xuICAgICAgICAgICAgICAgIG1heFggPSB4O1xuICAgICAgICAgICAgICAgIG1heFkgPSB5O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gaWYgdGhlcmUgYXJlIG5vIGJvdGggZGFya2VyIGFuZCBicmlnaHRlciBwaXhlbHMgYW1vbmcgc2libGluZ3MsIGl0J3Mgbm90IGFudGktYWxpYXNpbmdcbiAgICBpZiAobWluID09PSAwIHx8IG1heCA9PT0gMCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgLy8gaWYgZWl0aGVyIHRoZSBkYXJrZXN0IG9yIHRoZSBicmlnaHRlc3QgcGl4ZWwgaGFzIDMrIGVxdWFsIHNpYmxpbmdzIGluIGJvdGggaW1hZ2VzXG4gICAgLy8gKGRlZmluaXRlbHkgbm90IGFudGktYWxpYXNlZCksIHRoaXMgcGl4ZWwgaXMgYW50aS1hbGlhc2VkXG4gICAgcmV0dXJuIChoYXNNYW55U2libGluZ3MoaW1nLCBtaW5YLCBtaW5ZLCB3aWR0aCwgaGVpZ2h0KSAmJiBoYXNNYW55U2libGluZ3MoaW1nMiwgbWluWCwgbWluWSwgd2lkdGgsIGhlaWdodCkpIHx8XG4gICAgICAgICAgIChoYXNNYW55U2libGluZ3MoaW1nLCBtYXhYLCBtYXhZLCB3aWR0aCwgaGVpZ2h0KSAmJiBoYXNNYW55U2libGluZ3MoaW1nMiwgbWF4WCwgbWF4WSwgd2lkdGgsIGhlaWdodCkpO1xufVxuXG4vLyBjaGVjayBpZiBhIHBpeGVsIGhhcyAzKyBhZGphY2VudCBwaXhlbHMgb2YgdGhlIHNhbWUgY29sb3IuXG5mdW5jdGlvbiBoYXNNYW55U2libGluZ3MoaW1nLCB4MSwgeTEsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICBjb25zdCB4MCA9IE1hdGgubWF4KHgxIC0gMSwgMCk7XG4gICAgY29uc3QgeTAgPSBNYXRoLm1heCh5MSAtIDEsIDApO1xuICAgIGNvbnN0IHgyID0gTWF0aC5taW4oeDEgKyAxLCB3aWR0aCAtIDEpO1xuICAgIGNvbnN0IHkyID0gTWF0aC5taW4oeTEgKyAxLCBoZWlnaHQgLSAxKTtcbiAgICBjb25zdCBwb3MgPSAoeTEgKiB3aWR0aCArIHgxKSAqIDQ7XG4gICAgbGV0IHplcm9lcyA9IHgxID09PSB4MCB8fCB4MSA9PT0geDIgfHwgeTEgPT09IHkwIHx8IHkxID09PSB5MiA/IDEgOiAwO1xuXG4gICAgLy8gZ28gdGhyb3VnaCA4IGFkamFjZW50IHBpeGVsc1xuICAgIGZvciAobGV0IHggPSB4MDsgeCA8PSB4MjsgeCsrKSB7XG4gICAgICAgIGZvciAobGV0IHkgPSB5MDsgeSA8PSB5MjsgeSsrKSB7XG4gICAgICAgICAgICBpZiAoeCA9PT0geDEgJiYgeSA9PT0geTEpIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICBjb25zdCBwb3MyID0gKHkgKiB3aWR0aCArIHgpICogNDtcbiAgICAgICAgICAgIGlmIChpbWdbcG9zXSA9PT0gaW1nW3BvczJdICYmXG4gICAgICAgICAgICAgICAgaW1nW3BvcyArIDFdID09PSBpbWdbcG9zMiArIDFdICYmXG4gICAgICAgICAgICAgICAgaW1nW3BvcyArIDJdID09PSBpbWdbcG9zMiArIDJdICYmXG4gICAgICAgICAgICAgICAgaW1nW3BvcyArIDNdID09PSBpbWdbcG9zMiArIDNdKSB6ZXJvZXMrKztcblxuICAgICAgICAgICAgaWYgKHplcm9lcyA+IDIpIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG4vLyBjYWxjdWxhdGUgY29sb3IgZGlmZmVyZW5jZSBhY2NvcmRpbmcgdG8gdGhlIHBhcGVyIFwiTWVhc3VyaW5nIHBlcmNlaXZlZCBjb2xvciBkaWZmZXJlbmNlXG4vLyB1c2luZyBZSVEgTlRTQyB0cmFuc21pc3Npb24gY29sb3Igc3BhY2UgaW4gbW9iaWxlIGFwcGxpY2F0aW9uc1wiIGJ5IFkuIEtvdHNhcmVua28gYW5kIEYuIFJhbW9zXG5cbmZ1bmN0aW9uIGNvbG9yRGVsdGEoaW1nMSwgaW1nMiwgaywgbSwgeU9ubHkpIHtcbiAgICBsZXQgcjEgPSBpbWcxW2sgKyAwXTtcbiAgICBsZXQgZzEgPSBpbWcxW2sgKyAxXTtcbiAgICBsZXQgYjEgPSBpbWcxW2sgKyAyXTtcbiAgICBsZXQgYTEgPSBpbWcxW2sgKyAzXTtcblxuICAgIGxldCByMiA9IGltZzJbbSArIDBdO1xuICAgIGxldCBnMiA9IGltZzJbbSArIDFdO1xuICAgIGxldCBiMiA9IGltZzJbbSArIDJdO1xuICAgIGxldCBhMiA9IGltZzJbbSArIDNdO1xuXG4gICAgaWYgKGExID09PSBhMiAmJiByMSA9PT0gcjIgJiYgZzEgPT09IGcyICYmIGIxID09PSBiMikgcmV0dXJuIDA7XG5cbiAgICBpZiAoYTEgPCAyNTUpIHtcbiAgICAgICAgYTEgLz0gMjU1O1xuICAgICAgICByMSA9IGJsZW5kKHIxLCBhMSk7XG4gICAgICAgIGcxID0gYmxlbmQoZzEsIGExKTtcbiAgICAgICAgYjEgPSBibGVuZChiMSwgYTEpO1xuICAgIH1cblxuICAgIGlmIChhMiA8IDI1NSkge1xuICAgICAgICBhMiAvPSAyNTU7XG4gICAgICAgIHIyID0gYmxlbmQocjIsIGEyKTtcbiAgICAgICAgZzIgPSBibGVuZChnMiwgYTIpO1xuICAgICAgICBiMiA9IGJsZW5kKGIyLCBhMik7XG4gICAgfVxuXG4gICAgY29uc3QgeTEgPSByZ2IyeShyMSwgZzEsIGIxKTtcbiAgICBjb25zdCB5MiA9IHJnYjJ5KHIyLCBnMiwgYjIpO1xuICAgIGNvbnN0IHkgPSB5MSAtIHkyO1xuXG4gICAgaWYgKHlPbmx5KSByZXR1cm4geTsgLy8gYnJpZ2h0bmVzcyBkaWZmZXJlbmNlIG9ubHlcblxuICAgIGNvbnN0IGkgPSByZ2IyaShyMSwgZzEsIGIxKSAtIHJnYjJpKHIyLCBnMiwgYjIpO1xuICAgIGNvbnN0IHEgPSByZ2IycShyMSwgZzEsIGIxKSAtIHJnYjJxKHIyLCBnMiwgYjIpO1xuXG4gICAgY29uc3QgZGVsdGEgPSAwLjUwNTMgKiB5ICogeSArIDAuMjk5ICogaSAqIGkgKyAwLjE5NTcgKiBxICogcTtcblxuICAgIC8vIGVuY29kZSB3aGV0aGVyIHRoZSBwaXhlbCBsaWdodGVucyBvciBkYXJrZW5zIGluIHRoZSBzaWduXG4gICAgcmV0dXJuIHkxID4geTIgPyAtZGVsdGEgOiBkZWx0YTtcbn1cblxuZnVuY3Rpb24gcmdiMnkociwgZywgYikgeyByZXR1cm4gciAqIDAuMjk4ODk1MzEgKyBnICogMC41ODY2MjI0NyArIGIgKiAwLjExNDQ4MjIzOyB9XG5mdW5jdGlvbiByZ2IyaShyLCBnLCBiKSB7IHJldHVybiByICogMC41OTU5Nzc5OSAtIGcgKiAwLjI3NDE3NjEwIC0gYiAqIDAuMzIxODAxODk7IH1cbmZ1bmN0aW9uIHJnYjJxKHIsIGcsIGIpIHsgcmV0dXJuIHIgKiAwLjIxMTQ3MDE3IC0gZyAqIDAuNTIyNjE3MTEgKyBiICogMC4zMTExNDY5NDsgfVxuXG4vLyBibGVuZCBzZW1pLXRyYW5zcGFyZW50IGNvbG9yIHdpdGggd2hpdGVcbmZ1bmN0aW9uIGJsZW5kKGMsIGEpIHtcbiAgICByZXR1cm4gMjU1ICsgKGMgLSAyNTUpICogYTtcbn1cblxuZnVuY3Rpb24gZHJhd1BpeGVsKG91dHB1dCwgcG9zLCByLCBnLCBiKSB7XG4gICAgb3V0cHV0W3BvcyArIDBdID0gcjtcbiAgICBvdXRwdXRbcG9zICsgMV0gPSBnO1xuICAgIG91dHB1dFtwb3MgKyAyXSA9IGI7XG4gICAgb3V0cHV0W3BvcyArIDNdID0gMjU1O1xufVxuXG5mdW5jdGlvbiBkcmF3R3JheVBpeGVsKGltZywgaSwgYWxwaGEsIG91dHB1dCkge1xuICAgIGNvbnN0IHIgPSBpbWdbaSArIDBdO1xuICAgIGNvbnN0IGcgPSBpbWdbaSArIDFdO1xuICAgIGNvbnN0IGIgPSBpbWdbaSArIDJdO1xuICAgIGNvbnN0IHZhbCA9IGJsZW5kKHJnYjJ5KHIsIGcsIGIpLCBhbHBoYSAqIGltZ1tpICsgM10gLyAyNTUpO1xuICAgIGRyYXdQaXhlbChvdXRwdXQsIGksIHZhbCwgdmFsLCB2YWwpO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/pixelmatch@5.3.0/node_modules/pixelmatch/index.js\n");

/***/ })

};
;