"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@jimp+plugin-crop@1.6.0";
exports.ids = ["vendor-chunks/@jimp+plugin-crop@1.6.0"];
exports.modules = {

/***/ "(ssr)/../../node_modules/.pnpm/@jimp+plugin-crop@1.6.0/node_modules/@jimp/plugin-crop/dist/commonjs/index.js":
/*!**************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@jimp+plugin-crop@1.6.0/node_modules/@jimp/plugin-crop/dist/commonjs/index.js ***!
  \**************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.methods = exports.CropOptionsSchema = void 0;\nconst utils_1 = __webpack_require__(/*! @jimp/utils */ \"(ssr)/../../node_modules/.pnpm/@jimp+utils@1.6.0/node_modules/@jimp/utils/dist/commonjs/index.js\");\nconst zod_1 = __webpack_require__(/*! zod */ \"(ssr)/../../node_modules/.pnpm/zod@3.24.1/node_modules/zod/lib/index.js\");\nexports.CropOptionsSchema = zod_1.z.object({\n    /** the x position to crop form */\n    x: zod_1.z.number(),\n    /** the y position to crop form */\n    y: zod_1.z.number(),\n    /** the width to crop form */\n    w: zod_1.z.number(),\n    /** the height to crop form */\n    h: zod_1.z.number(),\n});\nconst AutocropComplexOptionsSchema = zod_1.z.object({\n    /** percent of color difference tolerance (default value) */\n    tolerance: zod_1.z.number().min(0).max(1).optional(),\n    /** flag to force cropping only if the image has a real \"frame\" i.e. all 4 sides have some border (default value) */\n    cropOnlyFrames: zod_1.z.boolean().optional(),\n    /** force cropping top be symmetric */\n    cropSymmetric: zod_1.z.boolean().optional(),\n    /** Amount of pixels in border to leave */\n    leaveBorder: zod_1.z.number().optional(),\n    ignoreSides: zod_1.z\n        .object({\n        north: zod_1.z.boolean().optional(),\n        south: zod_1.z.boolean().optional(),\n        east: zod_1.z.boolean().optional(),\n        west: zod_1.z.boolean().optional(),\n    })\n        .optional(),\n});\nexports.methods = {\n    /**\n     * Crops the image at a given point to a give size.\n     *\n     * @example\n     * ```ts\n     * import { Jimp } from \"jimp\";\n     *\n     * const image = await Jimp.read(\"test/image.png\");\n     * const cropped = image.crop(150, 100);\n     * ```\n     */\n    crop(image, options) {\n        let { x, y, w, h } = exports.CropOptionsSchema.parse(options);\n        // round input\n        x = Math.round(x);\n        y = Math.round(y);\n        w = Math.round(w);\n        h = Math.round(h);\n        if (x === 0 && w === image.bitmap.width) {\n            // shortcut\n            const start = (w * y + x) << 2;\n            const end = start + ((h * w) << 2);\n            image.bitmap.data = image.bitmap.data.slice(start, end);\n        }\n        else {\n            const bitmap = Buffer.allocUnsafe(w * h * 4);\n            let offset = 0;\n            (0, utils_1.scan)(image, x, y, w, h, function (_, __, idx) {\n                const data = image.bitmap.data.readUInt32BE(idx);\n                bitmap.writeUInt32BE(data, offset);\n                offset += 4;\n            });\n            image.bitmap.data = bitmap;\n        }\n        image.bitmap.width = w;\n        image.bitmap.height = h;\n        return image;\n    },\n    /**\n     * Autocrop same color borders from this image.\n     * This function will attempt to crop out transparent pixels from the image.\n     *\n     * @example\n     * ```ts\n     * import { Jimp } from \"jimp\";\n     *\n     * const image = await Jimp.read(\"test/image.png\");\n     * const cropped = image.autocrop();\n     * ```\n     */\n    autocrop(image, options = {}) {\n        const { tolerance = 0.0002, cropOnlyFrames = true, cropSymmetric = false, leaveBorder = 0, ignoreSides: ignoreSidesArg, } = typeof options === \"number\"\n            ? { tolerance: options }\n            : AutocropComplexOptionsSchema.parse(options);\n        const w = image.bitmap.width;\n        const h = image.bitmap.height;\n        const minPixelsPerSide = 1; // to avoid cropping completely the image, resulting in an invalid 0 sized image\n        // i.e. north and south / east and west are cropped by the same value\n        const ignoreSides = {\n            north: false,\n            south: false,\n            east: false,\n            west: false,\n            ...ignoreSidesArg,\n        };\n        /**\n         * All borders must be of the same color as the top left pixel, to be cropped.\n         * It should be possible to crop borders each with a different color,\n         * but since there are many ways for corners to intersect, it would\n         * introduce unnecessary complexity to the algorithm.\n         */\n        // scan each side for same color borders\n        let colorTarget = image.getPixelColor(0, 0); // top left pixel color is the target color\n        const rgba1 = (0, utils_1.intToRGBA)(colorTarget);\n        // for north and east sides\n        let northPixelsToCrop = 0;\n        let eastPixelsToCrop = 0;\n        let southPixelsToCrop = 0;\n        let westPixelsToCrop = 0;\n        // north side (scan rows from north to south)\n        colorTarget = image.getPixelColor(0, 0);\n        if (!ignoreSides.north) {\n            north: for (let y = 0; y < h - minPixelsPerSide; y++) {\n                for (let x = 0; x < w; x++) {\n                    const colorXY = image.getPixelColor(x, y);\n                    const rgba2 = (0, utils_1.intToRGBA)(colorXY);\n                    if ((0, utils_1.colorDiff)(rgba1, rgba2) > tolerance) {\n                        // this pixel is too distant from the first one: abort this side scan\n                        break north;\n                    }\n                }\n                // this row contains all pixels with the same color: increment this side pixels to crop\n                northPixelsToCrop++;\n            }\n        }\n        // west side (scan columns from west to east)\n        colorTarget = image.getPixelColor(w, 0);\n        if (!ignoreSides.west) {\n            west: for (let x = 0; x < w - minPixelsPerSide; x++) {\n                for (let y = 0 + northPixelsToCrop; y < h; y++) {\n                    const colorXY = image.getPixelColor(x, y);\n                    const rgba2 = (0, utils_1.intToRGBA)(colorXY);\n                    if ((0, utils_1.colorDiff)(rgba1, rgba2) > tolerance) {\n                        // this pixel is too distant from the first one: abort this side scan\n                        break west;\n                    }\n                }\n                // this column contains all pixels with the same color: increment this side pixels to crop\n                westPixelsToCrop++;\n            }\n        }\n        // south side (scan rows from south to north)\n        colorTarget = image.getPixelColor(0, h);\n        if (!ignoreSides.south) {\n            south: for (let y = h - 1; y >= northPixelsToCrop + minPixelsPerSide; y--) {\n                for (let x = w - eastPixelsToCrop - 1; x >= 0; x--) {\n                    const colorXY = image.getPixelColor(x, y);\n                    const rgba2 = (0, utils_1.intToRGBA)(colorXY);\n                    if ((0, utils_1.colorDiff)(rgba1, rgba2) > tolerance) {\n                        // this pixel is too distant from the first one: abort this side scan\n                        break south;\n                    }\n                }\n                // this row contains all pixels with the same color: increment this side pixels to crop\n                southPixelsToCrop++;\n            }\n        }\n        // east side (scan columns from east to west)\n        colorTarget = image.getPixelColor(w, h);\n        if (!ignoreSides.east) {\n            east: for (let x = w - 1; x >= 0 + westPixelsToCrop + minPixelsPerSide; x--) {\n                for (let y = h - 1; y >= 0 + northPixelsToCrop; y--) {\n                    const colorXY = image.getPixelColor(x, y);\n                    const rgba2 = (0, utils_1.intToRGBA)(colorXY);\n                    if ((0, utils_1.colorDiff)(rgba1, rgba2) > tolerance) {\n                        // this pixel is too distant from the first one: abort this side scan\n                        break east;\n                    }\n                }\n                // this column contains all pixels with the same color: increment this side pixels to crop\n                eastPixelsToCrop++;\n            }\n        }\n        // decide if a crop is needed\n        let doCrop = false;\n        // apply leaveBorder\n        westPixelsToCrop -= leaveBorder;\n        eastPixelsToCrop -= leaveBorder;\n        northPixelsToCrop -= leaveBorder;\n        southPixelsToCrop -= leaveBorder;\n        if (cropSymmetric) {\n            const horizontal = Math.min(eastPixelsToCrop, westPixelsToCrop);\n            const vertical = Math.min(northPixelsToCrop, southPixelsToCrop);\n            westPixelsToCrop = horizontal;\n            eastPixelsToCrop = horizontal;\n            northPixelsToCrop = vertical;\n            southPixelsToCrop = vertical;\n        }\n        // make sure that crops are >= 0\n        westPixelsToCrop = westPixelsToCrop >= 0 ? westPixelsToCrop : 0;\n        eastPixelsToCrop = eastPixelsToCrop >= 0 ? eastPixelsToCrop : 0;\n        northPixelsToCrop = northPixelsToCrop >= 0 ? northPixelsToCrop : 0;\n        southPixelsToCrop = southPixelsToCrop >= 0 ? southPixelsToCrop : 0;\n        // safety checks\n        const widthOfRemainingPixels = w - (westPixelsToCrop + eastPixelsToCrop);\n        const heightOfRemainingPixels = h - (southPixelsToCrop + northPixelsToCrop);\n        if (cropOnlyFrames) {\n            // crop image if all sides should be cropped\n            doCrop =\n                eastPixelsToCrop !== 0 &&\n                    northPixelsToCrop !== 0 &&\n                    westPixelsToCrop !== 0 &&\n                    southPixelsToCrop !== 0;\n        }\n        else {\n            // crop image if at least one side should be cropped\n            doCrop =\n                eastPixelsToCrop !== 0 ||\n                    northPixelsToCrop !== 0 ||\n                    westPixelsToCrop !== 0 ||\n                    southPixelsToCrop !== 0;\n        }\n        if (doCrop) {\n            // do the real crop\n            this.crop(image, {\n                x: westPixelsToCrop,\n                y: northPixelsToCrop,\n                w: widthOfRemainingPixels,\n                h: heightOfRemainingPixels,\n            });\n        }\n        return image;\n    },\n};\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BqaW1wK3BsdWdpbi1jcm9wQDEuNi4wL25vZGVfbW9kdWxlcy9AamltcC9wbHVnaW4tY3JvcC9kaXN0L2NvbW1vbmpzL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGVBQWUsR0FBRyx5QkFBeUI7QUFDM0MsZ0JBQWdCLG1CQUFPLENBQUMscUhBQWE7QUFDckMsY0FBYyxtQkFBTyxDQUFDLG9GQUFLO0FBQzNCLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRCxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsYUFBYTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDLGdCQUFnQixrSEFBa0g7QUFDbEksZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLDBCQUEwQjtBQUM3RCxnQ0FBZ0MsT0FBTztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLDBCQUEwQjtBQUM1RCxvREFBb0QsT0FBTztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLDJDQUEyQztBQUNsRix1REFBdUQsUUFBUTtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLDhDQUE4QztBQUNwRixvQ0FBb0MsNEJBQTRCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9taWtld2VzdGhhZC9EZXNrdG9wL1JlcG9zL3Nwb3JhZGljLWxhYnMtdGlsZS1leHRydWRlci9ub2RlX21vZHVsZXMvLnBucG0vQGppbXArcGx1Z2luLWNyb3BAMS42LjAvbm9kZV9tb2R1bGVzL0BqaW1wL3BsdWdpbi1jcm9wL2Rpc3QvY29tbW9uanMvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLm1ldGhvZHMgPSBleHBvcnRzLkNyb3BPcHRpb25zU2NoZW1hID0gdm9pZCAwO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCJAamltcC91dGlsc1wiKTtcbmNvbnN0IHpvZF8xID0gcmVxdWlyZShcInpvZFwiKTtcbmV4cG9ydHMuQ3JvcE9wdGlvbnNTY2hlbWEgPSB6b2RfMS56Lm9iamVjdCh7XG4gICAgLyoqIHRoZSB4IHBvc2l0aW9uIHRvIGNyb3AgZm9ybSAqL1xuICAgIHg6IHpvZF8xLnoubnVtYmVyKCksXG4gICAgLyoqIHRoZSB5IHBvc2l0aW9uIHRvIGNyb3AgZm9ybSAqL1xuICAgIHk6IHpvZF8xLnoubnVtYmVyKCksXG4gICAgLyoqIHRoZSB3aWR0aCB0byBjcm9wIGZvcm0gKi9cbiAgICB3OiB6b2RfMS56Lm51bWJlcigpLFxuICAgIC8qKiB0aGUgaGVpZ2h0IHRvIGNyb3AgZm9ybSAqL1xuICAgIGg6IHpvZF8xLnoubnVtYmVyKCksXG59KTtcbmNvbnN0IEF1dG9jcm9wQ29tcGxleE9wdGlvbnNTY2hlbWEgPSB6b2RfMS56Lm9iamVjdCh7XG4gICAgLyoqIHBlcmNlbnQgb2YgY29sb3IgZGlmZmVyZW5jZSB0b2xlcmFuY2UgKGRlZmF1bHQgdmFsdWUpICovXG4gICAgdG9sZXJhbmNlOiB6b2RfMS56Lm51bWJlcigpLm1pbigwKS5tYXgoMSkub3B0aW9uYWwoKSxcbiAgICAvKiogZmxhZyB0byBmb3JjZSBjcm9wcGluZyBvbmx5IGlmIHRoZSBpbWFnZSBoYXMgYSByZWFsIFwiZnJhbWVcIiBpLmUuIGFsbCA0IHNpZGVzIGhhdmUgc29tZSBib3JkZXIgKGRlZmF1bHQgdmFsdWUpICovXG4gICAgY3JvcE9ubHlGcmFtZXM6IHpvZF8xLnouYm9vbGVhbigpLm9wdGlvbmFsKCksXG4gICAgLyoqIGZvcmNlIGNyb3BwaW5nIHRvcCBiZSBzeW1tZXRyaWMgKi9cbiAgICBjcm9wU3ltbWV0cmljOiB6b2RfMS56LmJvb2xlYW4oKS5vcHRpb25hbCgpLFxuICAgIC8qKiBBbW91bnQgb2YgcGl4ZWxzIGluIGJvcmRlciB0byBsZWF2ZSAqL1xuICAgIGxlYXZlQm9yZGVyOiB6b2RfMS56Lm51bWJlcigpLm9wdGlvbmFsKCksXG4gICAgaWdub3JlU2lkZXM6IHpvZF8xLnpcbiAgICAgICAgLm9iamVjdCh7XG4gICAgICAgIG5vcnRoOiB6b2RfMS56LmJvb2xlYW4oKS5vcHRpb25hbCgpLFxuICAgICAgICBzb3V0aDogem9kXzEuei5ib29sZWFuKCkub3B0aW9uYWwoKSxcbiAgICAgICAgZWFzdDogem9kXzEuei5ib29sZWFuKCkub3B0aW9uYWwoKSxcbiAgICAgICAgd2VzdDogem9kXzEuei5ib29sZWFuKCkub3B0aW9uYWwoKSxcbiAgICB9KVxuICAgICAgICAub3B0aW9uYWwoKSxcbn0pO1xuZXhwb3J0cy5tZXRob2RzID0ge1xuICAgIC8qKlxuICAgICAqIENyb3BzIHRoZSBpbWFnZSBhdCBhIGdpdmVuIHBvaW50IHRvIGEgZ2l2ZSBzaXplLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIGltcG9ydCB7IEppbXAgfSBmcm9tIFwiamltcFwiO1xuICAgICAqXG4gICAgICogY29uc3QgaW1hZ2UgPSBhd2FpdCBKaW1wLnJlYWQoXCJ0ZXN0L2ltYWdlLnBuZ1wiKTtcbiAgICAgKiBjb25zdCBjcm9wcGVkID0gaW1hZ2UuY3JvcCgxNTAsIDEwMCk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgY3JvcChpbWFnZSwgb3B0aW9ucykge1xuICAgICAgICBsZXQgeyB4LCB5LCB3LCBoIH0gPSBleHBvcnRzLkNyb3BPcHRpb25zU2NoZW1hLnBhcnNlKG9wdGlvbnMpO1xuICAgICAgICAvLyByb3VuZCBpbnB1dFxuICAgICAgICB4ID0gTWF0aC5yb3VuZCh4KTtcbiAgICAgICAgeSA9IE1hdGgucm91bmQoeSk7XG4gICAgICAgIHcgPSBNYXRoLnJvdW5kKHcpO1xuICAgICAgICBoID0gTWF0aC5yb3VuZChoKTtcbiAgICAgICAgaWYgKHggPT09IDAgJiYgdyA9PT0gaW1hZ2UuYml0bWFwLndpZHRoKSB7XG4gICAgICAgICAgICAvLyBzaG9ydGN1dFxuICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSAodyAqIHkgKyB4KSA8PCAyO1xuICAgICAgICAgICAgY29uc3QgZW5kID0gc3RhcnQgKyAoKGggKiB3KSA8PCAyKTtcbiAgICAgICAgICAgIGltYWdlLmJpdG1hcC5kYXRhID0gaW1hZ2UuYml0bWFwLmRhdGEuc2xpY2Uoc3RhcnQsIGVuZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBiaXRtYXAgPSBCdWZmZXIuYWxsb2NVbnNhZmUodyAqIGggKiA0KTtcbiAgICAgICAgICAgIGxldCBvZmZzZXQgPSAwO1xuICAgICAgICAgICAgKDAsIHV0aWxzXzEuc2NhbikoaW1hZ2UsIHgsIHksIHcsIGgsIGZ1bmN0aW9uIChfLCBfXywgaWR4KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IGltYWdlLmJpdG1hcC5kYXRhLnJlYWRVSW50MzJCRShpZHgpO1xuICAgICAgICAgICAgICAgIGJpdG1hcC53cml0ZVVJbnQzMkJFKGRhdGEsIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IDQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGltYWdlLmJpdG1hcC5kYXRhID0gYml0bWFwO1xuICAgICAgICB9XG4gICAgICAgIGltYWdlLmJpdG1hcC53aWR0aCA9IHc7XG4gICAgICAgIGltYWdlLmJpdG1hcC5oZWlnaHQgPSBoO1xuICAgICAgICByZXR1cm4gaW1hZ2U7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBBdXRvY3JvcCBzYW1lIGNvbG9yIGJvcmRlcnMgZnJvbSB0aGlzIGltYWdlLlxuICAgICAqIFRoaXMgZnVuY3Rpb24gd2lsbCBhdHRlbXB0IHRvIGNyb3Agb3V0IHRyYW5zcGFyZW50IHBpeGVscyBmcm9tIHRoZSBpbWFnZS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBpbXBvcnQgeyBKaW1wIH0gZnJvbSBcImppbXBcIjtcbiAgICAgKlxuICAgICAqIGNvbnN0IGltYWdlID0gYXdhaXQgSmltcC5yZWFkKFwidGVzdC9pbWFnZS5wbmdcIik7XG4gICAgICogY29uc3QgY3JvcHBlZCA9IGltYWdlLmF1dG9jcm9wKCk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgYXV0b2Nyb3AoaW1hZ2UsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBjb25zdCB7IHRvbGVyYW5jZSA9IDAuMDAwMiwgY3JvcE9ubHlGcmFtZXMgPSB0cnVlLCBjcm9wU3ltbWV0cmljID0gZmFsc2UsIGxlYXZlQm9yZGVyID0gMCwgaWdub3JlU2lkZXM6IGlnbm9yZVNpZGVzQXJnLCB9ID0gdHlwZW9mIG9wdGlvbnMgPT09IFwibnVtYmVyXCJcbiAgICAgICAgICAgID8geyB0b2xlcmFuY2U6IG9wdGlvbnMgfVxuICAgICAgICAgICAgOiBBdXRvY3JvcENvbXBsZXhPcHRpb25zU2NoZW1hLnBhcnNlKG9wdGlvbnMpO1xuICAgICAgICBjb25zdCB3ID0gaW1hZ2UuYml0bWFwLndpZHRoO1xuICAgICAgICBjb25zdCBoID0gaW1hZ2UuYml0bWFwLmhlaWdodDtcbiAgICAgICAgY29uc3QgbWluUGl4ZWxzUGVyU2lkZSA9IDE7IC8vIHRvIGF2b2lkIGNyb3BwaW5nIGNvbXBsZXRlbHkgdGhlIGltYWdlLCByZXN1bHRpbmcgaW4gYW4gaW52YWxpZCAwIHNpemVkIGltYWdlXG4gICAgICAgIC8vIGkuZS4gbm9ydGggYW5kIHNvdXRoIC8gZWFzdCBhbmQgd2VzdCBhcmUgY3JvcHBlZCBieSB0aGUgc2FtZSB2YWx1ZVxuICAgICAgICBjb25zdCBpZ25vcmVTaWRlcyA9IHtcbiAgICAgICAgICAgIG5vcnRoOiBmYWxzZSxcbiAgICAgICAgICAgIHNvdXRoOiBmYWxzZSxcbiAgICAgICAgICAgIGVhc3Q6IGZhbHNlLFxuICAgICAgICAgICAgd2VzdDogZmFsc2UsXG4gICAgICAgICAgICAuLi5pZ25vcmVTaWRlc0FyZyxcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFsbCBib3JkZXJzIG11c3QgYmUgb2YgdGhlIHNhbWUgY29sb3IgYXMgdGhlIHRvcCBsZWZ0IHBpeGVsLCB0byBiZSBjcm9wcGVkLlxuICAgICAgICAgKiBJdCBzaG91bGQgYmUgcG9zc2libGUgdG8gY3JvcCBib3JkZXJzIGVhY2ggd2l0aCBhIGRpZmZlcmVudCBjb2xvcixcbiAgICAgICAgICogYnV0IHNpbmNlIHRoZXJlIGFyZSBtYW55IHdheXMgZm9yIGNvcm5lcnMgdG8gaW50ZXJzZWN0LCBpdCB3b3VsZFxuICAgICAgICAgKiBpbnRyb2R1Y2UgdW5uZWNlc3NhcnkgY29tcGxleGl0eSB0byB0aGUgYWxnb3JpdGhtLlxuICAgICAgICAgKi9cbiAgICAgICAgLy8gc2NhbiBlYWNoIHNpZGUgZm9yIHNhbWUgY29sb3IgYm9yZGVyc1xuICAgICAgICBsZXQgY29sb3JUYXJnZXQgPSBpbWFnZS5nZXRQaXhlbENvbG9yKDAsIDApOyAvLyB0b3AgbGVmdCBwaXhlbCBjb2xvciBpcyB0aGUgdGFyZ2V0IGNvbG9yXG4gICAgICAgIGNvbnN0IHJnYmExID0gKDAsIHV0aWxzXzEuaW50VG9SR0JBKShjb2xvclRhcmdldCk7XG4gICAgICAgIC8vIGZvciBub3J0aCBhbmQgZWFzdCBzaWRlc1xuICAgICAgICBsZXQgbm9ydGhQaXhlbHNUb0Nyb3AgPSAwO1xuICAgICAgICBsZXQgZWFzdFBpeGVsc1RvQ3JvcCA9IDA7XG4gICAgICAgIGxldCBzb3V0aFBpeGVsc1RvQ3JvcCA9IDA7XG4gICAgICAgIGxldCB3ZXN0UGl4ZWxzVG9Dcm9wID0gMDtcbiAgICAgICAgLy8gbm9ydGggc2lkZSAoc2NhbiByb3dzIGZyb20gbm9ydGggdG8gc291dGgpXG4gICAgICAgIGNvbG9yVGFyZ2V0ID0gaW1hZ2UuZ2V0UGl4ZWxDb2xvcigwLCAwKTtcbiAgICAgICAgaWYgKCFpZ25vcmVTaWRlcy5ub3J0aCkge1xuICAgICAgICAgICAgbm9ydGg6IGZvciAobGV0IHkgPSAwOyB5IDwgaCAtIG1pblBpeGVsc1BlclNpZGU7IHkrKykge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgdzsgeCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbG9yWFkgPSBpbWFnZS5nZXRQaXhlbENvbG9yKHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZ2JhMiA9ICgwLCB1dGlsc18xLmludFRvUkdCQSkoY29sb3JYWSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICgoMCwgdXRpbHNfMS5jb2xvckRpZmYpKHJnYmExLCByZ2JhMikgPiB0b2xlcmFuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgcGl4ZWwgaXMgdG9vIGRpc3RhbnQgZnJvbSB0aGUgZmlyc3Qgb25lOiBhYm9ydCB0aGlzIHNpZGUgc2NhblxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgbm9ydGg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gdGhpcyByb3cgY29udGFpbnMgYWxsIHBpeGVscyB3aXRoIHRoZSBzYW1lIGNvbG9yOiBpbmNyZW1lbnQgdGhpcyBzaWRlIHBpeGVscyB0byBjcm9wXG4gICAgICAgICAgICAgICAgbm9ydGhQaXhlbHNUb0Nyb3ArKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyB3ZXN0IHNpZGUgKHNjYW4gY29sdW1ucyBmcm9tIHdlc3QgdG8gZWFzdClcbiAgICAgICAgY29sb3JUYXJnZXQgPSBpbWFnZS5nZXRQaXhlbENvbG9yKHcsIDApO1xuICAgICAgICBpZiAoIWlnbm9yZVNpZGVzLndlc3QpIHtcbiAgICAgICAgICAgIHdlc3Q6IGZvciAobGV0IHggPSAwOyB4IDwgdyAtIG1pblBpeGVsc1BlclNpZGU7IHgrKykge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHkgPSAwICsgbm9ydGhQaXhlbHNUb0Nyb3A7IHkgPCBoOyB5KyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29sb3JYWSA9IGltYWdlLmdldFBpeGVsQ29sb3IoeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJnYmEyID0gKDAsIHV0aWxzXzEuaW50VG9SR0JBKShjb2xvclhZKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCgwLCB1dGlsc18xLmNvbG9yRGlmZikocmdiYTEsIHJnYmEyKSA+IHRvbGVyYW5jZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBwaXhlbCBpcyB0b28gZGlzdGFudCBmcm9tIHRoZSBmaXJzdCBvbmU6IGFib3J0IHRoaXMgc2lkZSBzY2FuXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhayB3ZXN0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHRoaXMgY29sdW1uIGNvbnRhaW5zIGFsbCBwaXhlbHMgd2l0aCB0aGUgc2FtZSBjb2xvcjogaW5jcmVtZW50IHRoaXMgc2lkZSBwaXhlbHMgdG8gY3JvcFxuICAgICAgICAgICAgICAgIHdlc3RQaXhlbHNUb0Nyb3ArKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBzb3V0aCBzaWRlIChzY2FuIHJvd3MgZnJvbSBzb3V0aCB0byBub3J0aClcbiAgICAgICAgY29sb3JUYXJnZXQgPSBpbWFnZS5nZXRQaXhlbENvbG9yKDAsIGgpO1xuICAgICAgICBpZiAoIWlnbm9yZVNpZGVzLnNvdXRoKSB7XG4gICAgICAgICAgICBzb3V0aDogZm9yIChsZXQgeSA9IGggLSAxOyB5ID49IG5vcnRoUGl4ZWxzVG9Dcm9wICsgbWluUGl4ZWxzUGVyU2lkZTsgeS0tKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgeCA9IHcgLSBlYXN0UGl4ZWxzVG9Dcm9wIC0gMTsgeCA+PSAwOyB4LS0pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29sb3JYWSA9IGltYWdlLmdldFBpeGVsQ29sb3IoeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJnYmEyID0gKDAsIHV0aWxzXzEuaW50VG9SR0JBKShjb2xvclhZKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCgwLCB1dGlsc18xLmNvbG9yRGlmZikocmdiYTEsIHJnYmEyKSA+IHRvbGVyYW5jZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBwaXhlbCBpcyB0b28gZGlzdGFudCBmcm9tIHRoZSBmaXJzdCBvbmU6IGFib3J0IHRoaXMgc2lkZSBzY2FuXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhayBzb3V0aDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyB0aGlzIHJvdyBjb250YWlucyBhbGwgcGl4ZWxzIHdpdGggdGhlIHNhbWUgY29sb3I6IGluY3JlbWVudCB0aGlzIHNpZGUgcGl4ZWxzIHRvIGNyb3BcbiAgICAgICAgICAgICAgICBzb3V0aFBpeGVsc1RvQ3JvcCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGVhc3Qgc2lkZSAoc2NhbiBjb2x1bW5zIGZyb20gZWFzdCB0byB3ZXN0KVxuICAgICAgICBjb2xvclRhcmdldCA9IGltYWdlLmdldFBpeGVsQ29sb3IodywgaCk7XG4gICAgICAgIGlmICghaWdub3JlU2lkZXMuZWFzdCkge1xuICAgICAgICAgICAgZWFzdDogZm9yIChsZXQgeCA9IHcgLSAxOyB4ID49IDAgKyB3ZXN0UGl4ZWxzVG9Dcm9wICsgbWluUGl4ZWxzUGVyU2lkZTsgeC0tKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgeSA9IGggLSAxOyB5ID49IDAgKyBub3J0aFBpeGVsc1RvQ3JvcDsgeS0tKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbG9yWFkgPSBpbWFnZS5nZXRQaXhlbENvbG9yKHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZ2JhMiA9ICgwLCB1dGlsc18xLmludFRvUkdCQSkoY29sb3JYWSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICgoMCwgdXRpbHNfMS5jb2xvckRpZmYpKHJnYmExLCByZ2JhMikgPiB0b2xlcmFuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgcGl4ZWwgaXMgdG9vIGRpc3RhbnQgZnJvbSB0aGUgZmlyc3Qgb25lOiBhYm9ydCB0aGlzIHNpZGUgc2NhblxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgZWFzdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyB0aGlzIGNvbHVtbiBjb250YWlucyBhbGwgcGl4ZWxzIHdpdGggdGhlIHNhbWUgY29sb3I6IGluY3JlbWVudCB0aGlzIHNpZGUgcGl4ZWxzIHRvIGNyb3BcbiAgICAgICAgICAgICAgICBlYXN0UGl4ZWxzVG9Dcm9wKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gZGVjaWRlIGlmIGEgY3JvcCBpcyBuZWVkZWRcbiAgICAgICAgbGV0IGRvQ3JvcCA9IGZhbHNlO1xuICAgICAgICAvLyBhcHBseSBsZWF2ZUJvcmRlclxuICAgICAgICB3ZXN0UGl4ZWxzVG9Dcm9wIC09IGxlYXZlQm9yZGVyO1xuICAgICAgICBlYXN0UGl4ZWxzVG9Dcm9wIC09IGxlYXZlQm9yZGVyO1xuICAgICAgICBub3J0aFBpeGVsc1RvQ3JvcCAtPSBsZWF2ZUJvcmRlcjtcbiAgICAgICAgc291dGhQaXhlbHNUb0Nyb3AgLT0gbGVhdmVCb3JkZXI7XG4gICAgICAgIGlmIChjcm9wU3ltbWV0cmljKSB7XG4gICAgICAgICAgICBjb25zdCBob3Jpem9udGFsID0gTWF0aC5taW4oZWFzdFBpeGVsc1RvQ3JvcCwgd2VzdFBpeGVsc1RvQ3JvcCk7XG4gICAgICAgICAgICBjb25zdCB2ZXJ0aWNhbCA9IE1hdGgubWluKG5vcnRoUGl4ZWxzVG9Dcm9wLCBzb3V0aFBpeGVsc1RvQ3JvcCk7XG4gICAgICAgICAgICB3ZXN0UGl4ZWxzVG9Dcm9wID0gaG9yaXpvbnRhbDtcbiAgICAgICAgICAgIGVhc3RQaXhlbHNUb0Nyb3AgPSBob3Jpem9udGFsO1xuICAgICAgICAgICAgbm9ydGhQaXhlbHNUb0Nyb3AgPSB2ZXJ0aWNhbDtcbiAgICAgICAgICAgIHNvdXRoUGl4ZWxzVG9Dcm9wID0gdmVydGljYWw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbWFrZSBzdXJlIHRoYXQgY3JvcHMgYXJlID49IDBcbiAgICAgICAgd2VzdFBpeGVsc1RvQ3JvcCA9IHdlc3RQaXhlbHNUb0Nyb3AgPj0gMCA/IHdlc3RQaXhlbHNUb0Nyb3AgOiAwO1xuICAgICAgICBlYXN0UGl4ZWxzVG9Dcm9wID0gZWFzdFBpeGVsc1RvQ3JvcCA+PSAwID8gZWFzdFBpeGVsc1RvQ3JvcCA6IDA7XG4gICAgICAgIG5vcnRoUGl4ZWxzVG9Dcm9wID0gbm9ydGhQaXhlbHNUb0Nyb3AgPj0gMCA/IG5vcnRoUGl4ZWxzVG9Dcm9wIDogMDtcbiAgICAgICAgc291dGhQaXhlbHNUb0Nyb3AgPSBzb3V0aFBpeGVsc1RvQ3JvcCA+PSAwID8gc291dGhQaXhlbHNUb0Nyb3AgOiAwO1xuICAgICAgICAvLyBzYWZldHkgY2hlY2tzXG4gICAgICAgIGNvbnN0IHdpZHRoT2ZSZW1haW5pbmdQaXhlbHMgPSB3IC0gKHdlc3RQaXhlbHNUb0Nyb3AgKyBlYXN0UGl4ZWxzVG9Dcm9wKTtcbiAgICAgICAgY29uc3QgaGVpZ2h0T2ZSZW1haW5pbmdQaXhlbHMgPSBoIC0gKHNvdXRoUGl4ZWxzVG9Dcm9wICsgbm9ydGhQaXhlbHNUb0Nyb3ApO1xuICAgICAgICBpZiAoY3JvcE9ubHlGcmFtZXMpIHtcbiAgICAgICAgICAgIC8vIGNyb3AgaW1hZ2UgaWYgYWxsIHNpZGVzIHNob3VsZCBiZSBjcm9wcGVkXG4gICAgICAgICAgICBkb0Nyb3AgPVxuICAgICAgICAgICAgICAgIGVhc3RQaXhlbHNUb0Nyb3AgIT09IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgbm9ydGhQaXhlbHNUb0Nyb3AgIT09IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgd2VzdFBpeGVsc1RvQ3JvcCAhPT0gMCAmJlxuICAgICAgICAgICAgICAgICAgICBzb3V0aFBpeGVsc1RvQ3JvcCAhPT0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGNyb3AgaW1hZ2UgaWYgYXQgbGVhc3Qgb25lIHNpZGUgc2hvdWxkIGJlIGNyb3BwZWRcbiAgICAgICAgICAgIGRvQ3JvcCA9XG4gICAgICAgICAgICAgICAgZWFzdFBpeGVsc1RvQ3JvcCAhPT0gMCB8fFxuICAgICAgICAgICAgICAgICAgICBub3J0aFBpeGVsc1RvQ3JvcCAhPT0gMCB8fFxuICAgICAgICAgICAgICAgICAgICB3ZXN0UGl4ZWxzVG9Dcm9wICE9PSAwIHx8XG4gICAgICAgICAgICAgICAgICAgIHNvdXRoUGl4ZWxzVG9Dcm9wICE9PSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkb0Nyb3ApIHtcbiAgICAgICAgICAgIC8vIGRvIHRoZSByZWFsIGNyb3BcbiAgICAgICAgICAgIHRoaXMuY3JvcChpbWFnZSwge1xuICAgICAgICAgICAgICAgIHg6IHdlc3RQaXhlbHNUb0Nyb3AsXG4gICAgICAgICAgICAgICAgeTogbm9ydGhQaXhlbHNUb0Nyb3AsXG4gICAgICAgICAgICAgICAgdzogd2lkdGhPZlJlbWFpbmluZ1BpeGVscyxcbiAgICAgICAgICAgICAgICBoOiBoZWlnaHRPZlJlbWFpbmluZ1BpeGVscyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbWFnZTtcbiAgICB9LFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@jimp+plugin-crop@1.6.0/node_modules/@jimp/plugin-crop/dist/commonjs/index.js\n");

/***/ })

};
;