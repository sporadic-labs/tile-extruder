"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@jimp+plugin-color@1.6.0";
exports.ids = ["vendor-chunks/@jimp+plugin-color@1.6.0"];
exports.modules = {

/***/ "(ssr)/../../node_modules/.pnpm/@jimp+plugin-color@1.6.0/node_modules/@jimp/plugin-color/dist/commonjs/index.js":
/*!****************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@jimp+plugin-color@1.6.0/node_modules/@jimp/plugin-color/dist/commonjs/index.js ***!
  \****************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.methods = exports.ColorActionName = void 0;\nconst tinycolor2_1 = __importDefault(__webpack_require__(/*! tinycolor2 */ \"(ssr)/../../node_modules/.pnpm/tinycolor2@1.6.0/node_modules/tinycolor2/cjs/tinycolor.js\"));\nconst utils_1 = __webpack_require__(/*! @jimp/utils */ \"(ssr)/../../node_modules/.pnpm/@jimp+utils@1.6.0/node_modules/@jimp/utils/dist/commonjs/index.js\");\nconst types_1 = __webpack_require__(/*! @jimp/types */ \"(ssr)/../../node_modules/.pnpm/@jimp+types@1.6.0/node_modules/@jimp/types/dist/commonjs/index.js\");\nconst zod_1 = __webpack_require__(/*! zod */ \"(ssr)/../../node_modules/.pnpm/zod@3.24.1/node_modules/zod/lib/index.js\");\nconst ConvolutionMatrixSchema = zod_1.z.array(zod_1.z.number()).min(1).array();\nconst ConvolutionComplexOptionsSchema = zod_1.z.object({\n    /** a matrix to weight the neighbors sum */\n    kernel: ConvolutionMatrixSchema,\n    /**define how to sum pixels from outside the border */\n    edgeHandling: zod_1.z.nativeEnum(types_1.Edge).optional(),\n});\nconst ConvolutionOptionsSchema = zod_1.z.union([\n    ConvolutionMatrixSchema,\n    ConvolutionComplexOptionsSchema,\n]);\nconst ConvoluteComplexOptionsSchema = zod_1.z.object({\n    /** the convolution kernel */\n    kernel: ConvolutionMatrixSchema,\n    /** the x position of the region to apply convolution to */\n    x: zod_1.z.number().optional(),\n    /** the y position of the region to apply convolution to */\n    y: zod_1.z.number().optional(),\n    /** the width of the region to apply convolution to */\n    w: zod_1.z.number().optional(),\n    /** the height of the region to apply convolution to */\n    h: zod_1.z.number().optional(),\n});\nconst ConvoluteOptionsSchema = zod_1.z.union([\n    ConvolutionMatrixSchema,\n    ConvoluteComplexOptionsSchema,\n]);\nconst PixelateSize = zod_1.z.number().min(1).max(Infinity);\nconst PixelateComplexOptionsSchema = zod_1.z.object({\n    /** the size of the pixels */\n    size: PixelateSize,\n    /** the x position of the region to pixelate */\n    x: zod_1.z.number().optional(),\n    /** the y position of the region to pixelate */\n    y: zod_1.z.number().optional(),\n    /** the width of the region to pixelate */\n    w: zod_1.z.number().optional(),\n    /** the height of the region to pixelate */\n    h: zod_1.z.number().optional(),\n});\nconst PixelateOptionsSchema = zod_1.z.union([\n    PixelateSize,\n    PixelateComplexOptionsSchema,\n]);\nfunction applyKernel(image, kernel, x, y) {\n    const value = [0, 0, 0, 0];\n    const size = (kernel.length - 1) / 2;\n    for (let kx = 0; kx < kernel.length; kx += 1) {\n        for (let ky = 0; ky < kernel[kx].length; ky += 1) {\n            const idx = image.getPixelIndex(x + kx - size, y + ky - size);\n            value[0] += image.bitmap.data[idx] * kernel[kx][ky];\n            value[1] += image.bitmap.data[idx + 1] * kernel[kx][ky];\n            value[2] += image.bitmap.data[idx + 2] * kernel[kx][ky];\n            value[3] += image.bitmap.data[idx + 3] * kernel[kx][ky];\n        }\n    }\n    return value;\n}\nfunction mix(clr, clr2, p = 50) {\n    return {\n        r: (clr2.r - clr.r) * (p / 100) + clr.r,\n        g: (clr2.g - clr.g) * (p / 100) + clr.g,\n        b: (clr2.b - clr.b) * (p / 100) + clr.b,\n    };\n}\nconst HueActionSchema = zod_1.z.object({\n    apply: zod_1.z.literal(\"hue\"),\n    params: zod_1.z.tuple([zod_1.z.number().min(-360).max(360)]),\n});\nconst SpinActionSchema = zod_1.z.object({\n    apply: zod_1.z.literal(\"spin\"),\n    params: zod_1.z.tuple([zod_1.z.number().min(-360).max(360)]),\n});\nconst LightenActionSchema = zod_1.z.object({\n    apply: zod_1.z.literal(\"lighten\"),\n    params: zod_1.z.tuple([zod_1.z.number().min(0).max(100)]).optional(),\n});\nconst RGBColorSchema = zod_1.z.object({\n    r: zod_1.z.number().min(0).max(255),\n    g: zod_1.z.number().min(0).max(255),\n    b: zod_1.z.number().min(0).max(255),\n});\nconst MixActionSchema = zod_1.z.object({\n    apply: zod_1.z.literal(\"mix\"),\n    params: zod_1.z.union([\n        zod_1.z.tuple([RGBColorSchema]),\n        zod_1.z.tuple([RGBColorSchema, zod_1.z.number().min(0).max(100)]),\n    ]),\n});\nconst TintActionSchema = zod_1.z.object({\n    apply: zod_1.z.literal(\"tint\"),\n    params: zod_1.z.tuple([zod_1.z.number().min(0).max(100)]).optional(),\n});\nconst ShadeActionSchema = zod_1.z.object({\n    apply: zod_1.z.literal(\"shade\"),\n    params: zod_1.z.tuple([zod_1.z.number().min(0).max(100)]).optional(),\n});\nconst XorActionSchema = zod_1.z.object({\n    apply: zod_1.z.literal(\"xor\"),\n    params: zod_1.z.tuple([RGBColorSchema]),\n});\nconst RedActionSchema = zod_1.z.object({\n    apply: zod_1.z.literal(\"red\"),\n    params: zod_1.z.tuple([zod_1.z.number().min(-255).max(255)]),\n});\nconst GreenActionSchema = zod_1.z.object({\n    apply: zod_1.z.literal(\"green\"),\n    params: zod_1.z.tuple([zod_1.z.number().min(-255).max(255)]),\n});\nconst BlueActionSchema = zod_1.z.object({\n    apply: zod_1.z.literal(\"blue\"),\n    params: zod_1.z.tuple([zod_1.z.number().min(-255).max(255)]),\n});\nconst BrightenActionSchema = zod_1.z.object({\n    apply: zod_1.z.literal(\"brighten\"),\n    params: zod_1.z.tuple([zod_1.z.number().min(0).max(100)]).optional(),\n});\nconst DarkenActionSchema = zod_1.z.object({\n    apply: zod_1.z.literal(\"darken\"),\n    params: zod_1.z.tuple([zod_1.z.number().min(0).max(100)]).optional(),\n});\nconst DesaturateActionSchema = zod_1.z.object({\n    apply: zod_1.z.literal(\"desaturate\"),\n    params: zod_1.z.tuple([zod_1.z.number().min(0).max(100)]).optional(),\n});\nconst SaturateActionSchema = zod_1.z.object({\n    apply: zod_1.z.literal(\"saturate\"),\n    params: zod_1.z.tuple([zod_1.z.number().min(0).max(100)]).optional(),\n});\nconst GrayscaleActionSchema = zod_1.z.object({\n    apply: zod_1.z.literal(\"greyscale\"),\n    params: zod_1.z.tuple([]).optional(),\n});\nconst ColorActionNameSchema = zod_1.z.union([\n    HueActionSchema,\n    SpinActionSchema,\n    LightenActionSchema,\n    MixActionSchema,\n    TintActionSchema,\n    ShadeActionSchema,\n    XorActionSchema,\n    RedActionSchema,\n    GreenActionSchema,\n    BlueActionSchema,\n    BrightenActionSchema,\n    DarkenActionSchema,\n    DesaturateActionSchema,\n    SaturateActionSchema,\n    GrayscaleActionSchema,\n]);\nexports.ColorActionName = Object.freeze({\n    LIGHTEN: \"lighten\",\n    BRIGHTEN: \"brighten\",\n    DARKEN: \"darken\",\n    DESATURATE: \"desaturate\",\n    SATURATE: \"saturate\",\n    GREYSCALE: \"greyscale\",\n    SPIN: \"spin\",\n    HUE: \"hue\",\n    MIX: \"mix\",\n    TINT: \"tint\",\n    SHADE: \"shade\",\n    XOR: \"xor\",\n    RED: \"red\",\n    GREEN: \"green\",\n    BLUE: \"blue\",\n});\n/**\n * Get an image's histogram\n * @return An object with an array of color occurrence counts for each channel (r,g,b)\n */\nfunction histogram(image) {\n    const histogram = {\n        r: new Array(256).fill(0),\n        g: new Array(256).fill(0),\n        b: new Array(256).fill(0),\n    };\n    image.scan((_, __, index) => {\n        histogram.r[image.bitmap.data[index + 0]]++;\n        histogram.g[image.bitmap.data[index + 1]]++;\n        histogram.b[image.bitmap.data[index + 2]]++;\n    });\n    return histogram;\n}\n/**\n * Normalize values\n * @param  value Pixel channel value.\n * @param  min   Minimum value for channel\n * @param  max   Maximum value for channel\n */\nconst normalizeValue = function (value, min, max) {\n    return ((value - min) * 255) / (max - min);\n};\nconst getBounds = function (histogramChannel) {\n    return [\n        histogramChannel.findIndex((value) => value > 0),\n        255 -\n            histogramChannel\n                .slice()\n                .reverse()\n                .findIndex((value) => value > 0),\n    ];\n};\nexports.methods = {\n    /**\n     * Normalizes the image.\n     * @example\n     * ```ts\n     * import { Jimp } from \"jimp\";\n     *\n     * const image = await Jimp.read(\"test/image.png\");\n     *\n     * image.normalize();\n     * ```\n     */\n    normalize(image) {\n        const h = histogram(image);\n        // store bounds (minimum and maximum values)\n        const bounds = {\n            r: getBounds(h.r),\n            g: getBounds(h.g),\n            b: getBounds(h.b),\n        };\n        // apply value transformations\n        image.scan((_, __, idx) => {\n            const r = image.bitmap.data[idx + 0];\n            const g = image.bitmap.data[idx + 1];\n            const b = image.bitmap.data[idx + 2];\n            image.bitmap.data[idx + 0] = normalizeValue(r, bounds.r[0], bounds.r[1]);\n            image.bitmap.data[idx + 1] = normalizeValue(g, bounds.g[0], bounds.g[1]);\n            image.bitmap.data[idx + 2] = normalizeValue(b, bounds.b[0], bounds.b[1]);\n        });\n        return image;\n    },\n    /**\n     * Inverts the colors in the image.\n     * @example\n     * ```ts\n     * import { Jimp } from \"jimp\";\n     *\n     * const image = await Jimp.read(\"test/image.png\");\n     *\n     * image.invert();\n     * ```\n     */\n    invert(image) {\n        image.scan((_, __, idx) => {\n            image.bitmap.data[idx] = 255 - image.bitmap.data[idx];\n            image.bitmap.data[idx + 1] = 255 - image.bitmap.data[idx + 1];\n            image.bitmap.data[idx + 2] = 255 - image.bitmap.data[idx + 2];\n        });\n        return image;\n    },\n    /**\n     * Adjusts the brightness of the image\n     * @param val the amount to adjust the brightness.\n     * @example\n     * ```ts\n     * import { Jimp } from \"jimp\";\n     *\n     * const image = await Jimp.read(\"test/image.png\");\n     *\n     * image.brightness(0.5);\n     * ```\n     */\n    brightness(image, val) {\n        if (typeof val !== \"number\") {\n            throw new Error(\"val must be numbers\");\n        }\n        image.scan((_, __, idx) => {\n            image.bitmap.data[idx] = (0, utils_1.limit255)(image.bitmap.data[idx] * val);\n            image.bitmap.data[idx + 1] = (0, utils_1.limit255)(image.bitmap.data[idx + 1] * val);\n            image.bitmap.data[idx + 2] = (0, utils_1.limit255)(image.bitmap.data[idx + 2] * val);\n        });\n        return image;\n    },\n    /**\n     * Adjusts the contrast of the image\n     * @param val the amount to adjust the contrast, a number between -1 and +1\n     * @example\n     * ```ts\n     * import { Jimp } from \"jimp\";\n     *\n     * const image = await Jimp.read(\"test/image.png\");\n     *\n     * image.contrast(0.75);\n     * ```\n     */\n    contrast(image, val) {\n        if (typeof val !== \"number\") {\n            throw new Error(\"val must be numbers\");\n        }\n        if (val < -1 || val > +1) {\n            throw new Error(\"val must be a number between -1 and +1\");\n        }\n        const factor = (val + 1) / (1 - val);\n        function adjust(value) {\n            value = Math.floor(factor * (value - 127) + 127);\n            return value < 0 ? 0 : value > 255 ? 255 : value;\n        }\n        image.scan((_, __, idx) => {\n            image.bitmap.data[idx] = adjust(image.bitmap.data[idx]);\n            image.bitmap.data[idx + 1] = adjust(image.bitmap.data[idx + 1]);\n            image.bitmap.data[idx + 2] = adjust(image.bitmap.data[idx + 2]);\n        });\n        return image;\n    },\n    /**\n     * Apply a posterize effect\n     * @param  n the amount to adjust the contrast, minimum threshold is two\n     * @example\n     * ```ts\n     * import { Jimp } from \"jimp\";\n     *\n     * const image = await Jimp.read(\"test/image.png\");\n     *\n     * image.posterize(5);\n     * ```\n     */\n    posterize(image, n) {\n        if (typeof n !== \"number\") {\n            throw new Error(\"n must be numbers\");\n        }\n        // minimum of 2 levels\n        if (n < 2) {\n            n = 2;\n        }\n        image.scan((_, __, idx) => {\n            const r = image.bitmap.data[idx];\n            const g = image.bitmap.data[idx + 1];\n            const b = image.bitmap.data[idx + 2];\n            image.bitmap.data[idx] =\n                (Math.floor((r / 255) * (n - 1)) / (n - 1)) * 255;\n            image.bitmap.data[idx + 1] =\n                (Math.floor((g / 255) * (n - 1)) / (n - 1)) * 255;\n            image.bitmap.data[idx + 2] =\n                (Math.floor((b / 255) * (n - 1)) / (n - 1)) * 255;\n        });\n        return image;\n    },\n    /**\n     * Removes colour from the image using ITU Rec 709 luminance values\n     * @example\n     * ```ts\n     * import { Jimp } from \"jimp\";\n     *\n     * const image = await Jimp.read(\"test/image.png\");\n     *\n     * image.greyscale();\n     * ```\n     */\n    greyscale(image) {\n        image.scan((_, __, idx) => {\n            // const grey = parseInt(\n            //   0.2126 * image.bitmap.data[idx]! +\n            //     0.7152 * image.bitmap.data[idx + 1]! +\n            //     0.0722 * image.bitmap.data[idx + 2]!,\n            //   10\n            // );\n            const grey = 0.2126 * image.bitmap.data[idx] +\n                0.7152 * image.bitmap.data[idx + 1] +\n                0.0722 * image.bitmap.data[idx + 2];\n            image.bitmap.data[idx] = grey;\n            image.bitmap.data[idx + 1] = grey;\n            image.bitmap.data[idx + 2] = grey;\n        });\n        return image;\n    },\n    /**\n     * Multiplies the opacity of each pixel by a factor between 0 and 1\n     * @param f A number, the factor by which to multiply the opacity of each pixel\n     * @example\n     * ```ts\n     * import { Jimp } from \"jimp\";\n     *\n     * const image = await Jimp.read(\"test/image.png\");\n     *\n     * image.opacity(0.5);\n     * ```\n     */\n    opacity(image, f) {\n        if (typeof f !== \"number\") {\n            throw new Error(\"f must be a number\");\n        }\n        if (f < 0 || f > 1) {\n            throw new Error(\"f must be a number from 0 to 1\");\n        }\n        image.scan((_, __, idx) => {\n            const v = image.bitmap.data[idx + 3] * f;\n            image.bitmap.data[idx + 3] = v;\n        });\n        return image;\n    },\n    /**\n     * Applies a sepia tone to the image.\n     * @example\n     * ```ts\n     * import { Jimp } from \"jimp\";\n     *\n     * const image = await Jimp.read(\"test/image.png\");\n     *\n     * image.sepia();\n     * ```\n     */\n    sepia(image) {\n        image.scan((_, __, idx) => {\n            let red = image.bitmap.data[idx];\n            let green = image.bitmap.data[idx + 1];\n            let blue = image.bitmap.data[idx + 2];\n            red = red * 0.393 + green * 0.769 + blue * 0.189;\n            green = red * 0.349 + green * 0.686 + blue * 0.168;\n            blue = red * 0.272 + green * 0.534 + blue * 0.131;\n            image.bitmap.data[idx] = red < 255 ? red : 255;\n            image.bitmap.data[idx + 1] = green < 255 ? green : 255;\n            image.bitmap.data[idx + 2] = blue < 255 ? blue : 255;\n        });\n        return image;\n    },\n    /**\n     * Fades each pixel by a factor between 0 and 1\n     * @param f A number from 0 to 1. 0 will haven no effect. 1 will turn the image completely transparent.\n     * @example\n     * ```ts\n     * import { Jimp } from \"jimp\";\n     *\n     * const image = await Jimp.read(\"test/image.png\");\n     *\n     * image.fade(0.7);\n     * ```\n     */\n    fade(image, f) {\n        if (typeof f !== \"number\") {\n            throw new Error(\"f must be a number\");\n        }\n        if (f < 0 || f > 1) {\n            throw new Error(\"f must be a number from 0 to 1\");\n        }\n        // this method is an alternative to opacity (which may be deprecated)\n        return this.opacity(image, 1 - f);\n    },\n    /**\n     * Adds each element of the image to its local neighbors, weighted by the kernel\n     * @example\n     * ```ts\n     * import { Jimp } from \"jimp\";\n     *\n     * const image = await Jimp.read(\"test/image.png\");\n     *\n     * image.convolute([\n     *   [-1, -1, 0],\n     *   [-1, 1, 1],\n     *   [0, 1, 1],\n     * ]);\n     * ```\n     */\n    convolution(image, options) {\n        const parsed = ConvolutionOptionsSchema.parse(options);\n        const { kernel, edgeHandling = types_1.Edge.EXTEND } = \"kernel\" in parsed ? parsed : { kernel: parsed, edgeHandling: undefined };\n        if (!kernel[0]) {\n            throw new Error(\"kernel must be a matrix\");\n        }\n        const newData = Buffer.from(image.bitmap.data);\n        const kRows = kernel.length;\n        const kCols = kernel[0].length;\n        const rowEnd = Math.floor(kRows / 2);\n        const colEnd = Math.floor(kCols / 2);\n        const rowIni = -rowEnd;\n        const colIni = -colEnd;\n        let weight;\n        let rSum;\n        let gSum;\n        let bSum;\n        let ri;\n        let gi;\n        let bi;\n        let xi;\n        let yi;\n        let idxi;\n        image.scan((x, y, idx) => {\n            bSum = 0;\n            gSum = 0;\n            rSum = 0;\n            for (let row = rowIni; row <= rowEnd; row++) {\n                for (let col = colIni; col <= colEnd; col++) {\n                    xi = x + col;\n                    yi = y + row;\n                    weight = kernel[row + rowEnd][col + colEnd];\n                    idxi = image.getPixelIndex(xi, yi, edgeHandling);\n                    if (idxi === -1) {\n                        bi = 0;\n                        gi = 0;\n                        ri = 0;\n                    }\n                    else {\n                        ri = image.bitmap.data[idxi + 0];\n                        gi = image.bitmap.data[idxi + 1];\n                        bi = image.bitmap.data[idxi + 2];\n                    }\n                    rSum += weight * ri;\n                    gSum += weight * gi;\n                    bSum += weight * bi;\n                }\n            }\n            if (rSum < 0) {\n                rSum = 0;\n            }\n            if (gSum < 0) {\n                gSum = 0;\n            }\n            if (bSum < 0) {\n                bSum = 0;\n            }\n            if (rSum > 255) {\n                rSum = 255;\n            }\n            if (gSum > 255) {\n                gSum = 255;\n            }\n            if (bSum > 255) {\n                bSum = 255;\n            }\n            newData[idx + 0] = rSum;\n            newData[idx + 1] = gSum;\n            newData[idx + 2] = bSum;\n        });\n        image.bitmap.data = newData;\n        return image;\n    },\n    /**\n     * Set the alpha channel on every pixel to fully opaque.\n     * @example\n     * ```ts\n     * import { Jimp } from \"jimp\";\n     *\n     * const image = await Jimp.read(\"test/image.png\");\n     *\n     * image.opaque();\n     * ```\n     */\n    opaque(image) {\n        image.scan((_, __, idx) => {\n            image.bitmap.data[idx + 3] = 255;\n        });\n        return image;\n    },\n    /**\n     * Pixelates the image or a region\n     * @example\n     * ```ts\n     * import { Jimp } from \"jimp\";\n     *\n     * const image = await Jimp.read(\"test/image.png\");\n     *\n     * // pixelate the whole image\n     * image.pixelate(10);\n     *\n     * // pixelate a region\n     * image.pixelate(10, 10, 10, 20, 20);\n     * ```\n     */\n    pixelate(image, options) {\n        const parsed = PixelateOptionsSchema.parse(options);\n        const { size, x = 0, y = 0, w = image.bitmap.width - x, h = image.bitmap.height - y, } = typeof parsed === \"number\"\n            ? { size: parsed }\n            : parsed;\n        const kernel = [\n            [1 / 16, 2 / 16, 1 / 16],\n            [2 / 16, 4 / 16, 2 / 16],\n            [1 / 16, 2 / 16, 1 / 16],\n        ];\n        const source = (0, utils_1.clone)(image);\n        (0, utils_1.scan)(source, x, y, w, h, (xx, yx, idx) => {\n            xx = size * Math.floor(xx / size);\n            yx = size * Math.floor(yx / size);\n            const value = applyKernel(source, kernel, xx, yx);\n            image.bitmap.data[idx] = value[0];\n            image.bitmap.data[idx + 1] = value[1];\n            image.bitmap.data[idx + 2] = value[2];\n            image.bitmap.data[idx + 3] = value[3];\n        });\n        return image;\n    },\n    /**\n     * Applies a convolution kernel to the image or a region\n     * @example\n     * ```ts\n     * import { Jimp } from \"jimp\";\n     *\n     * const image = await Jimp.read(\"test/image.png\");\n     *\n     * // apply a convolution kernel to the whole image\n     * image.convolution([\n     *   [-1, -1, 0],\n     *   [-1, 1, 1],\n     *   [0, 1, 1],\n     * ]);\n     *\n     * // apply a convolution kernel to a region\n     * image.convolution([\n     *   [-1, -1, 0],\n     *   [-1, 1, 1],\n     *   [0, 1, 1],\n     * ], 10, 10, 10, 20);\n     * ```\n     */\n    convolute(image, options) {\n        const parsed = ConvoluteOptionsSchema.parse(options);\n        const { kernel, x = 0, y = 0, w = image.bitmap.width - x, h = image.bitmap.height - y, } = \"kernel\" in parsed\n            ? parsed\n            : { kernel: parsed };\n        const source = (0, utils_1.clone)(image);\n        (0, utils_1.scan)(source, x, y, w, h, (xx, yx, idx) => {\n            const value = applyKernel(source, kernel, xx, yx);\n            image.bitmap.data[idx] = (0, utils_1.limit255)(value[0]);\n            image.bitmap.data[idx + 1] = (0, utils_1.limit255)(value[1]);\n            image.bitmap.data[idx + 2] = (0, utils_1.limit255)(value[2]);\n            image.bitmap.data[idx + 3] = (0, utils_1.limit255)(value[3]);\n        });\n        return image;\n    },\n    /**\n     * Apply multiple color modification rules\n     * @param  actions list of color modification rules, in following format: { apply: '<rule-name>', params: [ <rule-parameters> ]  }\n     * @example\n     * ```ts\n     * import { Jimp } from \"jimp\";\n     *\n     * const image = await Jimp.read(\"test/image.png\");\n     *\n     * image.color([\n     *   { apply: \"hue\", params: [-90] },\n     *   { apply: \"lighten\", params: [50] },\n     *   { apply: \"xor\", params: [\"#06D\"] },\n     * ]);\n     * ```\n     */\n    color(image, actions) {\n        if (!actions || !Array.isArray(actions)) {\n            throw new Error(\"actions must be an array\");\n        }\n        actions.forEach((action) => ColorActionNameSchema.parse(action));\n        actions = actions.map((action) => {\n            if (action.apply === \"xor\" || action.apply === \"mix\") {\n                action.params[0] = (0, tinycolor2_1.default)(action.params[0]).toRgb();\n            }\n            return action;\n        });\n        image.scan((_, __, idx) => {\n            let clr = {\n                r: image.bitmap.data[idx],\n                g: image.bitmap.data[idx + 1],\n                b: image.bitmap.data[idx + 2],\n            };\n            const colorModifier = (i, amount) => (0, utils_1.limit255)(clr[i] + amount);\n            actions.forEach((action) => {\n                if (action.apply === \"mix\") {\n                    clr = mix(clr, action.params[0], action.params[1]);\n                }\n                else if (action.apply === \"tint\") {\n                    clr = mix(clr, { r: 255, g: 255, b: 255 }, action.params?.[0]);\n                }\n                else if (action.apply === \"shade\") {\n                    clr = mix(clr, { r: 0, g: 0, b: 0 }, action.params?.[0]);\n                }\n                else if (action.apply === \"xor\") {\n                    clr = {\n                        r: clr.r ^ action.params[0].r,\n                        g: clr.g ^ action.params[0].g,\n                        b: clr.b ^ action.params[0].b,\n                    };\n                }\n                else if (action.apply === \"red\") {\n                    clr.r = colorModifier(\"r\", action.params[0]);\n                }\n                else if (action.apply === \"green\") {\n                    clr.g = colorModifier(\"g\", action.params[0]);\n                }\n                else if (action.apply === \"blue\") {\n                    clr.b = colorModifier(\"b\", action.params[0]);\n                }\n                else {\n                    if (action.apply === \"hue\") {\n                        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n                        // @ts-ignore\n                        action.apply = \"spin\";\n                    }\n                    const tnyClr = (0, tinycolor2_1.default)(clr);\n                    const fn = tnyClr[action.apply].bind(tnyClr);\n                    if (!fn) {\n                        throw new Error(\"action \" + action.apply + \" not supported\");\n                    }\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                    clr = fn(...(action.params || [])).toRgb();\n                }\n            });\n            image.bitmap.data[idx] = clr.r;\n            image.bitmap.data[idx + 1] = clr.g;\n            image.bitmap.data[idx + 2] = clr.b;\n        });\n        return image;\n    },\n};\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BqaW1wK3BsdWdpbi1jb2xvckAxLjYuMC9ub2RlX21vZHVsZXMvQGppbXAvcGx1Z2luLWNvbG9yL2Rpc3QvY29tbW9uanMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxlQUFlLEdBQUcsdUJBQXVCO0FBQ3pDLHFDQUFxQyxtQkFBTyxDQUFDLDRHQUFZO0FBQ3pELGdCQUFnQixtQkFBTyxDQUFDLHFIQUFhO0FBQ3JDLGdCQUFnQixtQkFBTyxDQUFDLHFIQUFhO0FBQ3JDLGNBQWMsbUJBQU8sQ0FBQyxvRkFBSztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG9CQUFvQjtBQUN6Qyx5QkFBeUIsd0JBQXdCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw2Q0FBNkMsa0NBQWtDO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxlQUFlO0FBQ2xELHVDQUF1QyxlQUFlO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsK0VBQStFO0FBQy9GLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGlGQUFpRjtBQUNqRztBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsZ0ZBQWdGO0FBQ2hGO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsNkJBQTZCO0FBQ3hDLFdBQVcsZ0NBQWdDO0FBQzNDLFdBQVcsZ0NBQWdDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyx3QkFBd0I7QUFDN0Q7QUFDQTtBQUNBLHFDQUFxQyxrQkFBa0I7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9taWtld2VzdGhhZC9EZXNrdG9wL1JlcG9zL3Nwb3JhZGljLWxhYnMtdGlsZS1leHRydWRlci9ub2RlX21vZHVsZXMvLnBucG0vQGppbXArcGx1Z2luLWNvbG9yQDEuNi4wL25vZGVfbW9kdWxlcy9AamltcC9wbHVnaW4tY29sb3IvZGlzdC9jb21tb25qcy9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMubWV0aG9kcyA9IGV4cG9ydHMuQ29sb3JBY3Rpb25OYW1lID0gdm9pZCAwO1xuY29uc3QgdGlueWNvbG9yMl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJ0aW55Y29sb3IyXCIpKTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiQGppbXAvdXRpbHNcIik7XG5jb25zdCB0eXBlc18xID0gcmVxdWlyZShcIkBqaW1wL3R5cGVzXCIpO1xuY29uc3Qgem9kXzEgPSByZXF1aXJlKFwiem9kXCIpO1xuY29uc3QgQ29udm9sdXRpb25NYXRyaXhTY2hlbWEgPSB6b2RfMS56LmFycmF5KHpvZF8xLnoubnVtYmVyKCkpLm1pbigxKS5hcnJheSgpO1xuY29uc3QgQ29udm9sdXRpb25Db21wbGV4T3B0aW9uc1NjaGVtYSA9IHpvZF8xLnoub2JqZWN0KHtcbiAgICAvKiogYSBtYXRyaXggdG8gd2VpZ2h0IHRoZSBuZWlnaGJvcnMgc3VtICovXG4gICAga2VybmVsOiBDb252b2x1dGlvbk1hdHJpeFNjaGVtYSxcbiAgICAvKipkZWZpbmUgaG93IHRvIHN1bSBwaXhlbHMgZnJvbSBvdXRzaWRlIHRoZSBib3JkZXIgKi9cbiAgICBlZGdlSGFuZGxpbmc6IHpvZF8xLnoubmF0aXZlRW51bSh0eXBlc18xLkVkZ2UpLm9wdGlvbmFsKCksXG59KTtcbmNvbnN0IENvbnZvbHV0aW9uT3B0aW9uc1NjaGVtYSA9IHpvZF8xLnoudW5pb24oW1xuICAgIENvbnZvbHV0aW9uTWF0cml4U2NoZW1hLFxuICAgIENvbnZvbHV0aW9uQ29tcGxleE9wdGlvbnNTY2hlbWEsXG5dKTtcbmNvbnN0IENvbnZvbHV0ZUNvbXBsZXhPcHRpb25zU2NoZW1hID0gem9kXzEuei5vYmplY3Qoe1xuICAgIC8qKiB0aGUgY29udm9sdXRpb24ga2VybmVsICovXG4gICAga2VybmVsOiBDb252b2x1dGlvbk1hdHJpeFNjaGVtYSxcbiAgICAvKiogdGhlIHggcG9zaXRpb24gb2YgdGhlIHJlZ2lvbiB0byBhcHBseSBjb252b2x1dGlvbiB0byAqL1xuICAgIHg6IHpvZF8xLnoubnVtYmVyKCkub3B0aW9uYWwoKSxcbiAgICAvKiogdGhlIHkgcG9zaXRpb24gb2YgdGhlIHJlZ2lvbiB0byBhcHBseSBjb252b2x1dGlvbiB0byAqL1xuICAgIHk6IHpvZF8xLnoubnVtYmVyKCkub3B0aW9uYWwoKSxcbiAgICAvKiogdGhlIHdpZHRoIG9mIHRoZSByZWdpb24gdG8gYXBwbHkgY29udm9sdXRpb24gdG8gKi9cbiAgICB3OiB6b2RfMS56Lm51bWJlcigpLm9wdGlvbmFsKCksXG4gICAgLyoqIHRoZSBoZWlnaHQgb2YgdGhlIHJlZ2lvbiB0byBhcHBseSBjb252b2x1dGlvbiB0byAqL1xuICAgIGg6IHpvZF8xLnoubnVtYmVyKCkub3B0aW9uYWwoKSxcbn0pO1xuY29uc3QgQ29udm9sdXRlT3B0aW9uc1NjaGVtYSA9IHpvZF8xLnoudW5pb24oW1xuICAgIENvbnZvbHV0aW9uTWF0cml4U2NoZW1hLFxuICAgIENvbnZvbHV0ZUNvbXBsZXhPcHRpb25zU2NoZW1hLFxuXSk7XG5jb25zdCBQaXhlbGF0ZVNpemUgPSB6b2RfMS56Lm51bWJlcigpLm1pbigxKS5tYXgoSW5maW5pdHkpO1xuY29uc3QgUGl4ZWxhdGVDb21wbGV4T3B0aW9uc1NjaGVtYSA9IHpvZF8xLnoub2JqZWN0KHtcbiAgICAvKiogdGhlIHNpemUgb2YgdGhlIHBpeGVscyAqL1xuICAgIHNpemU6IFBpeGVsYXRlU2l6ZSxcbiAgICAvKiogdGhlIHggcG9zaXRpb24gb2YgdGhlIHJlZ2lvbiB0byBwaXhlbGF0ZSAqL1xuICAgIHg6IHpvZF8xLnoubnVtYmVyKCkub3B0aW9uYWwoKSxcbiAgICAvKiogdGhlIHkgcG9zaXRpb24gb2YgdGhlIHJlZ2lvbiB0byBwaXhlbGF0ZSAqL1xuICAgIHk6IHpvZF8xLnoubnVtYmVyKCkub3B0aW9uYWwoKSxcbiAgICAvKiogdGhlIHdpZHRoIG9mIHRoZSByZWdpb24gdG8gcGl4ZWxhdGUgKi9cbiAgICB3OiB6b2RfMS56Lm51bWJlcigpLm9wdGlvbmFsKCksXG4gICAgLyoqIHRoZSBoZWlnaHQgb2YgdGhlIHJlZ2lvbiB0byBwaXhlbGF0ZSAqL1xuICAgIGg6IHpvZF8xLnoubnVtYmVyKCkub3B0aW9uYWwoKSxcbn0pO1xuY29uc3QgUGl4ZWxhdGVPcHRpb25zU2NoZW1hID0gem9kXzEuei51bmlvbihbXG4gICAgUGl4ZWxhdGVTaXplLFxuICAgIFBpeGVsYXRlQ29tcGxleE9wdGlvbnNTY2hlbWEsXG5dKTtcbmZ1bmN0aW9uIGFwcGx5S2VybmVsKGltYWdlLCBrZXJuZWwsIHgsIHkpIHtcbiAgICBjb25zdCB2YWx1ZSA9IFswLCAwLCAwLCAwXTtcbiAgICBjb25zdCBzaXplID0gKGtlcm5lbC5sZW5ndGggLSAxKSAvIDI7XG4gICAgZm9yIChsZXQga3ggPSAwOyBreCA8IGtlcm5lbC5sZW5ndGg7IGt4ICs9IDEpIHtcbiAgICAgICAgZm9yIChsZXQga3kgPSAwOyBreSA8IGtlcm5lbFtreF0ubGVuZ3RoOyBreSArPSAxKSB7XG4gICAgICAgICAgICBjb25zdCBpZHggPSBpbWFnZS5nZXRQaXhlbEluZGV4KHggKyBreCAtIHNpemUsIHkgKyBreSAtIHNpemUpO1xuICAgICAgICAgICAgdmFsdWVbMF0gKz0gaW1hZ2UuYml0bWFwLmRhdGFbaWR4XSAqIGtlcm5lbFtreF1ba3ldO1xuICAgICAgICAgICAgdmFsdWVbMV0gKz0gaW1hZ2UuYml0bWFwLmRhdGFbaWR4ICsgMV0gKiBrZXJuZWxba3hdW2t5XTtcbiAgICAgICAgICAgIHZhbHVlWzJdICs9IGltYWdlLmJpdG1hcC5kYXRhW2lkeCArIDJdICoga2VybmVsW2t4XVtreV07XG4gICAgICAgICAgICB2YWx1ZVszXSArPSBpbWFnZS5iaXRtYXAuZGF0YVtpZHggKyAzXSAqIGtlcm5lbFtreF1ba3ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIG1peChjbHIsIGNscjIsIHAgPSA1MCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHI6IChjbHIyLnIgLSBjbHIucikgKiAocCAvIDEwMCkgKyBjbHIucixcbiAgICAgICAgZzogKGNscjIuZyAtIGNsci5nKSAqIChwIC8gMTAwKSArIGNsci5nLFxuICAgICAgICBiOiAoY2xyMi5iIC0gY2xyLmIpICogKHAgLyAxMDApICsgY2xyLmIsXG4gICAgfTtcbn1cbmNvbnN0IEh1ZUFjdGlvblNjaGVtYSA9IHpvZF8xLnoub2JqZWN0KHtcbiAgICBhcHBseTogem9kXzEuei5saXRlcmFsKFwiaHVlXCIpLFxuICAgIHBhcmFtczogem9kXzEuei50dXBsZShbem9kXzEuei5udW1iZXIoKS5taW4oLTM2MCkubWF4KDM2MCldKSxcbn0pO1xuY29uc3QgU3BpbkFjdGlvblNjaGVtYSA9IHpvZF8xLnoub2JqZWN0KHtcbiAgICBhcHBseTogem9kXzEuei5saXRlcmFsKFwic3BpblwiKSxcbiAgICBwYXJhbXM6IHpvZF8xLnoudHVwbGUoW3pvZF8xLnoubnVtYmVyKCkubWluKC0zNjApLm1heCgzNjApXSksXG59KTtcbmNvbnN0IExpZ2h0ZW5BY3Rpb25TY2hlbWEgPSB6b2RfMS56Lm9iamVjdCh7XG4gICAgYXBwbHk6IHpvZF8xLnoubGl0ZXJhbChcImxpZ2h0ZW5cIiksXG4gICAgcGFyYW1zOiB6b2RfMS56LnR1cGxlKFt6b2RfMS56Lm51bWJlcigpLm1pbigwKS5tYXgoMTAwKV0pLm9wdGlvbmFsKCksXG59KTtcbmNvbnN0IFJHQkNvbG9yU2NoZW1hID0gem9kXzEuei5vYmplY3Qoe1xuICAgIHI6IHpvZF8xLnoubnVtYmVyKCkubWluKDApLm1heCgyNTUpLFxuICAgIGc6IHpvZF8xLnoubnVtYmVyKCkubWluKDApLm1heCgyNTUpLFxuICAgIGI6IHpvZF8xLnoubnVtYmVyKCkubWluKDApLm1heCgyNTUpLFxufSk7XG5jb25zdCBNaXhBY3Rpb25TY2hlbWEgPSB6b2RfMS56Lm9iamVjdCh7XG4gICAgYXBwbHk6IHpvZF8xLnoubGl0ZXJhbChcIm1peFwiKSxcbiAgICBwYXJhbXM6IHpvZF8xLnoudW5pb24oW1xuICAgICAgICB6b2RfMS56LnR1cGxlKFtSR0JDb2xvclNjaGVtYV0pLFxuICAgICAgICB6b2RfMS56LnR1cGxlKFtSR0JDb2xvclNjaGVtYSwgem9kXzEuei5udW1iZXIoKS5taW4oMCkubWF4KDEwMCldKSxcbiAgICBdKSxcbn0pO1xuY29uc3QgVGludEFjdGlvblNjaGVtYSA9IHpvZF8xLnoub2JqZWN0KHtcbiAgICBhcHBseTogem9kXzEuei5saXRlcmFsKFwidGludFwiKSxcbiAgICBwYXJhbXM6IHpvZF8xLnoudHVwbGUoW3pvZF8xLnoubnVtYmVyKCkubWluKDApLm1heCgxMDApXSkub3B0aW9uYWwoKSxcbn0pO1xuY29uc3QgU2hhZGVBY3Rpb25TY2hlbWEgPSB6b2RfMS56Lm9iamVjdCh7XG4gICAgYXBwbHk6IHpvZF8xLnoubGl0ZXJhbChcInNoYWRlXCIpLFxuICAgIHBhcmFtczogem9kXzEuei50dXBsZShbem9kXzEuei5udW1iZXIoKS5taW4oMCkubWF4KDEwMCldKS5vcHRpb25hbCgpLFxufSk7XG5jb25zdCBYb3JBY3Rpb25TY2hlbWEgPSB6b2RfMS56Lm9iamVjdCh7XG4gICAgYXBwbHk6IHpvZF8xLnoubGl0ZXJhbChcInhvclwiKSxcbiAgICBwYXJhbXM6IHpvZF8xLnoudHVwbGUoW1JHQkNvbG9yU2NoZW1hXSksXG59KTtcbmNvbnN0IFJlZEFjdGlvblNjaGVtYSA9IHpvZF8xLnoub2JqZWN0KHtcbiAgICBhcHBseTogem9kXzEuei5saXRlcmFsKFwicmVkXCIpLFxuICAgIHBhcmFtczogem9kXzEuei50dXBsZShbem9kXzEuei5udW1iZXIoKS5taW4oLTI1NSkubWF4KDI1NSldKSxcbn0pO1xuY29uc3QgR3JlZW5BY3Rpb25TY2hlbWEgPSB6b2RfMS56Lm9iamVjdCh7XG4gICAgYXBwbHk6IHpvZF8xLnoubGl0ZXJhbChcImdyZWVuXCIpLFxuICAgIHBhcmFtczogem9kXzEuei50dXBsZShbem9kXzEuei5udW1iZXIoKS5taW4oLTI1NSkubWF4KDI1NSldKSxcbn0pO1xuY29uc3QgQmx1ZUFjdGlvblNjaGVtYSA9IHpvZF8xLnoub2JqZWN0KHtcbiAgICBhcHBseTogem9kXzEuei5saXRlcmFsKFwiYmx1ZVwiKSxcbiAgICBwYXJhbXM6IHpvZF8xLnoudHVwbGUoW3pvZF8xLnoubnVtYmVyKCkubWluKC0yNTUpLm1heCgyNTUpXSksXG59KTtcbmNvbnN0IEJyaWdodGVuQWN0aW9uU2NoZW1hID0gem9kXzEuei5vYmplY3Qoe1xuICAgIGFwcGx5OiB6b2RfMS56LmxpdGVyYWwoXCJicmlnaHRlblwiKSxcbiAgICBwYXJhbXM6IHpvZF8xLnoudHVwbGUoW3pvZF8xLnoubnVtYmVyKCkubWluKDApLm1heCgxMDApXSkub3B0aW9uYWwoKSxcbn0pO1xuY29uc3QgRGFya2VuQWN0aW9uU2NoZW1hID0gem9kXzEuei5vYmplY3Qoe1xuICAgIGFwcGx5OiB6b2RfMS56LmxpdGVyYWwoXCJkYXJrZW5cIiksXG4gICAgcGFyYW1zOiB6b2RfMS56LnR1cGxlKFt6b2RfMS56Lm51bWJlcigpLm1pbigwKS5tYXgoMTAwKV0pLm9wdGlvbmFsKCksXG59KTtcbmNvbnN0IERlc2F0dXJhdGVBY3Rpb25TY2hlbWEgPSB6b2RfMS56Lm9iamVjdCh7XG4gICAgYXBwbHk6IHpvZF8xLnoubGl0ZXJhbChcImRlc2F0dXJhdGVcIiksXG4gICAgcGFyYW1zOiB6b2RfMS56LnR1cGxlKFt6b2RfMS56Lm51bWJlcigpLm1pbigwKS5tYXgoMTAwKV0pLm9wdGlvbmFsKCksXG59KTtcbmNvbnN0IFNhdHVyYXRlQWN0aW9uU2NoZW1hID0gem9kXzEuei5vYmplY3Qoe1xuICAgIGFwcGx5OiB6b2RfMS56LmxpdGVyYWwoXCJzYXR1cmF0ZVwiKSxcbiAgICBwYXJhbXM6IHpvZF8xLnoudHVwbGUoW3pvZF8xLnoubnVtYmVyKCkubWluKDApLm1heCgxMDApXSkub3B0aW9uYWwoKSxcbn0pO1xuY29uc3QgR3JheXNjYWxlQWN0aW9uU2NoZW1hID0gem9kXzEuei5vYmplY3Qoe1xuICAgIGFwcGx5OiB6b2RfMS56LmxpdGVyYWwoXCJncmV5c2NhbGVcIiksXG4gICAgcGFyYW1zOiB6b2RfMS56LnR1cGxlKFtdKS5vcHRpb25hbCgpLFxufSk7XG5jb25zdCBDb2xvckFjdGlvbk5hbWVTY2hlbWEgPSB6b2RfMS56LnVuaW9uKFtcbiAgICBIdWVBY3Rpb25TY2hlbWEsXG4gICAgU3BpbkFjdGlvblNjaGVtYSxcbiAgICBMaWdodGVuQWN0aW9uU2NoZW1hLFxuICAgIE1peEFjdGlvblNjaGVtYSxcbiAgICBUaW50QWN0aW9uU2NoZW1hLFxuICAgIFNoYWRlQWN0aW9uU2NoZW1hLFxuICAgIFhvckFjdGlvblNjaGVtYSxcbiAgICBSZWRBY3Rpb25TY2hlbWEsXG4gICAgR3JlZW5BY3Rpb25TY2hlbWEsXG4gICAgQmx1ZUFjdGlvblNjaGVtYSxcbiAgICBCcmlnaHRlbkFjdGlvblNjaGVtYSxcbiAgICBEYXJrZW5BY3Rpb25TY2hlbWEsXG4gICAgRGVzYXR1cmF0ZUFjdGlvblNjaGVtYSxcbiAgICBTYXR1cmF0ZUFjdGlvblNjaGVtYSxcbiAgICBHcmF5c2NhbGVBY3Rpb25TY2hlbWEsXG5dKTtcbmV4cG9ydHMuQ29sb3JBY3Rpb25OYW1lID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgTElHSFRFTjogXCJsaWdodGVuXCIsXG4gICAgQlJJR0hURU46IFwiYnJpZ2h0ZW5cIixcbiAgICBEQVJLRU46IFwiZGFya2VuXCIsXG4gICAgREVTQVRVUkFURTogXCJkZXNhdHVyYXRlXCIsXG4gICAgU0FUVVJBVEU6IFwic2F0dXJhdGVcIixcbiAgICBHUkVZU0NBTEU6IFwiZ3JleXNjYWxlXCIsXG4gICAgU1BJTjogXCJzcGluXCIsXG4gICAgSFVFOiBcImh1ZVwiLFxuICAgIE1JWDogXCJtaXhcIixcbiAgICBUSU5UOiBcInRpbnRcIixcbiAgICBTSEFERTogXCJzaGFkZVwiLFxuICAgIFhPUjogXCJ4b3JcIixcbiAgICBSRUQ6IFwicmVkXCIsXG4gICAgR1JFRU46IFwiZ3JlZW5cIixcbiAgICBCTFVFOiBcImJsdWVcIixcbn0pO1xuLyoqXG4gKiBHZXQgYW4gaW1hZ2UncyBoaXN0b2dyYW1cbiAqIEByZXR1cm4gQW4gb2JqZWN0IHdpdGggYW4gYXJyYXkgb2YgY29sb3Igb2NjdXJyZW5jZSBjb3VudHMgZm9yIGVhY2ggY2hhbm5lbCAocixnLGIpXG4gKi9cbmZ1bmN0aW9uIGhpc3RvZ3JhbShpbWFnZSkge1xuICAgIGNvbnN0IGhpc3RvZ3JhbSA9IHtcbiAgICAgICAgcjogbmV3IEFycmF5KDI1NikuZmlsbCgwKSxcbiAgICAgICAgZzogbmV3IEFycmF5KDI1NikuZmlsbCgwKSxcbiAgICAgICAgYjogbmV3IEFycmF5KDI1NikuZmlsbCgwKSxcbiAgICB9O1xuICAgIGltYWdlLnNjYW4oKF8sIF9fLCBpbmRleCkgPT4ge1xuICAgICAgICBoaXN0b2dyYW0ucltpbWFnZS5iaXRtYXAuZGF0YVtpbmRleCArIDBdXSsrO1xuICAgICAgICBoaXN0b2dyYW0uZ1tpbWFnZS5iaXRtYXAuZGF0YVtpbmRleCArIDFdXSsrO1xuICAgICAgICBoaXN0b2dyYW0uYltpbWFnZS5iaXRtYXAuZGF0YVtpbmRleCArIDJdXSsrO1xuICAgIH0pO1xuICAgIHJldHVybiBoaXN0b2dyYW07XG59XG4vKipcbiAqIE5vcm1hbGl6ZSB2YWx1ZXNcbiAqIEBwYXJhbSAgdmFsdWUgUGl4ZWwgY2hhbm5lbCB2YWx1ZS5cbiAqIEBwYXJhbSAgbWluICAgTWluaW11bSB2YWx1ZSBmb3IgY2hhbm5lbFxuICogQHBhcmFtICBtYXggICBNYXhpbXVtIHZhbHVlIGZvciBjaGFubmVsXG4gKi9cbmNvbnN0IG5vcm1hbGl6ZVZhbHVlID0gZnVuY3Rpb24gKHZhbHVlLCBtaW4sIG1heCkge1xuICAgIHJldHVybiAoKHZhbHVlIC0gbWluKSAqIDI1NSkgLyAobWF4IC0gbWluKTtcbn07XG5jb25zdCBnZXRCb3VuZHMgPSBmdW5jdGlvbiAoaGlzdG9ncmFtQ2hhbm5lbCkge1xuICAgIHJldHVybiBbXG4gICAgICAgIGhpc3RvZ3JhbUNoYW5uZWwuZmluZEluZGV4KCh2YWx1ZSkgPT4gdmFsdWUgPiAwKSxcbiAgICAgICAgMjU1IC1cbiAgICAgICAgICAgIGhpc3RvZ3JhbUNoYW5uZWxcbiAgICAgICAgICAgICAgICAuc2xpY2UoKVxuICAgICAgICAgICAgICAgIC5yZXZlcnNlKClcbiAgICAgICAgICAgICAgICAuZmluZEluZGV4KCh2YWx1ZSkgPT4gdmFsdWUgPiAwKSxcbiAgICBdO1xufTtcbmV4cG9ydHMubWV0aG9kcyA9IHtcbiAgICAvKipcbiAgICAgKiBOb3JtYWxpemVzIHRoZSBpbWFnZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHRzXG4gICAgICogaW1wb3J0IHsgSmltcCB9IGZyb20gXCJqaW1wXCI7XG4gICAgICpcbiAgICAgKiBjb25zdCBpbWFnZSA9IGF3YWl0IEppbXAucmVhZChcInRlc3QvaW1hZ2UucG5nXCIpO1xuICAgICAqXG4gICAgICogaW1hZ2Uubm9ybWFsaXplKCk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgbm9ybWFsaXplKGltYWdlKSB7XG4gICAgICAgIGNvbnN0IGggPSBoaXN0b2dyYW0oaW1hZ2UpO1xuICAgICAgICAvLyBzdG9yZSBib3VuZHMgKG1pbmltdW0gYW5kIG1heGltdW0gdmFsdWVzKVxuICAgICAgICBjb25zdCBib3VuZHMgPSB7XG4gICAgICAgICAgICByOiBnZXRCb3VuZHMoaC5yKSxcbiAgICAgICAgICAgIGc6IGdldEJvdW5kcyhoLmcpLFxuICAgICAgICAgICAgYjogZ2V0Qm91bmRzKGguYiksXG4gICAgICAgIH07XG4gICAgICAgIC8vIGFwcGx5IHZhbHVlIHRyYW5zZm9ybWF0aW9uc1xuICAgICAgICBpbWFnZS5zY2FuKChfLCBfXywgaWR4KSA9PiB7XG4gICAgICAgICAgICBjb25zdCByID0gaW1hZ2UuYml0bWFwLmRhdGFbaWR4ICsgMF07XG4gICAgICAgICAgICBjb25zdCBnID0gaW1hZ2UuYml0bWFwLmRhdGFbaWR4ICsgMV07XG4gICAgICAgICAgICBjb25zdCBiID0gaW1hZ2UuYml0bWFwLmRhdGFbaWR4ICsgMl07XG4gICAgICAgICAgICBpbWFnZS5iaXRtYXAuZGF0YVtpZHggKyAwXSA9IG5vcm1hbGl6ZVZhbHVlKHIsIGJvdW5kcy5yWzBdLCBib3VuZHMuclsxXSk7XG4gICAgICAgICAgICBpbWFnZS5iaXRtYXAuZGF0YVtpZHggKyAxXSA9IG5vcm1hbGl6ZVZhbHVlKGcsIGJvdW5kcy5nWzBdLCBib3VuZHMuZ1sxXSk7XG4gICAgICAgICAgICBpbWFnZS5iaXRtYXAuZGF0YVtpZHggKyAyXSA9IG5vcm1hbGl6ZVZhbHVlKGIsIGJvdW5kcy5iWzBdLCBib3VuZHMuYlsxXSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gaW1hZ2U7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBJbnZlcnRzIHRoZSBjb2xvcnMgaW4gdGhlIGltYWdlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBpbXBvcnQgeyBKaW1wIH0gZnJvbSBcImppbXBcIjtcbiAgICAgKlxuICAgICAqIGNvbnN0IGltYWdlID0gYXdhaXQgSmltcC5yZWFkKFwidGVzdC9pbWFnZS5wbmdcIik7XG4gICAgICpcbiAgICAgKiBpbWFnZS5pbnZlcnQoKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBpbnZlcnQoaW1hZ2UpIHtcbiAgICAgICAgaW1hZ2Uuc2NhbigoXywgX18sIGlkeCkgPT4ge1xuICAgICAgICAgICAgaW1hZ2UuYml0bWFwLmRhdGFbaWR4XSA9IDI1NSAtIGltYWdlLmJpdG1hcC5kYXRhW2lkeF07XG4gICAgICAgICAgICBpbWFnZS5iaXRtYXAuZGF0YVtpZHggKyAxXSA9IDI1NSAtIGltYWdlLmJpdG1hcC5kYXRhW2lkeCArIDFdO1xuICAgICAgICAgICAgaW1hZ2UuYml0bWFwLmRhdGFbaWR4ICsgMl0gPSAyNTUgLSBpbWFnZS5iaXRtYXAuZGF0YVtpZHggKyAyXTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBpbWFnZTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEFkanVzdHMgdGhlIGJyaWdodG5lc3Mgb2YgdGhlIGltYWdlXG4gICAgICogQHBhcmFtIHZhbCB0aGUgYW1vdW50IHRvIGFkanVzdCB0aGUgYnJpZ2h0bmVzcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHRzXG4gICAgICogaW1wb3J0IHsgSmltcCB9IGZyb20gXCJqaW1wXCI7XG4gICAgICpcbiAgICAgKiBjb25zdCBpbWFnZSA9IGF3YWl0IEppbXAucmVhZChcInRlc3QvaW1hZ2UucG5nXCIpO1xuICAgICAqXG4gICAgICogaW1hZ2UuYnJpZ2h0bmVzcygwLjUpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGJyaWdodG5lc3MoaW1hZ2UsIHZhbCkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbCAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidmFsIG11c3QgYmUgbnVtYmVyc1wiKTtcbiAgICAgICAgfVxuICAgICAgICBpbWFnZS5zY2FuKChfLCBfXywgaWR4KSA9PiB7XG4gICAgICAgICAgICBpbWFnZS5iaXRtYXAuZGF0YVtpZHhdID0gKDAsIHV0aWxzXzEubGltaXQyNTUpKGltYWdlLmJpdG1hcC5kYXRhW2lkeF0gKiB2YWwpO1xuICAgICAgICAgICAgaW1hZ2UuYml0bWFwLmRhdGFbaWR4ICsgMV0gPSAoMCwgdXRpbHNfMS5saW1pdDI1NSkoaW1hZ2UuYml0bWFwLmRhdGFbaWR4ICsgMV0gKiB2YWwpO1xuICAgICAgICAgICAgaW1hZ2UuYml0bWFwLmRhdGFbaWR4ICsgMl0gPSAoMCwgdXRpbHNfMS5saW1pdDI1NSkoaW1hZ2UuYml0bWFwLmRhdGFbaWR4ICsgMl0gKiB2YWwpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGltYWdlO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQWRqdXN0cyB0aGUgY29udHJhc3Qgb2YgdGhlIGltYWdlXG4gICAgICogQHBhcmFtIHZhbCB0aGUgYW1vdW50IHRvIGFkanVzdCB0aGUgY29udHJhc3QsIGEgbnVtYmVyIGJldHdlZW4gLTEgYW5kICsxXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIGltcG9ydCB7IEppbXAgfSBmcm9tIFwiamltcFwiO1xuICAgICAqXG4gICAgICogY29uc3QgaW1hZ2UgPSBhd2FpdCBKaW1wLnJlYWQoXCJ0ZXN0L2ltYWdlLnBuZ1wiKTtcbiAgICAgKlxuICAgICAqIGltYWdlLmNvbnRyYXN0KDAuNzUpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGNvbnRyYXN0KGltYWdlLCB2YWwpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWwgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInZhbCBtdXN0IGJlIG51bWJlcnNcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbCA8IC0xIHx8IHZhbCA+ICsxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ2YWwgbXVzdCBiZSBhIG51bWJlciBiZXR3ZWVuIC0xIGFuZCArMVwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmYWN0b3IgPSAodmFsICsgMSkgLyAoMSAtIHZhbCk7XG4gICAgICAgIGZ1bmN0aW9uIGFkanVzdCh2YWx1ZSkge1xuICAgICAgICAgICAgdmFsdWUgPSBNYXRoLmZsb29yKGZhY3RvciAqICh2YWx1ZSAtIDEyNykgKyAxMjcpO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlIDwgMCA/IDAgOiB2YWx1ZSA+IDI1NSA/IDI1NSA6IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGltYWdlLnNjYW4oKF8sIF9fLCBpZHgpID0+IHtcbiAgICAgICAgICAgIGltYWdlLmJpdG1hcC5kYXRhW2lkeF0gPSBhZGp1c3QoaW1hZ2UuYml0bWFwLmRhdGFbaWR4XSk7XG4gICAgICAgICAgICBpbWFnZS5iaXRtYXAuZGF0YVtpZHggKyAxXSA9IGFkanVzdChpbWFnZS5iaXRtYXAuZGF0YVtpZHggKyAxXSk7XG4gICAgICAgICAgICBpbWFnZS5iaXRtYXAuZGF0YVtpZHggKyAyXSA9IGFkanVzdChpbWFnZS5iaXRtYXAuZGF0YVtpZHggKyAyXSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gaW1hZ2U7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBBcHBseSBhIHBvc3Rlcml6ZSBlZmZlY3RcbiAgICAgKiBAcGFyYW0gIG4gdGhlIGFtb3VudCB0byBhZGp1c3QgdGhlIGNvbnRyYXN0LCBtaW5pbXVtIHRocmVzaG9sZCBpcyB0d29cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHRzXG4gICAgICogaW1wb3J0IHsgSmltcCB9IGZyb20gXCJqaW1wXCI7XG4gICAgICpcbiAgICAgKiBjb25zdCBpbWFnZSA9IGF3YWl0IEppbXAucmVhZChcInRlc3QvaW1hZ2UucG5nXCIpO1xuICAgICAqXG4gICAgICogaW1hZ2UucG9zdGVyaXplKDUpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHBvc3Rlcml6ZShpbWFnZSwgbikge1xuICAgICAgICBpZiAodHlwZW9mIG4gIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm4gbXVzdCBiZSBudW1iZXJzXCIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIG1pbmltdW0gb2YgMiBsZXZlbHNcbiAgICAgICAgaWYgKG4gPCAyKSB7XG4gICAgICAgICAgICBuID0gMjtcbiAgICAgICAgfVxuICAgICAgICBpbWFnZS5zY2FuKChfLCBfXywgaWR4KSA9PiB7XG4gICAgICAgICAgICBjb25zdCByID0gaW1hZ2UuYml0bWFwLmRhdGFbaWR4XTtcbiAgICAgICAgICAgIGNvbnN0IGcgPSBpbWFnZS5iaXRtYXAuZGF0YVtpZHggKyAxXTtcbiAgICAgICAgICAgIGNvbnN0IGIgPSBpbWFnZS5iaXRtYXAuZGF0YVtpZHggKyAyXTtcbiAgICAgICAgICAgIGltYWdlLmJpdG1hcC5kYXRhW2lkeF0gPVxuICAgICAgICAgICAgICAgIChNYXRoLmZsb29yKChyIC8gMjU1KSAqIChuIC0gMSkpIC8gKG4gLSAxKSkgKiAyNTU7XG4gICAgICAgICAgICBpbWFnZS5iaXRtYXAuZGF0YVtpZHggKyAxXSA9XG4gICAgICAgICAgICAgICAgKE1hdGguZmxvb3IoKGcgLyAyNTUpICogKG4gLSAxKSkgLyAobiAtIDEpKSAqIDI1NTtcbiAgICAgICAgICAgIGltYWdlLmJpdG1hcC5kYXRhW2lkeCArIDJdID1cbiAgICAgICAgICAgICAgICAoTWF0aC5mbG9vcigoYiAvIDI1NSkgKiAobiAtIDEpKSAvIChuIC0gMSkpICogMjU1O1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGltYWdlO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBjb2xvdXIgZnJvbSB0aGUgaW1hZ2UgdXNpbmcgSVRVIFJlYyA3MDkgbHVtaW5hbmNlIHZhbHVlc1xuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBpbXBvcnQgeyBKaW1wIH0gZnJvbSBcImppbXBcIjtcbiAgICAgKlxuICAgICAqIGNvbnN0IGltYWdlID0gYXdhaXQgSmltcC5yZWFkKFwidGVzdC9pbWFnZS5wbmdcIik7XG4gICAgICpcbiAgICAgKiBpbWFnZS5ncmV5c2NhbGUoKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBncmV5c2NhbGUoaW1hZ2UpIHtcbiAgICAgICAgaW1hZ2Uuc2NhbigoXywgX18sIGlkeCkgPT4ge1xuICAgICAgICAgICAgLy8gY29uc3QgZ3JleSA9IHBhcnNlSW50KFxuICAgICAgICAgICAgLy8gICAwLjIxMjYgKiBpbWFnZS5iaXRtYXAuZGF0YVtpZHhdISArXG4gICAgICAgICAgICAvLyAgICAgMC43MTUyICogaW1hZ2UuYml0bWFwLmRhdGFbaWR4ICsgMV0hICtcbiAgICAgICAgICAgIC8vICAgICAwLjA3MjIgKiBpbWFnZS5iaXRtYXAuZGF0YVtpZHggKyAyXSEsXG4gICAgICAgICAgICAvLyAgIDEwXG4gICAgICAgICAgICAvLyApO1xuICAgICAgICAgICAgY29uc3QgZ3JleSA9IDAuMjEyNiAqIGltYWdlLmJpdG1hcC5kYXRhW2lkeF0gK1xuICAgICAgICAgICAgICAgIDAuNzE1MiAqIGltYWdlLmJpdG1hcC5kYXRhW2lkeCArIDFdICtcbiAgICAgICAgICAgICAgICAwLjA3MjIgKiBpbWFnZS5iaXRtYXAuZGF0YVtpZHggKyAyXTtcbiAgICAgICAgICAgIGltYWdlLmJpdG1hcC5kYXRhW2lkeF0gPSBncmV5O1xuICAgICAgICAgICAgaW1hZ2UuYml0bWFwLmRhdGFbaWR4ICsgMV0gPSBncmV5O1xuICAgICAgICAgICAgaW1hZ2UuYml0bWFwLmRhdGFbaWR4ICsgMl0gPSBncmV5O1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGltYWdlO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogTXVsdGlwbGllcyB0aGUgb3BhY2l0eSBvZiBlYWNoIHBpeGVsIGJ5IGEgZmFjdG9yIGJldHdlZW4gMCBhbmQgMVxuICAgICAqIEBwYXJhbSBmIEEgbnVtYmVyLCB0aGUgZmFjdG9yIGJ5IHdoaWNoIHRvIG11bHRpcGx5IHRoZSBvcGFjaXR5IG9mIGVhY2ggcGl4ZWxcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHRzXG4gICAgICogaW1wb3J0IHsgSmltcCB9IGZyb20gXCJqaW1wXCI7XG4gICAgICpcbiAgICAgKiBjb25zdCBpbWFnZSA9IGF3YWl0IEppbXAucmVhZChcInRlc3QvaW1hZ2UucG5nXCIpO1xuICAgICAqXG4gICAgICogaW1hZ2Uub3BhY2l0eSgwLjUpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIG9wYWNpdHkoaW1hZ2UsIGYpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBmICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJmIG11c3QgYmUgYSBudW1iZXJcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGYgPCAwIHx8IGYgPiAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJmIG11c3QgYmUgYSBudW1iZXIgZnJvbSAwIHRvIDFcIik7XG4gICAgICAgIH1cbiAgICAgICAgaW1hZ2Uuc2NhbigoXywgX18sIGlkeCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdiA9IGltYWdlLmJpdG1hcC5kYXRhW2lkeCArIDNdICogZjtcbiAgICAgICAgICAgIGltYWdlLmJpdG1hcC5kYXRhW2lkeCArIDNdID0gdjtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBpbWFnZTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgYSBzZXBpYSB0b25lIHRvIHRoZSBpbWFnZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHRzXG4gICAgICogaW1wb3J0IHsgSmltcCB9IGZyb20gXCJqaW1wXCI7XG4gICAgICpcbiAgICAgKiBjb25zdCBpbWFnZSA9IGF3YWl0IEppbXAucmVhZChcInRlc3QvaW1hZ2UucG5nXCIpO1xuICAgICAqXG4gICAgICogaW1hZ2Uuc2VwaWEoKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBzZXBpYShpbWFnZSkge1xuICAgICAgICBpbWFnZS5zY2FuKChfLCBfXywgaWR4KSA9PiB7XG4gICAgICAgICAgICBsZXQgcmVkID0gaW1hZ2UuYml0bWFwLmRhdGFbaWR4XTtcbiAgICAgICAgICAgIGxldCBncmVlbiA9IGltYWdlLmJpdG1hcC5kYXRhW2lkeCArIDFdO1xuICAgICAgICAgICAgbGV0IGJsdWUgPSBpbWFnZS5iaXRtYXAuZGF0YVtpZHggKyAyXTtcbiAgICAgICAgICAgIHJlZCA9IHJlZCAqIDAuMzkzICsgZ3JlZW4gKiAwLjc2OSArIGJsdWUgKiAwLjE4OTtcbiAgICAgICAgICAgIGdyZWVuID0gcmVkICogMC4zNDkgKyBncmVlbiAqIDAuNjg2ICsgYmx1ZSAqIDAuMTY4O1xuICAgICAgICAgICAgYmx1ZSA9IHJlZCAqIDAuMjcyICsgZ3JlZW4gKiAwLjUzNCArIGJsdWUgKiAwLjEzMTtcbiAgICAgICAgICAgIGltYWdlLmJpdG1hcC5kYXRhW2lkeF0gPSByZWQgPCAyNTUgPyByZWQgOiAyNTU7XG4gICAgICAgICAgICBpbWFnZS5iaXRtYXAuZGF0YVtpZHggKyAxXSA9IGdyZWVuIDwgMjU1ID8gZ3JlZW4gOiAyNTU7XG4gICAgICAgICAgICBpbWFnZS5iaXRtYXAuZGF0YVtpZHggKyAyXSA9IGJsdWUgPCAyNTUgPyBibHVlIDogMjU1O1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGltYWdlO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogRmFkZXMgZWFjaCBwaXhlbCBieSBhIGZhY3RvciBiZXR3ZWVuIDAgYW5kIDFcbiAgICAgKiBAcGFyYW0gZiBBIG51bWJlciBmcm9tIDAgdG8gMS4gMCB3aWxsIGhhdmVuIG5vIGVmZmVjdC4gMSB3aWxsIHR1cm4gdGhlIGltYWdlIGNvbXBsZXRlbHkgdHJhbnNwYXJlbnQuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIGltcG9ydCB7IEppbXAgfSBmcm9tIFwiamltcFwiO1xuICAgICAqXG4gICAgICogY29uc3QgaW1hZ2UgPSBhd2FpdCBKaW1wLnJlYWQoXCJ0ZXN0L2ltYWdlLnBuZ1wiKTtcbiAgICAgKlxuICAgICAqIGltYWdlLmZhZGUoMC43KTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBmYWRlKGltYWdlLCBmKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZiAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZiBtdXN0IGJlIGEgbnVtYmVyXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmIDwgMCB8fCBmID4gMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZiBtdXN0IGJlIGEgbnVtYmVyIGZyb20gMCB0byAxXCIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRoaXMgbWV0aG9kIGlzIGFuIGFsdGVybmF0aXZlIHRvIG9wYWNpdHkgKHdoaWNoIG1heSBiZSBkZXByZWNhdGVkKVxuICAgICAgICByZXR1cm4gdGhpcy5vcGFjaXR5KGltYWdlLCAxIC0gZik7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBBZGRzIGVhY2ggZWxlbWVudCBvZiB0aGUgaW1hZ2UgdG8gaXRzIGxvY2FsIG5laWdoYm9ycywgd2VpZ2h0ZWQgYnkgdGhlIGtlcm5lbFxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBpbXBvcnQgeyBKaW1wIH0gZnJvbSBcImppbXBcIjtcbiAgICAgKlxuICAgICAqIGNvbnN0IGltYWdlID0gYXdhaXQgSmltcC5yZWFkKFwidGVzdC9pbWFnZS5wbmdcIik7XG4gICAgICpcbiAgICAgKiBpbWFnZS5jb252b2x1dGUoW1xuICAgICAqICAgWy0xLCAtMSwgMF0sXG4gICAgICogICBbLTEsIDEsIDFdLFxuICAgICAqICAgWzAsIDEsIDFdLFxuICAgICAqIF0pO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGNvbnZvbHV0aW9uKGltYWdlLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZCA9IENvbnZvbHV0aW9uT3B0aW9uc1NjaGVtYS5wYXJzZShvcHRpb25zKTtcbiAgICAgICAgY29uc3QgeyBrZXJuZWwsIGVkZ2VIYW5kbGluZyA9IHR5cGVzXzEuRWRnZS5FWFRFTkQgfSA9IFwia2VybmVsXCIgaW4gcGFyc2VkID8gcGFyc2VkIDogeyBrZXJuZWw6IHBhcnNlZCwgZWRnZUhhbmRsaW5nOiB1bmRlZmluZWQgfTtcbiAgICAgICAgaWYgKCFrZXJuZWxbMF0pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImtlcm5lbCBtdXN0IGJlIGEgbWF0cml4XCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5ld0RhdGEgPSBCdWZmZXIuZnJvbShpbWFnZS5iaXRtYXAuZGF0YSk7XG4gICAgICAgIGNvbnN0IGtSb3dzID0ga2VybmVsLmxlbmd0aDtcbiAgICAgICAgY29uc3Qga0NvbHMgPSBrZXJuZWxbMF0ubGVuZ3RoO1xuICAgICAgICBjb25zdCByb3dFbmQgPSBNYXRoLmZsb29yKGtSb3dzIC8gMik7XG4gICAgICAgIGNvbnN0IGNvbEVuZCA9IE1hdGguZmxvb3Ioa0NvbHMgLyAyKTtcbiAgICAgICAgY29uc3Qgcm93SW5pID0gLXJvd0VuZDtcbiAgICAgICAgY29uc3QgY29sSW5pID0gLWNvbEVuZDtcbiAgICAgICAgbGV0IHdlaWdodDtcbiAgICAgICAgbGV0IHJTdW07XG4gICAgICAgIGxldCBnU3VtO1xuICAgICAgICBsZXQgYlN1bTtcbiAgICAgICAgbGV0IHJpO1xuICAgICAgICBsZXQgZ2k7XG4gICAgICAgIGxldCBiaTtcbiAgICAgICAgbGV0IHhpO1xuICAgICAgICBsZXQgeWk7XG4gICAgICAgIGxldCBpZHhpO1xuICAgICAgICBpbWFnZS5zY2FuKCh4LCB5LCBpZHgpID0+IHtcbiAgICAgICAgICAgIGJTdW0gPSAwO1xuICAgICAgICAgICAgZ1N1bSA9IDA7XG4gICAgICAgICAgICByU3VtID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IHJvdyA9IHJvd0luaTsgcm93IDw9IHJvd0VuZDsgcm93KyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBjb2wgPSBjb2xJbmk7IGNvbCA8PSBjb2xFbmQ7IGNvbCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHhpID0geCArIGNvbDtcbiAgICAgICAgICAgICAgICAgICAgeWkgPSB5ICsgcm93O1xuICAgICAgICAgICAgICAgICAgICB3ZWlnaHQgPSBrZXJuZWxbcm93ICsgcm93RW5kXVtjb2wgKyBjb2xFbmRdO1xuICAgICAgICAgICAgICAgICAgICBpZHhpID0gaW1hZ2UuZ2V0UGl4ZWxJbmRleCh4aSwgeWksIGVkZ2VIYW5kbGluZyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpZHhpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmkgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2kgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmkgPSAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmkgPSBpbWFnZS5iaXRtYXAuZGF0YVtpZHhpICsgMF07XG4gICAgICAgICAgICAgICAgICAgICAgICBnaSA9IGltYWdlLmJpdG1hcC5kYXRhW2lkeGkgKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJpID0gaW1hZ2UuYml0bWFwLmRhdGFbaWR4aSArIDJdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJTdW0gKz0gd2VpZ2h0ICogcmk7XG4gICAgICAgICAgICAgICAgICAgIGdTdW0gKz0gd2VpZ2h0ICogZ2k7XG4gICAgICAgICAgICAgICAgICAgIGJTdW0gKz0gd2VpZ2h0ICogYmk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJTdW0gPCAwKSB7XG4gICAgICAgICAgICAgICAgclN1bSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ1N1bSA8IDApIHtcbiAgICAgICAgICAgICAgICBnU3VtID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChiU3VtIDwgMCkge1xuICAgICAgICAgICAgICAgIGJTdW0gPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJTdW0gPiAyNTUpIHtcbiAgICAgICAgICAgICAgICByU3VtID0gMjU1O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdTdW0gPiAyNTUpIHtcbiAgICAgICAgICAgICAgICBnU3VtID0gMjU1O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGJTdW0gPiAyNTUpIHtcbiAgICAgICAgICAgICAgICBiU3VtID0gMjU1O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV3RGF0YVtpZHggKyAwXSA9IHJTdW07XG4gICAgICAgICAgICBuZXdEYXRhW2lkeCArIDFdID0gZ1N1bTtcbiAgICAgICAgICAgIG5ld0RhdGFbaWR4ICsgMl0gPSBiU3VtO1xuICAgICAgICB9KTtcbiAgICAgICAgaW1hZ2UuYml0bWFwLmRhdGEgPSBuZXdEYXRhO1xuICAgICAgICByZXR1cm4gaW1hZ2U7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGFscGhhIGNoYW5uZWwgb24gZXZlcnkgcGl4ZWwgdG8gZnVsbHkgb3BhcXVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBpbXBvcnQgeyBKaW1wIH0gZnJvbSBcImppbXBcIjtcbiAgICAgKlxuICAgICAqIGNvbnN0IGltYWdlID0gYXdhaXQgSmltcC5yZWFkKFwidGVzdC9pbWFnZS5wbmdcIik7XG4gICAgICpcbiAgICAgKiBpbWFnZS5vcGFxdWUoKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBvcGFxdWUoaW1hZ2UpIHtcbiAgICAgICAgaW1hZ2Uuc2NhbigoXywgX18sIGlkeCkgPT4ge1xuICAgICAgICAgICAgaW1hZ2UuYml0bWFwLmRhdGFbaWR4ICsgM10gPSAyNTU7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gaW1hZ2U7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBQaXhlbGF0ZXMgdGhlIGltYWdlIG9yIGEgcmVnaW9uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIGltcG9ydCB7IEppbXAgfSBmcm9tIFwiamltcFwiO1xuICAgICAqXG4gICAgICogY29uc3QgaW1hZ2UgPSBhd2FpdCBKaW1wLnJlYWQoXCJ0ZXN0L2ltYWdlLnBuZ1wiKTtcbiAgICAgKlxuICAgICAqIC8vIHBpeGVsYXRlIHRoZSB3aG9sZSBpbWFnZVxuICAgICAqIGltYWdlLnBpeGVsYXRlKDEwKTtcbiAgICAgKlxuICAgICAqIC8vIHBpeGVsYXRlIGEgcmVnaW9uXG4gICAgICogaW1hZ2UucGl4ZWxhdGUoMTAsIDEwLCAxMCwgMjAsIDIwKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBwaXhlbGF0ZShpbWFnZSwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBwYXJzZWQgPSBQaXhlbGF0ZU9wdGlvbnNTY2hlbWEucGFyc2Uob3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IHsgc2l6ZSwgeCA9IDAsIHkgPSAwLCB3ID0gaW1hZ2UuYml0bWFwLndpZHRoIC0geCwgaCA9IGltYWdlLmJpdG1hcC5oZWlnaHQgLSB5LCB9ID0gdHlwZW9mIHBhcnNlZCA9PT0gXCJudW1iZXJcIlxuICAgICAgICAgICAgPyB7IHNpemU6IHBhcnNlZCB9XG4gICAgICAgICAgICA6IHBhcnNlZDtcbiAgICAgICAgY29uc3Qga2VybmVsID0gW1xuICAgICAgICAgICAgWzEgLyAxNiwgMiAvIDE2LCAxIC8gMTZdLFxuICAgICAgICAgICAgWzIgLyAxNiwgNCAvIDE2LCAyIC8gMTZdLFxuICAgICAgICAgICAgWzEgLyAxNiwgMiAvIDE2LCAxIC8gMTZdLFxuICAgICAgICBdO1xuICAgICAgICBjb25zdCBzb3VyY2UgPSAoMCwgdXRpbHNfMS5jbG9uZSkoaW1hZ2UpO1xuICAgICAgICAoMCwgdXRpbHNfMS5zY2FuKShzb3VyY2UsIHgsIHksIHcsIGgsICh4eCwgeXgsIGlkeCkgPT4ge1xuICAgICAgICAgICAgeHggPSBzaXplICogTWF0aC5mbG9vcih4eCAvIHNpemUpO1xuICAgICAgICAgICAgeXggPSBzaXplICogTWF0aC5mbG9vcih5eCAvIHNpemUpO1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBhcHBseUtlcm5lbChzb3VyY2UsIGtlcm5lbCwgeHgsIHl4KTtcbiAgICAgICAgICAgIGltYWdlLmJpdG1hcC5kYXRhW2lkeF0gPSB2YWx1ZVswXTtcbiAgICAgICAgICAgIGltYWdlLmJpdG1hcC5kYXRhW2lkeCArIDFdID0gdmFsdWVbMV07XG4gICAgICAgICAgICBpbWFnZS5iaXRtYXAuZGF0YVtpZHggKyAyXSA9IHZhbHVlWzJdO1xuICAgICAgICAgICAgaW1hZ2UuYml0bWFwLmRhdGFbaWR4ICsgM10gPSB2YWx1ZVszXTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBpbWFnZTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgYSBjb252b2x1dGlvbiBrZXJuZWwgdG8gdGhlIGltYWdlIG9yIGEgcmVnaW9uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIGltcG9ydCB7IEppbXAgfSBmcm9tIFwiamltcFwiO1xuICAgICAqXG4gICAgICogY29uc3QgaW1hZ2UgPSBhd2FpdCBKaW1wLnJlYWQoXCJ0ZXN0L2ltYWdlLnBuZ1wiKTtcbiAgICAgKlxuICAgICAqIC8vIGFwcGx5IGEgY29udm9sdXRpb24ga2VybmVsIHRvIHRoZSB3aG9sZSBpbWFnZVxuICAgICAqIGltYWdlLmNvbnZvbHV0aW9uKFtcbiAgICAgKiAgIFstMSwgLTEsIDBdLFxuICAgICAqICAgWy0xLCAxLCAxXSxcbiAgICAgKiAgIFswLCAxLCAxXSxcbiAgICAgKiBdKTtcbiAgICAgKlxuICAgICAqIC8vIGFwcGx5IGEgY29udm9sdXRpb24ga2VybmVsIHRvIGEgcmVnaW9uXG4gICAgICogaW1hZ2UuY29udm9sdXRpb24oW1xuICAgICAqICAgWy0xLCAtMSwgMF0sXG4gICAgICogICBbLTEsIDEsIDFdLFxuICAgICAqICAgWzAsIDEsIDFdLFxuICAgICAqIF0sIDEwLCAxMCwgMTAsIDIwKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBjb252b2x1dGUoaW1hZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkID0gQ29udm9sdXRlT3B0aW9uc1NjaGVtYS5wYXJzZShvcHRpb25zKTtcbiAgICAgICAgY29uc3QgeyBrZXJuZWwsIHggPSAwLCB5ID0gMCwgdyA9IGltYWdlLmJpdG1hcC53aWR0aCAtIHgsIGggPSBpbWFnZS5iaXRtYXAuaGVpZ2h0IC0geSwgfSA9IFwia2VybmVsXCIgaW4gcGFyc2VkXG4gICAgICAgICAgICA/IHBhcnNlZFxuICAgICAgICAgICAgOiB7IGtlcm5lbDogcGFyc2VkIH07XG4gICAgICAgIGNvbnN0IHNvdXJjZSA9ICgwLCB1dGlsc18xLmNsb25lKShpbWFnZSk7XG4gICAgICAgICgwLCB1dGlsc18xLnNjYW4pKHNvdXJjZSwgeCwgeSwgdywgaCwgKHh4LCB5eCwgaWR4KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGFwcGx5S2VybmVsKHNvdXJjZSwga2VybmVsLCB4eCwgeXgpO1xuICAgICAgICAgICAgaW1hZ2UuYml0bWFwLmRhdGFbaWR4XSA9ICgwLCB1dGlsc18xLmxpbWl0MjU1KSh2YWx1ZVswXSk7XG4gICAgICAgICAgICBpbWFnZS5iaXRtYXAuZGF0YVtpZHggKyAxXSA9ICgwLCB1dGlsc18xLmxpbWl0MjU1KSh2YWx1ZVsxXSk7XG4gICAgICAgICAgICBpbWFnZS5iaXRtYXAuZGF0YVtpZHggKyAyXSA9ICgwLCB1dGlsc18xLmxpbWl0MjU1KSh2YWx1ZVsyXSk7XG4gICAgICAgICAgICBpbWFnZS5iaXRtYXAuZGF0YVtpZHggKyAzXSA9ICgwLCB1dGlsc18xLmxpbWl0MjU1KSh2YWx1ZVszXSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gaW1hZ2U7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBBcHBseSBtdWx0aXBsZSBjb2xvciBtb2RpZmljYXRpb24gcnVsZXNcbiAgICAgKiBAcGFyYW0gIGFjdGlvbnMgbGlzdCBvZiBjb2xvciBtb2RpZmljYXRpb24gcnVsZXMsIGluIGZvbGxvd2luZyBmb3JtYXQ6IHsgYXBwbHk6ICc8cnVsZS1uYW1lPicsIHBhcmFtczogWyA8cnVsZS1wYXJhbWV0ZXJzPiBdICB9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIGltcG9ydCB7IEppbXAgfSBmcm9tIFwiamltcFwiO1xuICAgICAqXG4gICAgICogY29uc3QgaW1hZ2UgPSBhd2FpdCBKaW1wLnJlYWQoXCJ0ZXN0L2ltYWdlLnBuZ1wiKTtcbiAgICAgKlxuICAgICAqIGltYWdlLmNvbG9yKFtcbiAgICAgKiAgIHsgYXBwbHk6IFwiaHVlXCIsIHBhcmFtczogWy05MF0gfSxcbiAgICAgKiAgIHsgYXBwbHk6IFwibGlnaHRlblwiLCBwYXJhbXM6IFs1MF0gfSxcbiAgICAgKiAgIHsgYXBwbHk6IFwieG9yXCIsIHBhcmFtczogW1wiIzA2RFwiXSB9LFxuICAgICAqIF0pO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGNvbG9yKGltYWdlLCBhY3Rpb25zKSB7XG4gICAgICAgIGlmICghYWN0aW9ucyB8fCAhQXJyYXkuaXNBcnJheShhY3Rpb25zKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWN0aW9ucyBtdXN0IGJlIGFuIGFycmF5XCIpO1xuICAgICAgICB9XG4gICAgICAgIGFjdGlvbnMuZm9yRWFjaCgoYWN0aW9uKSA9PiBDb2xvckFjdGlvbk5hbWVTY2hlbWEucGFyc2UoYWN0aW9uKSk7XG4gICAgICAgIGFjdGlvbnMgPSBhY3Rpb25zLm1hcCgoYWN0aW9uKSA9PiB7XG4gICAgICAgICAgICBpZiAoYWN0aW9uLmFwcGx5ID09PSBcInhvclwiIHx8IGFjdGlvbi5hcHBseSA9PT0gXCJtaXhcIikge1xuICAgICAgICAgICAgICAgIGFjdGlvbi5wYXJhbXNbMF0gPSAoMCwgdGlueWNvbG9yMl8xLmRlZmF1bHQpKGFjdGlvbi5wYXJhbXNbMF0pLnRvUmdiKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYWN0aW9uO1xuICAgICAgICB9KTtcbiAgICAgICAgaW1hZ2Uuc2NhbigoXywgX18sIGlkeCkgPT4ge1xuICAgICAgICAgICAgbGV0IGNsciA9IHtcbiAgICAgICAgICAgICAgICByOiBpbWFnZS5iaXRtYXAuZGF0YVtpZHhdLFxuICAgICAgICAgICAgICAgIGc6IGltYWdlLmJpdG1hcC5kYXRhW2lkeCArIDFdLFxuICAgICAgICAgICAgICAgIGI6IGltYWdlLmJpdG1hcC5kYXRhW2lkeCArIDJdLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IGNvbG9yTW9kaWZpZXIgPSAoaSwgYW1vdW50KSA9PiAoMCwgdXRpbHNfMS5saW1pdDI1NSkoY2xyW2ldICsgYW1vdW50KTtcbiAgICAgICAgICAgIGFjdGlvbnMuZm9yRWFjaCgoYWN0aW9uKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGFjdGlvbi5hcHBseSA9PT0gXCJtaXhcIikge1xuICAgICAgICAgICAgICAgICAgICBjbHIgPSBtaXgoY2xyLCBhY3Rpb24ucGFyYW1zWzBdLCBhY3Rpb24ucGFyYW1zWzFdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYWN0aW9uLmFwcGx5ID09PSBcInRpbnRcIikge1xuICAgICAgICAgICAgICAgICAgICBjbHIgPSBtaXgoY2xyLCB7IHI6IDI1NSwgZzogMjU1LCBiOiAyNTUgfSwgYWN0aW9uLnBhcmFtcz8uWzBdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYWN0aW9uLmFwcGx5ID09PSBcInNoYWRlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xyID0gbWl4KGNsciwgeyByOiAwLCBnOiAwLCBiOiAwIH0sIGFjdGlvbi5wYXJhbXM/LlswXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGFjdGlvbi5hcHBseSA9PT0gXCJ4b3JcIikge1xuICAgICAgICAgICAgICAgICAgICBjbHIgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByOiBjbHIuciBeIGFjdGlvbi5wYXJhbXNbMF0ucixcbiAgICAgICAgICAgICAgICAgICAgICAgIGc6IGNsci5nIF4gYWN0aW9uLnBhcmFtc1swXS5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgYjogY2xyLmIgXiBhY3Rpb24ucGFyYW1zWzBdLmIsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGFjdGlvbi5hcHBseSA9PT0gXCJyZWRcIikge1xuICAgICAgICAgICAgICAgICAgICBjbHIuciA9IGNvbG9yTW9kaWZpZXIoXCJyXCIsIGFjdGlvbi5wYXJhbXNbMF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChhY3Rpb24uYXBwbHkgPT09IFwiZ3JlZW5cIikge1xuICAgICAgICAgICAgICAgICAgICBjbHIuZyA9IGNvbG9yTW9kaWZpZXIoXCJnXCIsIGFjdGlvbi5wYXJhbXNbMF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChhY3Rpb24uYXBwbHkgPT09IFwiYmx1ZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsci5iID0gY29sb3JNb2RpZmllcihcImJcIiwgYWN0aW9uLnBhcmFtc1swXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWN0aW9uLmFwcGx5ID09PSBcImh1ZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb24uYXBwbHkgPSBcInNwaW5cIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0bnlDbHIgPSAoMCwgdGlueWNvbG9yMl8xLmRlZmF1bHQpKGNscik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZuID0gdG55Q2xyW2FjdGlvbi5hcHBseV0uYmluZCh0bnlDbHIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWZuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhY3Rpb24gXCIgKyBhY3Rpb24uYXBwbHkgKyBcIiBub3Qgc3VwcG9ydGVkXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgICAgICAgIGNsciA9IGZuKC4uLihhY3Rpb24ucGFyYW1zIHx8IFtdKSkudG9SZ2IoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGltYWdlLmJpdG1hcC5kYXRhW2lkeF0gPSBjbHIucjtcbiAgICAgICAgICAgIGltYWdlLmJpdG1hcC5kYXRhW2lkeCArIDFdID0gY2xyLmc7XG4gICAgICAgICAgICBpbWFnZS5iaXRtYXAuZGF0YVtpZHggKyAyXSA9IGNsci5iO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGltYWdlO1xuICAgIH0sXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@jimp+plugin-color@1.6.0/node_modules/@jimp/plugin-color/dist/commonjs/index.js\n");

/***/ })

};
;