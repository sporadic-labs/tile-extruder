"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@jimp+utils@1.6.0";
exports.ids = ["vendor-chunks/@jimp+utils@1.6.0"];
exports.modules = {

/***/ "(ssr)/../../node_modules/.pnpm/@jimp+utils@1.6.0/node_modules/@jimp/utils/dist/commonjs/index.js":
/*!**************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@jimp+utils@1.6.0/node_modules/@jimp/utils/dist/commonjs/index.js ***!
  \**************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.clone = clone;\nexports.scan = scan;\nexports.scanIterator = scanIterator;\nexports.intToRGBA = intToRGBA;\nexports.rgbaToInt = rgbaToInt;\nexports.colorDiff = colorDiff;\nexports.limit255 = limit255;\nexports.cssColorToHex = cssColorToHex;\nconst tinycolor2_1 = __importDefault(__webpack_require__(/*! tinycolor2 */ \"(ssr)/../../node_modules/.pnpm/tinycolor2@1.6.0/node_modules/tinycolor2/cjs/tinycolor.js\"));\nfunction clone(image) {\n    const newBitmap = {\n        width: image.bitmap.width,\n        height: image.bitmap.height,\n        data: Buffer.from(image.bitmap.data),\n    };\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return new image.constructor(newBitmap);\n}\nfunction scan(image, \n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nxArg, yArg, wArg, hArg, \n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ncbArg) {\n    let x;\n    let y;\n    let w;\n    let h;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let cb;\n    if (typeof xArg === \"function\") {\n        cb = xArg;\n        x = 0;\n        y = 0;\n        w = image.bitmap.width;\n        h = image.bitmap.height;\n    }\n    else {\n        x = xArg;\n        if (typeof yArg !== \"number\")\n            throw new Error(\"y must be a number\");\n        y = yArg;\n        if (typeof wArg !== \"number\")\n            throw new Error(\"w must be a number\");\n        w = wArg;\n        if (typeof hArg !== \"number\")\n            throw new Error(\"h must be a number\");\n        h = hArg;\n        if (typeof cbArg !== \"function\")\n            throw new Error(\"cb must be a function\");\n        cb = cbArg;\n    }\n    // round input\n    x = Math.round(x);\n    y = Math.round(y);\n    w = Math.round(w);\n    h = Math.round(h);\n    const bound = cb.bind(image);\n    for (let _y = y; _y < y + h; _y++) {\n        for (let _x = x; _x < x + w; _x++) {\n            const idx = (image.bitmap.width * _y + _x) << 2;\n            // Bind the images so this.bitmap works\n            bound(_x, _y, idx);\n        }\n    }\n    return image;\n}\nfunction* scanIterator(image, x, y, w, h) {\n    // round input\n    x = Math.round(x);\n    y = Math.round(y);\n    w = Math.round(w);\n    h = Math.round(h);\n    for (let _y = y; _y < y + h; _y++) {\n        for (let _x = x; _x < x + w; _x++) {\n            const idx = (image.bitmap.width * _y + _x) << 2;\n            yield { x: _x, y: _y, idx, image };\n        }\n    }\n}\n/**\n * A helper method that converts RGBA values to a single integer value\n * @param i A single integer value representing an RGBA colour (e.g. 0xFF0000FF for red)\n * @returns An object with the properties r, g, b and a representing RGBA values\n * @example\n * ```ts\n * import { intToRGBA } from \"@jimp/utils\";\n *\n * intToRGBA(0xFF0000FF); // { r: 255, g: 0, b: 0, a:255 }\n * ```\n */\nfunction intToRGBA(i) {\n    if (typeof i !== \"number\") {\n        throw new Error(\"i must be a number\");\n    }\n    const rgba = {\n        r: 0,\n        g: 0,\n        b: 0,\n        a: 0,\n    };\n    rgba.r = Math.floor(i / Math.pow(256, 3));\n    rgba.g = Math.floor((i - rgba.r * Math.pow(256, 3)) / Math.pow(256, 2));\n    rgba.b = Math.floor((i - rgba.r * Math.pow(256, 3) - rgba.g * Math.pow(256, 2)) /\n        Math.pow(256, 1));\n    rgba.a = Math.floor((i -\n        rgba.r * Math.pow(256, 3) -\n        rgba.g * Math.pow(256, 2) -\n        rgba.b * Math.pow(256, 1)) /\n        Math.pow(256, 0));\n    return rgba;\n}\n/**\n * A static helper method that converts RGBA values to a single integer value\n * @param r the red value (0-255)\n * @param g the green value (0-255)\n * @param b the blue value (0-255)\n * @param a the alpha value (0-255)\n * @example\n * ```ts\n * import { rgbaToInt } from \"@jimp/utils\";\n *\n * rgbaToInt(255, 0, 0, 255); // 0xFF0000FF\n * ```\n */\nfunction rgbaToInt(r, g, b, a) {\n    if (typeof r !== \"number\" ||\n        typeof g !== \"number\" ||\n        typeof b !== \"number\" ||\n        typeof a !== \"number\") {\n        throw new Error(\"r, g, b and a must be numbers\");\n    }\n    if (r < 0 || r > 255) {\n        throw new Error(\"r must be between 0 and 255\");\n    }\n    if (g < 0 || g > 255) {\n        throw new Error(\"g must be between 0 and 255\");\n    }\n    if (b < 0 || b > 255) {\n        throw new Error(\"b must be between 0 and 255\");\n    }\n    if (a < 0 || a > 255) {\n        throw new Error(\"a must be between 0 and 255\");\n    }\n    let i = r & 0xff;\n    i <<= 8;\n    i |= g & 0xff;\n    i <<= 8;\n    i |= b & 0xff;\n    i <<= 8;\n    i |= a & 0xff;\n    // Ensure sign is correct\n    i >>>= 0;\n    return i;\n}\n/**\n * Compute color difference\n * 0 means no difference, 1 means maximum difference.\n * Both parameters must be an color object `{ r:val, g:val, b:val, a:val }`\n * Where `a` is optional and `val` is an integer between 0 and 255.\n * @param rgba1 first color to compare.\n * @param rgba2 second color to compare.\n * @returns float between 0 and 1.\n * @example\n * ```ts\n * import { colorDiff } from \"@jimp/utils\";\n *\n * colorDiff(\n *  { r: 255, g: 0, b: 0, a: 0 },\n *  { r: 0, g: 255, b: 0, a: 0 },\n * ); // 0.5\n *\n * colorDiff(\n *  { r: 0, g: 0, b: 0, },\n *  { r: 255, g: 255, b: 255, }\n * ); // 0.7\n * ```\n */\nfunction colorDiff(rgba1, rgba2) {\n    const sq = (n) => Math.pow(n, 2);\n    const { max } = Math;\n    const maxVal = 255 * 255 * 3;\n    const rgba1A = \"a\" in rgba1 ? rgba1.a : 255;\n    const rgba2A = \"a\" in rgba2 ? rgba2.a : 255;\n    return ((max(sq(rgba1.r - rgba2.r), sq(rgba1.r - rgba2.r - rgba1A + rgba2A)) +\n        max(sq(rgba1.g - rgba2.g), sq(rgba1.g - rgba2.g - rgba1A + rgba2A)) +\n        max(sq(rgba1.b - rgba2.b), sq(rgba1.b - rgba2.b - rgba1A + rgba2A))) /\n        maxVal);\n}\n/**\n * Limits a number to between 0 or 255\n * @example\n * ```ts\n * import { limit255 } from \"@jimp/utils\";\n *\n * limit255(256); // 255\n * limit255(-1); // 0\n * ```\n */\nfunction limit255(n) {\n    n = Math.max(n, 0);\n    n = Math.min(n, 255);\n    return n;\n}\n/**\n * Converts a css color (Hex, 8-digit (RGBA) Hex, RGB, RGBA, HSL, HSLA, HSV, HSVA, Named) to a hex number\n * @returns A hex number representing a color\n * @example\n * ```ts\n * import { cssColorToHex } from \"@jimp/utils\";\n *\n * cssColorToHex(\"rgba(255, 0, 0, 0.5)\"); // \"ff000080\"\n * ```\n */\nfunction cssColorToHex(cssColor) {\n    if (typeof cssColor === \"number\") {\n        return cssColor;\n    }\n    return parseInt((0, tinycolor2_1.default)(cssColor).toHex8(), 16);\n}\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BqaW1wK3V0aWxzQDEuNi4wL25vZGVfbW9kdWxlcy9AamltcC91dGlscy9kaXN0L2NvbW1vbmpzL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsYUFBYTtBQUNiLFlBQVk7QUFDWixvQkFBb0I7QUFDcEIsaUJBQWlCO0FBQ2pCLGlCQUFpQjtBQUNqQixpQkFBaUI7QUFDakIsZ0JBQWdCO0FBQ2hCLHFCQUFxQjtBQUNyQixxQ0FBcUMsbUJBQU8sQ0FBQyw0R0FBWTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsWUFBWTtBQUNqQyx5QkFBeUIsWUFBWTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixZQUFZO0FBQ2pDLHlCQUF5QixZQUFZO0FBQ3JDO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksWUFBWTtBQUN4QjtBQUNBLDBCQUEwQixLQUFLO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsNEJBQTRCO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksWUFBWTtBQUN4QjtBQUNBO0FBQ0EsTUFBTSwwQkFBMEI7QUFDaEMsTUFBTSwwQkFBMEI7QUFDaEMsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNLG1CQUFtQjtBQUN6QixNQUFNO0FBQ04sTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksV0FBVztBQUN2QjtBQUNBLGtCQUFrQjtBQUNsQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnQkFBZ0I7QUFDNUI7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvbWlrZXdlc3RoYWQvRGVza3RvcC9SZXBvcy9zcG9yYWRpYy1sYWJzLXRpbGUtZXh0cnVkZXIvbm9kZV9tb2R1bGVzLy5wbnBtL0BqaW1wK3V0aWxzQDEuNi4wL25vZGVfbW9kdWxlcy9AamltcC91dGlscy9kaXN0L2NvbW1vbmpzL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jbG9uZSA9IGNsb25lO1xuZXhwb3J0cy5zY2FuID0gc2NhbjtcbmV4cG9ydHMuc2Nhbkl0ZXJhdG9yID0gc2Nhbkl0ZXJhdG9yO1xuZXhwb3J0cy5pbnRUb1JHQkEgPSBpbnRUb1JHQkE7XG5leHBvcnRzLnJnYmFUb0ludCA9IHJnYmFUb0ludDtcbmV4cG9ydHMuY29sb3JEaWZmID0gY29sb3JEaWZmO1xuZXhwb3J0cy5saW1pdDI1NSA9IGxpbWl0MjU1O1xuZXhwb3J0cy5jc3NDb2xvclRvSGV4ID0gY3NzQ29sb3JUb0hleDtcbmNvbnN0IHRpbnljb2xvcjJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwidGlueWNvbG9yMlwiKSk7XG5mdW5jdGlvbiBjbG9uZShpbWFnZSkge1xuICAgIGNvbnN0IG5ld0JpdG1hcCA9IHtcbiAgICAgICAgd2lkdGg6IGltYWdlLmJpdG1hcC53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBpbWFnZS5iaXRtYXAuaGVpZ2h0LFxuICAgICAgICBkYXRhOiBCdWZmZXIuZnJvbShpbWFnZS5iaXRtYXAuZGF0YSksXG4gICAgfTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIHJldHVybiBuZXcgaW1hZ2UuY29uc3RydWN0b3IobmV3Qml0bWFwKTtcbn1cbmZ1bmN0aW9uIHNjYW4oaW1hZ2UsIFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbnhBcmcsIHlBcmcsIHdBcmcsIGhBcmcsIFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmNiQXJnKSB7XG4gICAgbGV0IHg7XG4gICAgbGV0IHk7XG4gICAgbGV0IHc7XG4gICAgbGV0IGg7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBsZXQgY2I7XG4gICAgaWYgKHR5cGVvZiB4QXJnID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgY2IgPSB4QXJnO1xuICAgICAgICB4ID0gMDtcbiAgICAgICAgeSA9IDA7XG4gICAgICAgIHcgPSBpbWFnZS5iaXRtYXAud2lkdGg7XG4gICAgICAgIGggPSBpbWFnZS5iaXRtYXAuaGVpZ2h0O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgeCA9IHhBcmc7XG4gICAgICAgIGlmICh0eXBlb2YgeUFyZyAhPT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInkgbXVzdCBiZSBhIG51bWJlclwiKTtcbiAgICAgICAgeSA9IHlBcmc7XG4gICAgICAgIGlmICh0eXBlb2Ygd0FyZyAhPT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIncgbXVzdCBiZSBhIG51bWJlclwiKTtcbiAgICAgICAgdyA9IHdBcmc7XG4gICAgICAgIGlmICh0eXBlb2YgaEFyZyAhPT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImggbXVzdCBiZSBhIG51bWJlclwiKTtcbiAgICAgICAgaCA9IGhBcmc7XG4gICAgICAgIGlmICh0eXBlb2YgY2JBcmcgIT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImNiIG11c3QgYmUgYSBmdW5jdGlvblwiKTtcbiAgICAgICAgY2IgPSBjYkFyZztcbiAgICB9XG4gICAgLy8gcm91bmQgaW5wdXRcbiAgICB4ID0gTWF0aC5yb3VuZCh4KTtcbiAgICB5ID0gTWF0aC5yb3VuZCh5KTtcbiAgICB3ID0gTWF0aC5yb3VuZCh3KTtcbiAgICBoID0gTWF0aC5yb3VuZChoKTtcbiAgICBjb25zdCBib3VuZCA9IGNiLmJpbmQoaW1hZ2UpO1xuICAgIGZvciAobGV0IF95ID0geTsgX3kgPCB5ICsgaDsgX3krKykge1xuICAgICAgICBmb3IgKGxldCBfeCA9IHg7IF94IDwgeCArIHc7IF94KyspIHtcbiAgICAgICAgICAgIGNvbnN0IGlkeCA9IChpbWFnZS5iaXRtYXAud2lkdGggKiBfeSArIF94KSA8PCAyO1xuICAgICAgICAgICAgLy8gQmluZCB0aGUgaW1hZ2VzIHNvIHRoaXMuYml0bWFwIHdvcmtzXG4gICAgICAgICAgICBib3VuZChfeCwgX3ksIGlkeCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGltYWdlO1xufVxuZnVuY3Rpb24qIHNjYW5JdGVyYXRvcihpbWFnZSwgeCwgeSwgdywgaCkge1xuICAgIC8vIHJvdW5kIGlucHV0XG4gICAgeCA9IE1hdGgucm91bmQoeCk7XG4gICAgeSA9IE1hdGgucm91bmQoeSk7XG4gICAgdyA9IE1hdGgucm91bmQodyk7XG4gICAgaCA9IE1hdGgucm91bmQoaCk7XG4gICAgZm9yIChsZXQgX3kgPSB5OyBfeSA8IHkgKyBoOyBfeSsrKSB7XG4gICAgICAgIGZvciAobGV0IF94ID0geDsgX3ggPCB4ICsgdzsgX3grKykge1xuICAgICAgICAgICAgY29uc3QgaWR4ID0gKGltYWdlLmJpdG1hcC53aWR0aCAqIF95ICsgX3gpIDw8IDI7XG4gICAgICAgICAgICB5aWVsZCB7IHg6IF94LCB5OiBfeSwgaWR4LCBpbWFnZSB9O1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBBIGhlbHBlciBtZXRob2QgdGhhdCBjb252ZXJ0cyBSR0JBIHZhbHVlcyB0byBhIHNpbmdsZSBpbnRlZ2VyIHZhbHVlXG4gKiBAcGFyYW0gaSBBIHNpbmdsZSBpbnRlZ2VyIHZhbHVlIHJlcHJlc2VudGluZyBhbiBSR0JBIGNvbG91ciAoZS5nLiAweEZGMDAwMEZGIGZvciByZWQpXG4gKiBAcmV0dXJucyBBbiBvYmplY3Qgd2l0aCB0aGUgcHJvcGVydGllcyByLCBnLCBiIGFuZCBhIHJlcHJlc2VudGluZyBSR0JBIHZhbHVlc1xuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBpbnRUb1JHQkEgfSBmcm9tIFwiQGppbXAvdXRpbHNcIjtcbiAqXG4gKiBpbnRUb1JHQkEoMHhGRjAwMDBGRik7IC8vIHsgcjogMjU1LCBnOiAwLCBiOiAwLCBhOjI1NSB9XG4gKiBgYGBcbiAqL1xuZnVuY3Rpb24gaW50VG9SR0JBKGkpIHtcbiAgICBpZiAodHlwZW9mIGkgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaSBtdXN0IGJlIGEgbnVtYmVyXCIpO1xuICAgIH1cbiAgICBjb25zdCByZ2JhID0ge1xuICAgICAgICByOiAwLFxuICAgICAgICBnOiAwLFxuICAgICAgICBiOiAwLFxuICAgICAgICBhOiAwLFxuICAgIH07XG4gICAgcmdiYS5yID0gTWF0aC5mbG9vcihpIC8gTWF0aC5wb3coMjU2LCAzKSk7XG4gICAgcmdiYS5nID0gTWF0aC5mbG9vcigoaSAtIHJnYmEuciAqIE1hdGgucG93KDI1NiwgMykpIC8gTWF0aC5wb3coMjU2LCAyKSk7XG4gICAgcmdiYS5iID0gTWF0aC5mbG9vcigoaSAtIHJnYmEuciAqIE1hdGgucG93KDI1NiwgMykgLSByZ2JhLmcgKiBNYXRoLnBvdygyNTYsIDIpKSAvXG4gICAgICAgIE1hdGgucG93KDI1NiwgMSkpO1xuICAgIHJnYmEuYSA9IE1hdGguZmxvb3IoKGkgLVxuICAgICAgICByZ2JhLnIgKiBNYXRoLnBvdygyNTYsIDMpIC1cbiAgICAgICAgcmdiYS5nICogTWF0aC5wb3coMjU2LCAyKSAtXG4gICAgICAgIHJnYmEuYiAqIE1hdGgucG93KDI1NiwgMSkpIC9cbiAgICAgICAgTWF0aC5wb3coMjU2LCAwKSk7XG4gICAgcmV0dXJuIHJnYmE7XG59XG4vKipcbiAqIEEgc3RhdGljIGhlbHBlciBtZXRob2QgdGhhdCBjb252ZXJ0cyBSR0JBIHZhbHVlcyB0byBhIHNpbmdsZSBpbnRlZ2VyIHZhbHVlXG4gKiBAcGFyYW0gciB0aGUgcmVkIHZhbHVlICgwLTI1NSlcbiAqIEBwYXJhbSBnIHRoZSBncmVlbiB2YWx1ZSAoMC0yNTUpXG4gKiBAcGFyYW0gYiB0aGUgYmx1ZSB2YWx1ZSAoMC0yNTUpXG4gKiBAcGFyYW0gYSB0aGUgYWxwaGEgdmFsdWUgKDAtMjU1KVxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyByZ2JhVG9JbnQgfSBmcm9tIFwiQGppbXAvdXRpbHNcIjtcbiAqXG4gKiByZ2JhVG9JbnQoMjU1LCAwLCAwLCAyNTUpOyAvLyAweEZGMDAwMEZGXG4gKiBgYGBcbiAqL1xuZnVuY3Rpb24gcmdiYVRvSW50KHIsIGcsIGIsIGEpIHtcbiAgICBpZiAodHlwZW9mIHIgIT09IFwibnVtYmVyXCIgfHxcbiAgICAgICAgdHlwZW9mIGcgIT09IFwibnVtYmVyXCIgfHxcbiAgICAgICAgdHlwZW9mIGIgIT09IFwibnVtYmVyXCIgfHxcbiAgICAgICAgdHlwZW9mIGEgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiciwgZywgYiBhbmQgYSBtdXN0IGJlIG51bWJlcnNcIik7XG4gICAgfVxuICAgIGlmIChyIDwgMCB8fCByID4gMjU1KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInIgbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDI1NVwiKTtcbiAgICB9XG4gICAgaWYgKGcgPCAwIHx8IGcgPiAyNTUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZyBtdXN0IGJlIGJldHdlZW4gMCBhbmQgMjU1XCIpO1xuICAgIH1cbiAgICBpZiAoYiA8IDAgfHwgYiA+IDI1NSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJiIG11c3QgYmUgYmV0d2VlbiAwIGFuZCAyNTVcIik7XG4gICAgfVxuICAgIGlmIChhIDwgMCB8fCBhID4gMjU1KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImEgbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDI1NVwiKTtcbiAgICB9XG4gICAgbGV0IGkgPSByICYgMHhmZjtcbiAgICBpIDw8PSA4O1xuICAgIGkgfD0gZyAmIDB4ZmY7XG4gICAgaSA8PD0gODtcbiAgICBpIHw9IGIgJiAweGZmO1xuICAgIGkgPDw9IDg7XG4gICAgaSB8PSBhICYgMHhmZjtcbiAgICAvLyBFbnN1cmUgc2lnbiBpcyBjb3JyZWN0XG4gICAgaSA+Pj49IDA7XG4gICAgcmV0dXJuIGk7XG59XG4vKipcbiAqIENvbXB1dGUgY29sb3IgZGlmZmVyZW5jZVxuICogMCBtZWFucyBubyBkaWZmZXJlbmNlLCAxIG1lYW5zIG1heGltdW0gZGlmZmVyZW5jZS5cbiAqIEJvdGggcGFyYW1ldGVycyBtdXN0IGJlIGFuIGNvbG9yIG9iamVjdCBgeyByOnZhbCwgZzp2YWwsIGI6dmFsLCBhOnZhbCB9YFxuICogV2hlcmUgYGFgIGlzIG9wdGlvbmFsIGFuZCBgdmFsYCBpcyBhbiBpbnRlZ2VyIGJldHdlZW4gMCBhbmQgMjU1LlxuICogQHBhcmFtIHJnYmExIGZpcnN0IGNvbG9yIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0gcmdiYTIgc2Vjb25kIGNvbG9yIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyBmbG9hdCBiZXR3ZWVuIDAgYW5kIDEuXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IGNvbG9yRGlmZiB9IGZyb20gXCJAamltcC91dGlsc1wiO1xuICpcbiAqIGNvbG9yRGlmZihcbiAqICB7IHI6IDI1NSwgZzogMCwgYjogMCwgYTogMCB9LFxuICogIHsgcjogMCwgZzogMjU1LCBiOiAwLCBhOiAwIH0sXG4gKiApOyAvLyAwLjVcbiAqXG4gKiBjb2xvckRpZmYoXG4gKiAgeyByOiAwLCBnOiAwLCBiOiAwLCB9LFxuICogIHsgcjogMjU1LCBnOiAyNTUsIGI6IDI1NSwgfVxuICogKTsgLy8gMC43XG4gKiBgYGBcbiAqL1xuZnVuY3Rpb24gY29sb3JEaWZmKHJnYmExLCByZ2JhMikge1xuICAgIGNvbnN0IHNxID0gKG4pID0+IE1hdGgucG93KG4sIDIpO1xuICAgIGNvbnN0IHsgbWF4IH0gPSBNYXRoO1xuICAgIGNvbnN0IG1heFZhbCA9IDI1NSAqIDI1NSAqIDM7XG4gICAgY29uc3QgcmdiYTFBID0gXCJhXCIgaW4gcmdiYTEgPyByZ2JhMS5hIDogMjU1O1xuICAgIGNvbnN0IHJnYmEyQSA9IFwiYVwiIGluIHJnYmEyID8gcmdiYTIuYSA6IDI1NTtcbiAgICByZXR1cm4gKChtYXgoc3EocmdiYTEuciAtIHJnYmEyLnIpLCBzcShyZ2JhMS5yIC0gcmdiYTIuciAtIHJnYmExQSArIHJnYmEyQSkpICtcbiAgICAgICAgbWF4KHNxKHJnYmExLmcgLSByZ2JhMi5nKSwgc3EocmdiYTEuZyAtIHJnYmEyLmcgLSByZ2JhMUEgKyByZ2JhMkEpKSArXG4gICAgICAgIG1heChzcShyZ2JhMS5iIC0gcmdiYTIuYiksIHNxKHJnYmExLmIgLSByZ2JhMi5iIC0gcmdiYTFBICsgcmdiYTJBKSkpIC9cbiAgICAgICAgbWF4VmFsKTtcbn1cbi8qKlxuICogTGltaXRzIGEgbnVtYmVyIHRvIGJldHdlZW4gMCBvciAyNTVcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgbGltaXQyNTUgfSBmcm9tIFwiQGppbXAvdXRpbHNcIjtcbiAqXG4gKiBsaW1pdDI1NSgyNTYpOyAvLyAyNTVcbiAqIGxpbWl0MjU1KC0xKTsgLy8gMFxuICogYGBgXG4gKi9cbmZ1bmN0aW9uIGxpbWl0MjU1KG4pIHtcbiAgICBuID0gTWF0aC5tYXgobiwgMCk7XG4gICAgbiA9IE1hdGgubWluKG4sIDI1NSk7XG4gICAgcmV0dXJuIG47XG59XG4vKipcbiAqIENvbnZlcnRzIGEgY3NzIGNvbG9yIChIZXgsIDgtZGlnaXQgKFJHQkEpIEhleCwgUkdCLCBSR0JBLCBIU0wsIEhTTEEsIEhTViwgSFNWQSwgTmFtZWQpIHRvIGEgaGV4IG51bWJlclxuICogQHJldHVybnMgQSBoZXggbnVtYmVyIHJlcHJlc2VudGluZyBhIGNvbG9yXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IGNzc0NvbG9yVG9IZXggfSBmcm9tIFwiQGppbXAvdXRpbHNcIjtcbiAqXG4gKiBjc3NDb2xvclRvSGV4KFwicmdiYSgyNTUsIDAsIDAsIDAuNSlcIik7IC8vIFwiZmYwMDAwODBcIlxuICogYGBgXG4gKi9cbmZ1bmN0aW9uIGNzc0NvbG9yVG9IZXgoY3NzQ29sb3IpIHtcbiAgICBpZiAodHlwZW9mIGNzc0NvbG9yID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHJldHVybiBjc3NDb2xvcjtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlSW50KCgwLCB0aW55Y29sb3IyXzEuZGVmYXVsdCkoY3NzQ29sb3IpLnRvSGV4OCgpLCAxNik7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@jimp+utils@1.6.0/node_modules/@jimp/utils/dist/commonjs/index.js\n");

/***/ })

};
;