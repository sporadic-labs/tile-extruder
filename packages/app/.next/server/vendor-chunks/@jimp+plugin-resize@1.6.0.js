"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@jimp+plugin-resize@1.6.0";
exports.ids = ["vendor-chunks/@jimp+plugin-resize@1.6.0"];
exports.modules = {

/***/ "(ssr)/../../node_modules/.pnpm/@jimp+plugin-resize@1.6.0/node_modules/@jimp/plugin-resize/dist/commonjs/constants.js":
/*!**********************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@jimp+plugin-resize@1.6.0/node_modules/@jimp/plugin-resize/dist/commonjs/constants.js ***!
  \**********************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ResizeStrategy = void 0;\n/**\n * What resizing algorithm to use.\n */\nvar ResizeStrategy;\n(function (ResizeStrategy) {\n    /**\n     * Nearest Neighbor resizing is a method used in image processing that assigns the value of the nearest pixel to the output pixel when resizing an image.\n     * While fast, it can lead to lower quality outputs with noticeable pixelation, especially at larger scaling factors.\n     */\n    ResizeStrategy[\"NEAREST_NEIGHBOR\"] = \"nearestNeighbor\";\n    /**\n     * Bilinear resizing is an image scaling method that uses the weighted average of the four nearest pixel values, providing smoother gradients than nearest neighbor resizing.\n     * It's computationally more intense than nearest neighbor but results in images of higher quality and fewer artifacts.\n     */\n    ResizeStrategy[\"BILINEAR\"] = \"bilinearInterpolation\";\n    /**\n     * Bicubic resizing is an image interpolation method that uses the values of the nearest 16 pixels in the input image to calculate the output pixel value, providing even more smoothness and sharpness than bilinear resizing.\n     * Although it's computationally more expensive than bilinear and nearest neighbor, it produces higher quality images, making it ideal for photographic image scaling.\n     */\n    ResizeStrategy[\"BICUBIC\"] = \"bicubicInterpolation\";\n    /**\n     * Hermite resizing is an image resizing method that uses Hermite interpolation, a mathematical formula, to determine the values of output pixels based on a weighted average of the surrounding pixels.\n     * Although slower than some simpler techniques like bilinear or nearest neighbor, Hermite resizing can produce higher quality visuals and detailed renderings with less blurring.\n     */\n    ResizeStrategy[\"HERMITE\"] = \"hermiteInterpolation\";\n    ResizeStrategy[\"BEZIER\"] = \"bezierInterpolation\";\n})(ResizeStrategy || (exports.ResizeStrategy = ResizeStrategy = {}));\n//# sourceMappingURL=constants.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BqaW1wK3BsdWdpbi1yZXNpemVAMS42LjAvbm9kZV9tb2R1bGVzL0BqaW1wL3BsdWdpbi1yZXNpemUvZGlzdC9jb21tb25qcy9jb25zdGFudHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHFCQUFxQixzQkFBc0Isc0JBQXNCO0FBQ2xFIiwic291cmNlcyI6WyIvVXNlcnMvbWlrZXdlc3RoYWQvRGVza3RvcC9SZXBvcy9zcG9yYWRpYy1sYWJzLXRpbGUtZXh0cnVkZXIvbm9kZV9tb2R1bGVzLy5wbnBtL0BqaW1wK3BsdWdpbi1yZXNpemVAMS42LjAvbm9kZV9tb2R1bGVzL0BqaW1wL3BsdWdpbi1yZXNpemUvZGlzdC9jb21tb25qcy9jb25zdGFudHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlJlc2l6ZVN0cmF0ZWd5ID0gdm9pZCAwO1xuLyoqXG4gKiBXaGF0IHJlc2l6aW5nIGFsZ29yaXRobSB0byB1c2UuXG4gKi9cbnZhciBSZXNpemVTdHJhdGVneTtcbihmdW5jdGlvbiAoUmVzaXplU3RyYXRlZ3kpIHtcbiAgICAvKipcbiAgICAgKiBOZWFyZXN0IE5laWdoYm9yIHJlc2l6aW5nIGlzIGEgbWV0aG9kIHVzZWQgaW4gaW1hZ2UgcHJvY2Vzc2luZyB0aGF0IGFzc2lnbnMgdGhlIHZhbHVlIG9mIHRoZSBuZWFyZXN0IHBpeGVsIHRvIHRoZSBvdXRwdXQgcGl4ZWwgd2hlbiByZXNpemluZyBhbiBpbWFnZS5cbiAgICAgKiBXaGlsZSBmYXN0LCBpdCBjYW4gbGVhZCB0byBsb3dlciBxdWFsaXR5IG91dHB1dHMgd2l0aCBub3RpY2VhYmxlIHBpeGVsYXRpb24sIGVzcGVjaWFsbHkgYXQgbGFyZ2VyIHNjYWxpbmcgZmFjdG9ycy5cbiAgICAgKi9cbiAgICBSZXNpemVTdHJhdGVneVtcIk5FQVJFU1RfTkVJR0hCT1JcIl0gPSBcIm5lYXJlc3ROZWlnaGJvclwiO1xuICAgIC8qKlxuICAgICAqIEJpbGluZWFyIHJlc2l6aW5nIGlzIGFuIGltYWdlIHNjYWxpbmcgbWV0aG9kIHRoYXQgdXNlcyB0aGUgd2VpZ2h0ZWQgYXZlcmFnZSBvZiB0aGUgZm91ciBuZWFyZXN0IHBpeGVsIHZhbHVlcywgcHJvdmlkaW5nIHNtb290aGVyIGdyYWRpZW50cyB0aGFuIG5lYXJlc3QgbmVpZ2hib3IgcmVzaXppbmcuXG4gICAgICogSXQncyBjb21wdXRhdGlvbmFsbHkgbW9yZSBpbnRlbnNlIHRoYW4gbmVhcmVzdCBuZWlnaGJvciBidXQgcmVzdWx0cyBpbiBpbWFnZXMgb2YgaGlnaGVyIHF1YWxpdHkgYW5kIGZld2VyIGFydGlmYWN0cy5cbiAgICAgKi9cbiAgICBSZXNpemVTdHJhdGVneVtcIkJJTElORUFSXCJdID0gXCJiaWxpbmVhckludGVycG9sYXRpb25cIjtcbiAgICAvKipcbiAgICAgKiBCaWN1YmljIHJlc2l6aW5nIGlzIGFuIGltYWdlIGludGVycG9sYXRpb24gbWV0aG9kIHRoYXQgdXNlcyB0aGUgdmFsdWVzIG9mIHRoZSBuZWFyZXN0IDE2IHBpeGVscyBpbiB0aGUgaW5wdXQgaW1hZ2UgdG8gY2FsY3VsYXRlIHRoZSBvdXRwdXQgcGl4ZWwgdmFsdWUsIHByb3ZpZGluZyBldmVuIG1vcmUgc21vb3RobmVzcyBhbmQgc2hhcnBuZXNzIHRoYW4gYmlsaW5lYXIgcmVzaXppbmcuXG4gICAgICogQWx0aG91Z2ggaXQncyBjb21wdXRhdGlvbmFsbHkgbW9yZSBleHBlbnNpdmUgdGhhbiBiaWxpbmVhciBhbmQgbmVhcmVzdCBuZWlnaGJvciwgaXQgcHJvZHVjZXMgaGlnaGVyIHF1YWxpdHkgaW1hZ2VzLCBtYWtpbmcgaXQgaWRlYWwgZm9yIHBob3RvZ3JhcGhpYyBpbWFnZSBzY2FsaW5nLlxuICAgICAqL1xuICAgIFJlc2l6ZVN0cmF0ZWd5W1wiQklDVUJJQ1wiXSA9IFwiYmljdWJpY0ludGVycG9sYXRpb25cIjtcbiAgICAvKipcbiAgICAgKiBIZXJtaXRlIHJlc2l6aW5nIGlzIGFuIGltYWdlIHJlc2l6aW5nIG1ldGhvZCB0aGF0IHVzZXMgSGVybWl0ZSBpbnRlcnBvbGF0aW9uLCBhIG1hdGhlbWF0aWNhbCBmb3JtdWxhLCB0byBkZXRlcm1pbmUgdGhlIHZhbHVlcyBvZiBvdXRwdXQgcGl4ZWxzIGJhc2VkIG9uIGEgd2VpZ2h0ZWQgYXZlcmFnZSBvZiB0aGUgc3Vycm91bmRpbmcgcGl4ZWxzLlxuICAgICAqIEFsdGhvdWdoIHNsb3dlciB0aGFuIHNvbWUgc2ltcGxlciB0ZWNobmlxdWVzIGxpa2UgYmlsaW5lYXIgb3IgbmVhcmVzdCBuZWlnaGJvciwgSGVybWl0ZSByZXNpemluZyBjYW4gcHJvZHVjZSBoaWdoZXIgcXVhbGl0eSB2aXN1YWxzIGFuZCBkZXRhaWxlZCByZW5kZXJpbmdzIHdpdGggbGVzcyBibHVycmluZy5cbiAgICAgKi9cbiAgICBSZXNpemVTdHJhdGVneVtcIkhFUk1JVEVcIl0gPSBcImhlcm1pdGVJbnRlcnBvbGF0aW9uXCI7XG4gICAgUmVzaXplU3RyYXRlZ3lbXCJCRVpJRVJcIl0gPSBcImJlemllckludGVycG9sYXRpb25cIjtcbn0pKFJlc2l6ZVN0cmF0ZWd5IHx8IChleHBvcnRzLlJlc2l6ZVN0cmF0ZWd5ID0gUmVzaXplU3RyYXRlZ3kgPSB7fSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uc3RhbnRzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@jimp+plugin-resize@1.6.0/node_modules/@jimp/plugin-resize/dist/commonjs/constants.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/@jimp+plugin-resize@1.6.0/node_modules/@jimp/plugin-resize/dist/commonjs/index.js":
/*!******************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@jimp+plugin-resize@1.6.0/node_modules/@jimp/plugin-resize/dist/commonjs/index.js ***!
  \******************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.methods = void 0;\nconst constants_js_1 = __webpack_require__(/*! ./constants.js */ \"(ssr)/../../node_modules/.pnpm/@jimp+plugin-resize@1.6.0/node_modules/@jimp/plugin-resize/dist/commonjs/constants.js\");\nconst zod_1 = __webpack_require__(/*! zod */ \"(ssr)/../../node_modules/.pnpm/zod@3.24.1/node_modules/zod/lib/index.js\");\nconst resize_js_1 = __importDefault(__webpack_require__(/*! ./modules/resize.js */ \"(ssr)/../../node_modules/.pnpm/@jimp+plugin-resize@1.6.0/node_modules/@jimp/plugin-resize/dist/commonjs/modules/resize.js\"));\nconst resize2_js_1 = __webpack_require__(/*! ./modules/resize2.js */ \"(ssr)/../../node_modules/.pnpm/@jimp+plugin-resize@1.6.0/node_modules/@jimp/plugin-resize/dist/commonjs/modules/resize2.js\");\n__exportStar(__webpack_require__(/*! ./constants.js */ \"(ssr)/../../node_modules/.pnpm/@jimp+plugin-resize@1.6.0/node_modules/@jimp/plugin-resize/dist/commonjs/constants.js\"), exports);\nconst ResizeOptionsSchema = zod_1.z.union([\n    zod_1.z.object({\n        /** the width to resize the image to */\n        w: zod_1.z.number().min(0),\n        /** the height to resize the image to */\n        h: zod_1.z.number().min(0).optional(),\n        /** a scaling method (e.g. ResizeStrategy.BEZIER) */\n        mode: zod_1.z.nativeEnum(constants_js_1.ResizeStrategy).optional(),\n    }),\n    zod_1.z.object({\n        /** the width to resize the image to */\n        w: zod_1.z.number().min(0).optional(),\n        /** the height to resize the image to */\n        h: zod_1.z.number().min(0),\n        /** a scaling method (e.g. ResizeStrategy.BEZIER) */\n        mode: zod_1.z.nativeEnum(constants_js_1.ResizeStrategy).optional(),\n    }),\n]);\nconst ScaleToFitOptionsSchema = zod_1.z.object({\n    /** the width to resize the image to */\n    w: zod_1.z.number().min(0),\n    /** the height to resize the image to */\n    h: zod_1.z.number().min(0),\n    /** a scaling method (e.g. Jimp.RESIZE_BEZIER) */\n    mode: zod_1.z.nativeEnum(constants_js_1.ResizeStrategy).optional(),\n});\nconst ScaleComplexOptionsSchema = zod_1.z.object({\n    /** the width to resize the image to */\n    f: zod_1.z.number().min(0),\n    /** a scaling method (e.g. Jimp.RESIZE_BEZIER) */\n    mode: zod_1.z.nativeEnum(constants_js_1.ResizeStrategy).optional(),\n});\nexports.methods = {\n    /**\n     * Resizes the image to a set width and height using a 2-pass bilinear algorithm\n     * @example\n     * ```ts\n     * import { Jimp } from \"jimp\";\n     *\n     * const image = await Jimp.read(\"test/image.png\");\n     *\n     * image.resize({ w: 150 });\n     * ```\n     */\n    resize(image, options) {\n        const { mode } = ResizeOptionsSchema.parse(options);\n        let w;\n        let h;\n        if (typeof options.w === \"number\") {\n            w = options.w;\n            h = options.h ?? image.bitmap.height * (w / image.bitmap.width);\n        }\n        else if (typeof options.h === \"number\") {\n            h = options.h;\n            w = options.w ?? image.bitmap.width * (h / image.bitmap.height);\n        }\n        else {\n            throw new Error(\"w must be a number\");\n        }\n        // round inputs\n        w = Math.round(w) || 1;\n        h = Math.round(h) || 1;\n        if (mode && typeof resize2_js_1.operations[mode] === \"function\") {\n            const dst = {\n                data: Buffer.alloc(w * h * 4),\n                width: w,\n                height: h,\n            };\n            resize2_js_1.operations[mode](image.bitmap, dst);\n            image.bitmap = dst;\n        }\n        else {\n            const resize = new resize_js_1.default(image.bitmap.width, image.bitmap.height, w, h, true, true, (buffer) => {\n                image.bitmap.data = Buffer.from(buffer);\n                image.bitmap.width = w;\n                image.bitmap.height = h;\n            });\n            resize.resize(image.bitmap.data);\n        }\n        return image;\n    },\n    /**\n     * Uniformly scales the image by a factor.\n     * @param f the factor to scale the image by\n     * @param mode (optional) a scaling method (e.g. Jimp.RESIZE_BEZIER)\n     * @example\n     * ```ts\n     * import { Jimp } from \"jimp\";\n     *\n     * const image = await Jimp.read(\"test/image.png\");\n     *\n     * image.scale(0.5);\n     * ```\n     */\n    scale(image, options) {\n        const { f, mode } = typeof options === \"number\"\n            ? { f: options }\n            : ScaleComplexOptionsSchema.parse(options);\n        const w = image.bitmap.width * f;\n        const h = image.bitmap.height * f;\n        return this.resize(image, { w, h, mode: mode });\n    },\n    /**\n     * Scale the image to the largest size that fits inside the rectangle that has the given width and height.\n     * @param w the width to resize the image to\n     * @param h the height to resize the image to\n     * @param mode a scaling method (e.g. ResizeStrategy.BEZIER)\n     * @example\n     * ```ts\n     * import { Jimp } from \"jimp\";\n     *\n     * const image = await Jimp.read(\"test/image.png\");\n     *\n     * image.scaleToFit(100, 100);\n     * ```\n     */\n    scaleToFit(image, options) {\n        const { h, w, mode } = ScaleToFitOptionsSchema.parse(options);\n        const f = w / h > image.bitmap.width / image.bitmap.height\n            ? h / image.bitmap.height\n            : w / image.bitmap.width;\n        return this.scale(image, { f, mode: mode });\n    },\n};\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BqaW1wK3BsdWdpbi1yZXNpemVAMS42LjAvbm9kZV9tb2R1bGVzL0BqaW1wL3BsdWdpbi1yZXNpemUvZGlzdC9jb21tb25qcy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGVBQWU7QUFDZix1QkFBdUIsbUJBQU8sQ0FBQyw0SUFBZ0I7QUFDL0MsY0FBYyxtQkFBTyxDQUFDLG9GQUFLO0FBQzNCLG9DQUFvQyxtQkFBTyxDQUFDLHNKQUFxQjtBQUNqRSxxQkFBcUIsbUJBQU8sQ0FBQyx3SkFBc0I7QUFDbkQsYUFBYSxtQkFBTyxDQUFDLDRJQUFnQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsUUFBUTtBQUM5QjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxrQkFBa0I7QUFDdEQsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsYUFBYTtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsZUFBZTtBQUNsRCxLQUFLO0FBQ0w7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL21pa2V3ZXN0aGFkL0Rlc2t0b3AvUmVwb3Mvc3BvcmFkaWMtbGFicy10aWxlLWV4dHJ1ZGVyL25vZGVfbW9kdWxlcy8ucG5wbS9AamltcCtwbHVnaW4tcmVzaXplQDEuNi4wL25vZGVfbW9kdWxlcy9AamltcC9wbHVnaW4tcmVzaXplL2Rpc3QvY29tbW9uanMvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMubWV0aG9kcyA9IHZvaWQgMDtcbmNvbnN0IGNvbnN0YW50c19qc18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzLmpzXCIpO1xuY29uc3Qgem9kXzEgPSByZXF1aXJlKFwiem9kXCIpO1xuY29uc3QgcmVzaXplX2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vbW9kdWxlcy9yZXNpemUuanNcIikpO1xuY29uc3QgcmVzaXplMl9qc18xID0gcmVxdWlyZShcIi4vbW9kdWxlcy9yZXNpemUyLmpzXCIpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2NvbnN0YW50cy5qc1wiKSwgZXhwb3J0cyk7XG5jb25zdCBSZXNpemVPcHRpb25zU2NoZW1hID0gem9kXzEuei51bmlvbihbXG4gICAgem9kXzEuei5vYmplY3Qoe1xuICAgICAgICAvKiogdGhlIHdpZHRoIHRvIHJlc2l6ZSB0aGUgaW1hZ2UgdG8gKi9cbiAgICAgICAgdzogem9kXzEuei5udW1iZXIoKS5taW4oMCksXG4gICAgICAgIC8qKiB0aGUgaGVpZ2h0IHRvIHJlc2l6ZSB0aGUgaW1hZ2UgdG8gKi9cbiAgICAgICAgaDogem9kXzEuei5udW1iZXIoKS5taW4oMCkub3B0aW9uYWwoKSxcbiAgICAgICAgLyoqIGEgc2NhbGluZyBtZXRob2QgKGUuZy4gUmVzaXplU3RyYXRlZ3kuQkVaSUVSKSAqL1xuICAgICAgICBtb2RlOiB6b2RfMS56Lm5hdGl2ZUVudW0oY29uc3RhbnRzX2pzXzEuUmVzaXplU3RyYXRlZ3kpLm9wdGlvbmFsKCksXG4gICAgfSksXG4gICAgem9kXzEuei5vYmplY3Qoe1xuICAgICAgICAvKiogdGhlIHdpZHRoIHRvIHJlc2l6ZSB0aGUgaW1hZ2UgdG8gKi9cbiAgICAgICAgdzogem9kXzEuei5udW1iZXIoKS5taW4oMCkub3B0aW9uYWwoKSxcbiAgICAgICAgLyoqIHRoZSBoZWlnaHQgdG8gcmVzaXplIHRoZSBpbWFnZSB0byAqL1xuICAgICAgICBoOiB6b2RfMS56Lm51bWJlcigpLm1pbigwKSxcbiAgICAgICAgLyoqIGEgc2NhbGluZyBtZXRob2QgKGUuZy4gUmVzaXplU3RyYXRlZ3kuQkVaSUVSKSAqL1xuICAgICAgICBtb2RlOiB6b2RfMS56Lm5hdGl2ZUVudW0oY29uc3RhbnRzX2pzXzEuUmVzaXplU3RyYXRlZ3kpLm9wdGlvbmFsKCksXG4gICAgfSksXG5dKTtcbmNvbnN0IFNjYWxlVG9GaXRPcHRpb25zU2NoZW1hID0gem9kXzEuei5vYmplY3Qoe1xuICAgIC8qKiB0aGUgd2lkdGggdG8gcmVzaXplIHRoZSBpbWFnZSB0byAqL1xuICAgIHc6IHpvZF8xLnoubnVtYmVyKCkubWluKDApLFxuICAgIC8qKiB0aGUgaGVpZ2h0IHRvIHJlc2l6ZSB0aGUgaW1hZ2UgdG8gKi9cbiAgICBoOiB6b2RfMS56Lm51bWJlcigpLm1pbigwKSxcbiAgICAvKiogYSBzY2FsaW5nIG1ldGhvZCAoZS5nLiBKaW1wLlJFU0laRV9CRVpJRVIpICovXG4gICAgbW9kZTogem9kXzEuei5uYXRpdmVFbnVtKGNvbnN0YW50c19qc18xLlJlc2l6ZVN0cmF0ZWd5KS5vcHRpb25hbCgpLFxufSk7XG5jb25zdCBTY2FsZUNvbXBsZXhPcHRpb25zU2NoZW1hID0gem9kXzEuei5vYmplY3Qoe1xuICAgIC8qKiB0aGUgd2lkdGggdG8gcmVzaXplIHRoZSBpbWFnZSB0byAqL1xuICAgIGY6IHpvZF8xLnoubnVtYmVyKCkubWluKDApLFxuICAgIC8qKiBhIHNjYWxpbmcgbWV0aG9kIChlLmcuIEppbXAuUkVTSVpFX0JFWklFUikgKi9cbiAgICBtb2RlOiB6b2RfMS56Lm5hdGl2ZUVudW0oY29uc3RhbnRzX2pzXzEuUmVzaXplU3RyYXRlZ3kpLm9wdGlvbmFsKCksXG59KTtcbmV4cG9ydHMubWV0aG9kcyA9IHtcbiAgICAvKipcbiAgICAgKiBSZXNpemVzIHRoZSBpbWFnZSB0byBhIHNldCB3aWR0aCBhbmQgaGVpZ2h0IHVzaW5nIGEgMi1wYXNzIGJpbGluZWFyIGFsZ29yaXRobVxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBpbXBvcnQgeyBKaW1wIH0gZnJvbSBcImppbXBcIjtcbiAgICAgKlxuICAgICAqIGNvbnN0IGltYWdlID0gYXdhaXQgSmltcC5yZWFkKFwidGVzdC9pbWFnZS5wbmdcIik7XG4gICAgICpcbiAgICAgKiBpbWFnZS5yZXNpemUoeyB3OiAxNTAgfSk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgcmVzaXplKGltYWdlLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHsgbW9kZSB9ID0gUmVzaXplT3B0aW9uc1NjaGVtYS5wYXJzZShvcHRpb25zKTtcbiAgICAgICAgbGV0IHc7XG4gICAgICAgIGxldCBoO1xuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMudyA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgdyA9IG9wdGlvbnMudztcbiAgICAgICAgICAgIGggPSBvcHRpb25zLmggPz8gaW1hZ2UuYml0bWFwLmhlaWdodCAqICh3IC8gaW1hZ2UuYml0bWFwLndpZHRoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucy5oID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICBoID0gb3B0aW9ucy5oO1xuICAgICAgICAgICAgdyA9IG9wdGlvbnMudyA/PyBpbWFnZS5iaXRtYXAud2lkdGggKiAoaCAvIGltYWdlLmJpdG1hcC5oZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidyBtdXN0IGJlIGEgbnVtYmVyXCIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJvdW5kIGlucHV0c1xuICAgICAgICB3ID0gTWF0aC5yb3VuZCh3KSB8fCAxO1xuICAgICAgICBoID0gTWF0aC5yb3VuZChoKSB8fCAxO1xuICAgICAgICBpZiAobW9kZSAmJiB0eXBlb2YgcmVzaXplMl9qc18xLm9wZXJhdGlvbnNbbW9kZV0gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgY29uc3QgZHN0ID0ge1xuICAgICAgICAgICAgICAgIGRhdGE6IEJ1ZmZlci5hbGxvYyh3ICogaCAqIDQpLFxuICAgICAgICAgICAgICAgIHdpZHRoOiB3LFxuICAgICAgICAgICAgICAgIGhlaWdodDogaCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXNpemUyX2pzXzEub3BlcmF0aW9uc1ttb2RlXShpbWFnZS5iaXRtYXAsIGRzdCk7XG4gICAgICAgICAgICBpbWFnZS5iaXRtYXAgPSBkc3Q7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCByZXNpemUgPSBuZXcgcmVzaXplX2pzXzEuZGVmYXVsdChpbWFnZS5iaXRtYXAud2lkdGgsIGltYWdlLmJpdG1hcC5oZWlnaHQsIHcsIGgsIHRydWUsIHRydWUsIChidWZmZXIpID0+IHtcbiAgICAgICAgICAgICAgICBpbWFnZS5iaXRtYXAuZGF0YSA9IEJ1ZmZlci5mcm9tKGJ1ZmZlcik7XG4gICAgICAgICAgICAgICAgaW1hZ2UuYml0bWFwLndpZHRoID0gdztcbiAgICAgICAgICAgICAgICBpbWFnZS5iaXRtYXAuaGVpZ2h0ID0gaDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmVzaXplLnJlc2l6ZShpbWFnZS5iaXRtYXAuZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGltYWdlO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogVW5pZm9ybWx5IHNjYWxlcyB0aGUgaW1hZ2UgYnkgYSBmYWN0b3IuXG4gICAgICogQHBhcmFtIGYgdGhlIGZhY3RvciB0byBzY2FsZSB0aGUgaW1hZ2UgYnlcbiAgICAgKiBAcGFyYW0gbW9kZSAob3B0aW9uYWwpIGEgc2NhbGluZyBtZXRob2QgKGUuZy4gSmltcC5SRVNJWkVfQkVaSUVSKVxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBpbXBvcnQgeyBKaW1wIH0gZnJvbSBcImppbXBcIjtcbiAgICAgKlxuICAgICAqIGNvbnN0IGltYWdlID0gYXdhaXQgSmltcC5yZWFkKFwidGVzdC9pbWFnZS5wbmdcIik7XG4gICAgICpcbiAgICAgKiBpbWFnZS5zY2FsZSgwLjUpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHNjYWxlKGltYWdlLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHsgZiwgbW9kZSB9ID0gdHlwZW9mIG9wdGlvbnMgPT09IFwibnVtYmVyXCJcbiAgICAgICAgICAgID8geyBmOiBvcHRpb25zIH1cbiAgICAgICAgICAgIDogU2NhbGVDb21wbGV4T3B0aW9uc1NjaGVtYS5wYXJzZShvcHRpb25zKTtcbiAgICAgICAgY29uc3QgdyA9IGltYWdlLmJpdG1hcC53aWR0aCAqIGY7XG4gICAgICAgIGNvbnN0IGggPSBpbWFnZS5iaXRtYXAuaGVpZ2h0ICogZjtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzaXplKGltYWdlLCB7IHcsIGgsIG1vZGU6IG1vZGUgfSk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBTY2FsZSB0aGUgaW1hZ2UgdG8gdGhlIGxhcmdlc3Qgc2l6ZSB0aGF0IGZpdHMgaW5zaWRlIHRoZSByZWN0YW5nbGUgdGhhdCBoYXMgdGhlIGdpdmVuIHdpZHRoIGFuZCBoZWlnaHQuXG4gICAgICogQHBhcmFtIHcgdGhlIHdpZHRoIHRvIHJlc2l6ZSB0aGUgaW1hZ2UgdG9cbiAgICAgKiBAcGFyYW0gaCB0aGUgaGVpZ2h0IHRvIHJlc2l6ZSB0aGUgaW1hZ2UgdG9cbiAgICAgKiBAcGFyYW0gbW9kZSBhIHNjYWxpbmcgbWV0aG9kIChlLmcuIFJlc2l6ZVN0cmF0ZWd5LkJFWklFUilcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHRzXG4gICAgICogaW1wb3J0IHsgSmltcCB9IGZyb20gXCJqaW1wXCI7XG4gICAgICpcbiAgICAgKiBjb25zdCBpbWFnZSA9IGF3YWl0IEppbXAucmVhZChcInRlc3QvaW1hZ2UucG5nXCIpO1xuICAgICAqXG4gICAgICogaW1hZ2Uuc2NhbGVUb0ZpdCgxMDAsIDEwMCk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgc2NhbGVUb0ZpdChpbWFnZSwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCB7IGgsIHcsIG1vZGUgfSA9IFNjYWxlVG9GaXRPcHRpb25zU2NoZW1hLnBhcnNlKG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBmID0gdyAvIGggPiBpbWFnZS5iaXRtYXAud2lkdGggLyBpbWFnZS5iaXRtYXAuaGVpZ2h0XG4gICAgICAgICAgICA/IGggLyBpbWFnZS5iaXRtYXAuaGVpZ2h0XG4gICAgICAgICAgICA6IHcgLyBpbWFnZS5iaXRtYXAud2lkdGg7XG4gICAgICAgIHJldHVybiB0aGlzLnNjYWxlKGltYWdlLCB7IGYsIG1vZGU6IG1vZGUgfSk7XG4gICAgfSxcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@jimp+plugin-resize@1.6.0/node_modules/@jimp/plugin-resize/dist/commonjs/index.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/@jimp+plugin-resize@1.6.0/node_modules/@jimp/plugin-resize/dist/commonjs/modules/resize.js":
/*!***************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@jimp+plugin-resize@1.6.0/node_modules/@jimp/plugin-resize/dist/commonjs/modules/resize.js ***!
  \***************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-nocheck\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n// JavaScript Image Resizer (c) 2012 - Grant Galitz\n// Released to public domain 29 July 2013: https://github.com/grantgalitz/JS-Image-Resizer/issues/4\nfunction Resize(widthOriginal, heightOriginal, targetWidth, targetHeight, blendAlpha, interpolationPass, resizeCallback) {\n    this.widthOriginal = Math.abs(Math.floor(widthOriginal) || 0);\n    this.heightOriginal = Math.abs(Math.floor(heightOriginal) || 0);\n    this.targetWidth = Math.abs(Math.floor(targetWidth) || 0);\n    this.targetHeight = Math.abs(Math.floor(targetHeight) || 0);\n    this.colorChannels = blendAlpha ? 4 : 3;\n    this.interpolationPass = Boolean(interpolationPass);\n    this.resizeCallback =\n        typeof resizeCallback === \"function\" ? resizeCallback : function () { };\n    this.targetWidthMultipliedByChannels = this.targetWidth * this.colorChannels;\n    this.originalWidthMultipliedByChannels =\n        this.widthOriginal * this.colorChannels;\n    this.originalHeightMultipliedByChannels =\n        this.heightOriginal * this.colorChannels;\n    this.widthPassResultSize =\n        this.targetWidthMultipliedByChannels * this.heightOriginal;\n    this.finalResultSize =\n        this.targetWidthMultipliedByChannels * this.targetHeight;\n    this.initialize();\n}\nResize.prototype.initialize = function () {\n    // Perform some checks:\n    if (this.widthOriginal > 0 &&\n        this.heightOriginal > 0 &&\n        this.targetWidth > 0 &&\n        this.targetHeight > 0) {\n        this.configurePasses();\n    }\n    else {\n        console.log(this);\n        throw new Error(\"Invalid settings specified for the resizer.\");\n    }\n};\nResize.prototype.configurePasses = function () {\n    if (this.widthOriginal === this.targetWidth) {\n        // Bypass the width resizer pass:\n        this.resizeWidth = this.bypassResizer;\n    }\n    else {\n        // Setup the width resizer pass:\n        this.ratioWeightWidthPass = this.widthOriginal / this.targetWidth;\n        if (this.ratioWeightWidthPass < 1 && this.interpolationPass) {\n            this.initializeFirstPassBuffers(true);\n            this.resizeWidth =\n                this.colorChannels === 4\n                    ? this.resizeWidthInterpolatedRGBA\n                    : this.resizeWidthInterpolatedRGB;\n        }\n        else {\n            this.initializeFirstPassBuffers(false);\n            this.resizeWidth =\n                this.colorChannels === 4 ? this.resizeWidthRGBA : this.resizeWidthRGB;\n        }\n    }\n    if (this.heightOriginal === this.targetHeight) {\n        // Bypass the height resizer pass:\n        this.resizeHeight = this.bypassResizer;\n    }\n    else {\n        // Setup the height resizer pass:\n        this.ratioWeightHeightPass = this.heightOriginal / this.targetHeight;\n        if (this.ratioWeightHeightPass < 1 && this.interpolationPass) {\n            this.initializeSecondPassBuffers(true);\n            this.resizeHeight = this.resizeHeightInterpolated;\n        }\n        else {\n            this.initializeSecondPassBuffers(false);\n            this.resizeHeight =\n                this.colorChannels === 4 ? this.resizeHeightRGBA : this.resizeHeightRGB;\n        }\n    }\n};\nResize.prototype._resizeWidthInterpolatedRGBChannels = function (buffer, fourthChannel) {\n    const channelsNum = fourthChannel ? 4 : 3;\n    const ratioWeight = this.ratioWeightWidthPass;\n    const outputBuffer = this.widthBuffer;\n    let weight = 0;\n    let finalOffset = 0;\n    let pixelOffset = 0;\n    let firstWeight = 0;\n    let secondWeight = 0;\n    let targetPosition;\n    // Handle for only one interpolation input being valid for start calculation:\n    for (targetPosition = 0; weight < 1 / 3; targetPosition += channelsNum, weight += ratioWeight) {\n        for (finalOffset = targetPosition, pixelOffset = 0; finalOffset < this.widthPassResultSize; pixelOffset += this.originalWidthMultipliedByChannels,\n            finalOffset += this.targetWidthMultipliedByChannels) {\n            outputBuffer[finalOffset] = buffer[pixelOffset];\n            outputBuffer[finalOffset + 1] = buffer[pixelOffset + 1];\n            outputBuffer[finalOffset + 2] = buffer[pixelOffset + 2];\n            if (fourthChannel)\n                outputBuffer[finalOffset + 3] = buffer[pixelOffset + 3];\n        }\n    }\n    // Adjust for overshoot of the last pass's counter:\n    weight -= 1 / 3;\n    let interpolationWidthSourceReadStop;\n    for (interpolationWidthSourceReadStop = this.widthOriginal - 1; weight < interpolationWidthSourceReadStop; targetPosition += channelsNum, weight += ratioWeight) {\n        // Calculate weightings:\n        secondWeight = weight % 1;\n        firstWeight = 1 - secondWeight;\n        // Interpolate:\n        for (finalOffset = targetPosition,\n            pixelOffset = Math.floor(weight) * channelsNum; finalOffset < this.widthPassResultSize; pixelOffset += this.originalWidthMultipliedByChannels,\n            finalOffset += this.targetWidthMultipliedByChannels) {\n            outputBuffer[finalOffset + 0] =\n                buffer[pixelOffset + 0] * firstWeight +\n                    buffer[pixelOffset + channelsNum + 0] * secondWeight;\n            outputBuffer[finalOffset + 1] =\n                buffer[pixelOffset + 1] * firstWeight +\n                    buffer[pixelOffset + channelsNum + 1] * secondWeight;\n            outputBuffer[finalOffset + 2] =\n                buffer[pixelOffset + 2] * firstWeight +\n                    buffer[pixelOffset + channelsNum + 2] * secondWeight;\n            if (fourthChannel)\n                outputBuffer[finalOffset + 3] =\n                    buffer[pixelOffset + 3] * firstWeight +\n                        buffer[pixelOffset + channelsNum + 3] * secondWeight;\n        }\n    }\n    // Handle for only one interpolation input being valid for end calculation:\n    for (interpolationWidthSourceReadStop =\n        this.originalWidthMultipliedByChannels - channelsNum; targetPosition < this.targetWidthMultipliedByChannels; targetPosition += channelsNum) {\n        for (finalOffset = targetPosition,\n            pixelOffset = interpolationWidthSourceReadStop; finalOffset < this.widthPassResultSize; pixelOffset += this.originalWidthMultipliedByChannels,\n            finalOffset += this.targetWidthMultipliedByChannels) {\n            outputBuffer[finalOffset] = buffer[pixelOffset];\n            outputBuffer[finalOffset + 1] = buffer[pixelOffset + 1];\n            outputBuffer[finalOffset + 2] = buffer[pixelOffset + 2];\n            if (fourthChannel)\n                outputBuffer[finalOffset + 3] = buffer[pixelOffset + 3];\n        }\n    }\n    return outputBuffer;\n};\nResize.prototype._resizeWidthRGBChannels = function (buffer, fourthChannel) {\n    const channelsNum = fourthChannel ? 4 : 3;\n    const ratioWeight = this.ratioWeightWidthPass;\n    const ratioWeightDivisor = 1 / ratioWeight;\n    const nextLineOffsetOriginalWidth = this.originalWidthMultipliedByChannels - channelsNum + 1;\n    const nextLineOffsetTargetWidth = this.targetWidthMultipliedByChannels - channelsNum + 1;\n    const output = this.outputWidthWorkBench;\n    const outputBuffer = this.widthBuffer;\n    const trustworthyColorsCount = this.outputWidthWorkBenchOpaquePixelsCount;\n    let weight = 0;\n    let amountToNext = 0;\n    let actualPosition = 0;\n    let currentPosition = 0;\n    let line = 0;\n    let pixelOffset = 0;\n    let outputOffset = 0;\n    let multiplier = 1;\n    let r = 0;\n    let g = 0;\n    let b = 0;\n    let a = 0;\n    do {\n        for (line = 0; line < this.originalHeightMultipliedByChannels;) {\n            output[line++] = 0;\n            output[line++] = 0;\n            output[line++] = 0;\n            if (fourthChannel) {\n                output[line++] = 0;\n                trustworthyColorsCount[line / channelsNum - 1] = 0;\n            }\n        }\n        weight = ratioWeight;\n        do {\n            amountToNext = 1 + actualPosition - currentPosition;\n            multiplier = Math.min(weight, amountToNext);\n            for (line = 0, pixelOffset = actualPosition; line < this.originalHeightMultipliedByChannels; pixelOffset += nextLineOffsetOriginalWidth) {\n                r = buffer[pixelOffset];\n                g = buffer[++pixelOffset];\n                b = buffer[++pixelOffset];\n                a = fourthChannel ? buffer[++pixelOffset] : 255;\n                // Ignore RGB values if pixel is completely transparent\n                output[line++] += (a ? r : 0) * multiplier;\n                output[line++] += (a ? g : 0) * multiplier;\n                output[line++] += (a ? b : 0) * multiplier;\n                if (fourthChannel) {\n                    output[line++] += a * multiplier;\n                    trustworthyColorsCount[line / channelsNum - 1] += a ? multiplier : 0;\n                }\n            }\n            if (weight >= amountToNext) {\n                actualPosition += channelsNum;\n                currentPosition = actualPosition;\n                weight -= amountToNext;\n            }\n            else {\n                currentPosition += weight;\n                break;\n            }\n        } while (weight > 0 &&\n            actualPosition < this.originalWidthMultipliedByChannels);\n        for (line = 0, pixelOffset = outputOffset; line < this.originalHeightMultipliedByChannels; pixelOffset += nextLineOffsetTargetWidth) {\n            weight = fourthChannel ? trustworthyColorsCount[line / channelsNum] : 1;\n            multiplier = fourthChannel\n                ? weight\n                    ? 1 / weight\n                    : 0\n                : ratioWeightDivisor;\n            outputBuffer[pixelOffset] = output[line++] * multiplier;\n            outputBuffer[++pixelOffset] = output[line++] * multiplier;\n            outputBuffer[++pixelOffset] = output[line++] * multiplier;\n            if (fourthChannel)\n                outputBuffer[++pixelOffset] = output[line++] * ratioWeightDivisor;\n        }\n        outputOffset += channelsNum;\n    } while (outputOffset < this.targetWidthMultipliedByChannels);\n    return outputBuffer;\n};\nResize.prototype._resizeHeightRGBChannels = function (buffer, fourthChannel) {\n    const ratioWeight = this.ratioWeightHeightPass;\n    const ratioWeightDivisor = 1 / ratioWeight;\n    const output = this.outputHeightWorkBench;\n    const outputBuffer = this.heightBuffer;\n    const trustworthyColorsCount = this.outputHeightWorkBenchOpaquePixelsCount;\n    let weight = 0;\n    let amountToNext = 0;\n    let actualPosition = 0;\n    let currentPosition = 0;\n    let pixelOffset = 0;\n    let outputOffset = 0;\n    let caret = 0;\n    let multiplier = 1;\n    let r = 0;\n    let g = 0;\n    let b = 0;\n    let a = 0;\n    do {\n        for (pixelOffset = 0; pixelOffset < this.targetWidthMultipliedByChannels;) {\n            output[pixelOffset++] = 0;\n            output[pixelOffset++] = 0;\n            output[pixelOffset++] = 0;\n            if (fourthChannel) {\n                output[pixelOffset++] = 0;\n                trustworthyColorsCount[pixelOffset / 4 - 1] = 0;\n            }\n        }\n        weight = ratioWeight;\n        do {\n            amountToNext = 1 + actualPosition - currentPosition;\n            multiplier = Math.min(weight, amountToNext);\n            caret = actualPosition;\n            for (pixelOffset = 0; pixelOffset < this.targetWidthMultipliedByChannels;) {\n                r = buffer[caret++];\n                g = buffer[caret++];\n                b = buffer[caret++];\n                a = fourthChannel ? buffer[caret++] : 255;\n                // Ignore RGB values if pixel is completely transparent\n                output[pixelOffset++] += (a ? r : 0) * multiplier;\n                output[pixelOffset++] += (a ? g : 0) * multiplier;\n                output[pixelOffset++] += (a ? b : 0) * multiplier;\n                if (fourthChannel) {\n                    output[pixelOffset++] += a * multiplier;\n                    trustworthyColorsCount[pixelOffset / 4 - 1] += a ? multiplier : 0;\n                }\n            }\n            if (weight >= amountToNext) {\n                actualPosition = caret;\n                currentPosition = actualPosition;\n                weight -= amountToNext;\n            }\n            else {\n                currentPosition += weight;\n                break;\n            }\n        } while (weight > 0 && actualPosition < this.widthPassResultSize);\n        for (pixelOffset = 0; pixelOffset < this.targetWidthMultipliedByChannels;) {\n            weight = fourthChannel ? trustworthyColorsCount[pixelOffset / 4] : 1;\n            multiplier = fourthChannel\n                ? weight\n                    ? 1 / weight\n                    : 0\n                : ratioWeightDivisor;\n            outputBuffer[outputOffset++] = Math.round(output[pixelOffset++] * multiplier);\n            outputBuffer[outputOffset++] = Math.round(output[pixelOffset++] * multiplier);\n            outputBuffer[outputOffset++] = Math.round(output[pixelOffset++] * multiplier);\n            if (fourthChannel) {\n                outputBuffer[outputOffset++] = Math.round(output[pixelOffset++] * ratioWeightDivisor);\n            }\n        }\n    } while (outputOffset < this.finalResultSize);\n    return outputBuffer;\n};\nResize.prototype.resizeWidthInterpolatedRGB = function (buffer) {\n    return this._resizeWidthInterpolatedRGBChannels(buffer, false);\n};\nResize.prototype.resizeWidthInterpolatedRGBA = function (buffer) {\n    return this._resizeWidthInterpolatedRGBChannels(buffer, true);\n};\nResize.prototype.resizeWidthRGB = function (buffer) {\n    return this._resizeWidthRGBChannels(buffer, false);\n};\nResize.prototype.resizeWidthRGBA = function (buffer) {\n    return this._resizeWidthRGBChannels(buffer, true);\n};\nResize.prototype.resizeHeightInterpolated = function (buffer) {\n    const ratioWeight = this.ratioWeightHeightPass;\n    const outputBuffer = this.heightBuffer;\n    let weight = 0;\n    let finalOffset = 0;\n    let pixelOffset = 0;\n    let pixelOffsetAccumulated = 0;\n    let pixelOffsetAccumulated2 = 0;\n    let firstWeight = 0;\n    let secondWeight = 0;\n    let interpolationHeightSourceReadStop;\n    // Handle for only one interpolation input being valid for start calculation:\n    for (; weight < 1 / 3; weight += ratioWeight) {\n        for (pixelOffset = 0; pixelOffset < this.targetWidthMultipliedByChannels;) {\n            outputBuffer[finalOffset++] = Math.round(buffer[pixelOffset++]);\n        }\n    }\n    // Adjust for overshoot of the last pass's counter:\n    weight -= 1 / 3;\n    for (interpolationHeightSourceReadStop = this.heightOriginal - 1; weight < interpolationHeightSourceReadStop; weight += ratioWeight) {\n        // Calculate weightings:\n        secondWeight = weight % 1;\n        firstWeight = 1 - secondWeight;\n        // Interpolate:\n        pixelOffsetAccumulated =\n            Math.floor(weight) * this.targetWidthMultipliedByChannels;\n        pixelOffsetAccumulated2 =\n            pixelOffsetAccumulated + this.targetWidthMultipliedByChannels;\n        for (pixelOffset = 0; pixelOffset < this.targetWidthMultipliedByChannels; ++pixelOffset) {\n            outputBuffer[finalOffset++] = Math.round(buffer[pixelOffsetAccumulated++] * firstWeight +\n                buffer[pixelOffsetAccumulated2++] * secondWeight);\n        }\n    }\n    // Handle for only one interpolation input being valid for end calculation:\n    while (finalOffset < this.finalResultSize) {\n        for (pixelOffset = 0,\n            pixelOffsetAccumulated =\n                interpolationHeightSourceReadStop *\n                    this.targetWidthMultipliedByChannels; pixelOffset < this.targetWidthMultipliedByChannels; ++pixelOffset) {\n            outputBuffer[finalOffset++] = Math.round(buffer[pixelOffsetAccumulated++]);\n        }\n    }\n    return outputBuffer;\n};\nResize.prototype.resizeHeightRGB = function (buffer) {\n    return this._resizeHeightRGBChannels(buffer, false);\n};\nResize.prototype.resizeHeightRGBA = function (buffer) {\n    return this._resizeHeightRGBChannels(buffer, true);\n};\nResize.prototype.resize = function (buffer) {\n    this.resizeCallback(this.resizeHeight(this.resizeWidth(buffer)));\n};\nResize.prototype.bypassResizer = function (buffer) {\n    // Just return the buffer passed:\n    return buffer;\n};\nResize.prototype.initializeFirstPassBuffers = function (BILINEARAlgo) {\n    // Initialize the internal width pass buffers:\n    this.widthBuffer = this.generateFloatBuffer(this.widthPassResultSize);\n    if (!BILINEARAlgo) {\n        this.outputWidthWorkBench = this.generateFloatBuffer(this.originalHeightMultipliedByChannels);\n        if (this.colorChannels > 3) {\n            this.outputWidthWorkBenchOpaquePixelsCount = this.generateFloat64Buffer(this.heightOriginal);\n        }\n    }\n};\nResize.prototype.initializeSecondPassBuffers = function (BILINEARAlgo) {\n    // Initialize the internal height pass buffers:\n    this.heightBuffer = this.generateUint8Buffer(this.finalResultSize);\n    if (!BILINEARAlgo) {\n        this.outputHeightWorkBench = this.generateFloatBuffer(this.targetWidthMultipliedByChannels);\n        if (this.colorChannels > 3) {\n            this.outputHeightWorkBenchOpaquePixelsCount = this.generateFloat64Buffer(this.targetWidth);\n        }\n    }\n};\nResize.prototype.generateFloatBuffer = function (bufferLength) {\n    // Generate a float32 typed array buffer:\n    try {\n        return new Float32Array(bufferLength);\n    }\n    catch (error) {\n        console.error(error);\n        return [];\n    }\n};\nResize.prototype.generateFloat64Buffer = function (bufferLength) {\n    // Generate a float64 typed array buffer:\n    try {\n        return new Float64Array(bufferLength);\n    }\n    catch (error) {\n        console.error(error);\n        return [];\n    }\n};\nResize.prototype.generateUint8Buffer = function (bufferLength) {\n    // Generate a uint8 typed array buffer:\n    try {\n        return new Uint8Array(bufferLength);\n    }\n    catch (error) {\n        console.error(error);\n        return [];\n    }\n};\nexports[\"default\"] = Resize;\n//# sourceMappingURL=resize.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BqaW1wK3BsdWdpbi1yZXNpemVAMS42LjAvbm9kZV9tb2R1bGVzL0BqaW1wL3BsdWdpbi1yZXNpemUvZGlzdC9jb21tb25qcy9tb2R1bGVzL3Jlc2l6ZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsZ0JBQWdCO0FBQzdDLDREQUE0RCx3Q0FBd0M7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSwyQ0FBMkM7QUFDL0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCx3Q0FBd0M7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELHVEQUF1RDtBQUNySDtBQUNBLDREQUE0RCx3Q0FBd0M7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QiwrQ0FBK0M7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELGdEQUFnRDtBQUN6RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLG1EQUFtRCxnREFBZ0Q7QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLG1EQUFtRDtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxtREFBbUQ7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsOEJBQThCLG1EQUFtRDtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnQkFBZ0I7QUFDM0IsOEJBQThCLG1EQUFtRDtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLDRDQUE0QztBQUNsSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLG9EQUFvRDtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsb0RBQW9EO0FBQzlHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBZTtBQUNmIiwic291cmNlcyI6WyIvVXNlcnMvbWlrZXdlc3RoYWQvRGVza3RvcC9SZXBvcy9zcG9yYWRpYy1sYWJzLXRpbGUtZXh0cnVkZXIvbm9kZV9tb2R1bGVzLy5wbnBtL0BqaW1wK3BsdWdpbi1yZXNpemVAMS42LjAvbm9kZV9tb2R1bGVzL0BqaW1wL3BsdWdpbi1yZXNpemUvZGlzdC9jb21tb25qcy9tb2R1bGVzL3Jlc2l6ZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnRcbi8vIEB0cy1ub2NoZWNrXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vLyBKYXZhU2NyaXB0IEltYWdlIFJlc2l6ZXIgKGMpIDIwMTIgLSBHcmFudCBHYWxpdHpcbi8vIFJlbGVhc2VkIHRvIHB1YmxpYyBkb21haW4gMjkgSnVseSAyMDEzOiBodHRwczovL2dpdGh1Yi5jb20vZ3JhbnRnYWxpdHovSlMtSW1hZ2UtUmVzaXplci9pc3N1ZXMvNFxuZnVuY3Rpb24gUmVzaXplKHdpZHRoT3JpZ2luYWwsIGhlaWdodE9yaWdpbmFsLCB0YXJnZXRXaWR0aCwgdGFyZ2V0SGVpZ2h0LCBibGVuZEFscGhhLCBpbnRlcnBvbGF0aW9uUGFzcywgcmVzaXplQ2FsbGJhY2spIHtcbiAgICB0aGlzLndpZHRoT3JpZ2luYWwgPSBNYXRoLmFicyhNYXRoLmZsb29yKHdpZHRoT3JpZ2luYWwpIHx8IDApO1xuICAgIHRoaXMuaGVpZ2h0T3JpZ2luYWwgPSBNYXRoLmFicyhNYXRoLmZsb29yKGhlaWdodE9yaWdpbmFsKSB8fCAwKTtcbiAgICB0aGlzLnRhcmdldFdpZHRoID0gTWF0aC5hYnMoTWF0aC5mbG9vcih0YXJnZXRXaWR0aCkgfHwgMCk7XG4gICAgdGhpcy50YXJnZXRIZWlnaHQgPSBNYXRoLmFicyhNYXRoLmZsb29yKHRhcmdldEhlaWdodCkgfHwgMCk7XG4gICAgdGhpcy5jb2xvckNoYW5uZWxzID0gYmxlbmRBbHBoYSA/IDQgOiAzO1xuICAgIHRoaXMuaW50ZXJwb2xhdGlvblBhc3MgPSBCb29sZWFuKGludGVycG9sYXRpb25QYXNzKTtcbiAgICB0aGlzLnJlc2l6ZUNhbGxiYWNrID1cbiAgICAgICAgdHlwZW9mIHJlc2l6ZUNhbGxiYWNrID09PSBcImZ1bmN0aW9uXCIgPyByZXNpemVDYWxsYmFjayA6IGZ1bmN0aW9uICgpIHsgfTtcbiAgICB0aGlzLnRhcmdldFdpZHRoTXVsdGlwbGllZEJ5Q2hhbm5lbHMgPSB0aGlzLnRhcmdldFdpZHRoICogdGhpcy5jb2xvckNoYW5uZWxzO1xuICAgIHRoaXMub3JpZ2luYWxXaWR0aE11bHRpcGxpZWRCeUNoYW5uZWxzID1cbiAgICAgICAgdGhpcy53aWR0aE9yaWdpbmFsICogdGhpcy5jb2xvckNoYW5uZWxzO1xuICAgIHRoaXMub3JpZ2luYWxIZWlnaHRNdWx0aXBsaWVkQnlDaGFubmVscyA9XG4gICAgICAgIHRoaXMuaGVpZ2h0T3JpZ2luYWwgKiB0aGlzLmNvbG9yQ2hhbm5lbHM7XG4gICAgdGhpcy53aWR0aFBhc3NSZXN1bHRTaXplID1cbiAgICAgICAgdGhpcy50YXJnZXRXaWR0aE11bHRpcGxpZWRCeUNoYW5uZWxzICogdGhpcy5oZWlnaHRPcmlnaW5hbDtcbiAgICB0aGlzLmZpbmFsUmVzdWx0U2l6ZSA9XG4gICAgICAgIHRoaXMudGFyZ2V0V2lkdGhNdWx0aXBsaWVkQnlDaGFubmVscyAqIHRoaXMudGFyZ2V0SGVpZ2h0O1xuICAgIHRoaXMuaW5pdGlhbGl6ZSgpO1xufVxuUmVzaXplLnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIFBlcmZvcm0gc29tZSBjaGVja3M6XG4gICAgaWYgKHRoaXMud2lkdGhPcmlnaW5hbCA+IDAgJiZcbiAgICAgICAgdGhpcy5oZWlnaHRPcmlnaW5hbCA+IDAgJiZcbiAgICAgICAgdGhpcy50YXJnZXRXaWR0aCA+IDAgJiZcbiAgICAgICAgdGhpcy50YXJnZXRIZWlnaHQgPiAwKSB7XG4gICAgICAgIHRoaXMuY29uZmlndXJlUGFzc2VzKCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zb2xlLmxvZyh0aGlzKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZXR0aW5ncyBzcGVjaWZpZWQgZm9yIHRoZSByZXNpemVyLlwiKTtcbiAgICB9XG59O1xuUmVzaXplLnByb3RvdHlwZS5jb25maWd1cmVQYXNzZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMud2lkdGhPcmlnaW5hbCA9PT0gdGhpcy50YXJnZXRXaWR0aCkge1xuICAgICAgICAvLyBCeXBhc3MgdGhlIHdpZHRoIHJlc2l6ZXIgcGFzczpcbiAgICAgICAgdGhpcy5yZXNpemVXaWR0aCA9IHRoaXMuYnlwYXNzUmVzaXplcjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIFNldHVwIHRoZSB3aWR0aCByZXNpemVyIHBhc3M6XG4gICAgICAgIHRoaXMucmF0aW9XZWlnaHRXaWR0aFBhc3MgPSB0aGlzLndpZHRoT3JpZ2luYWwgLyB0aGlzLnRhcmdldFdpZHRoO1xuICAgICAgICBpZiAodGhpcy5yYXRpb1dlaWdodFdpZHRoUGFzcyA8IDEgJiYgdGhpcy5pbnRlcnBvbGF0aW9uUGFzcykge1xuICAgICAgICAgICAgdGhpcy5pbml0aWFsaXplRmlyc3RQYXNzQnVmZmVycyh0cnVlKTtcbiAgICAgICAgICAgIHRoaXMucmVzaXplV2lkdGggPVxuICAgICAgICAgICAgICAgIHRoaXMuY29sb3JDaGFubmVscyA9PT0gNFxuICAgICAgICAgICAgICAgICAgICA/IHRoaXMucmVzaXplV2lkdGhJbnRlcnBvbGF0ZWRSR0JBXG4gICAgICAgICAgICAgICAgICAgIDogdGhpcy5yZXNpemVXaWR0aEludGVycG9sYXRlZFJHQjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaW5pdGlhbGl6ZUZpcnN0UGFzc0J1ZmZlcnMoZmFsc2UpO1xuICAgICAgICAgICAgdGhpcy5yZXNpemVXaWR0aCA9XG4gICAgICAgICAgICAgICAgdGhpcy5jb2xvckNoYW5uZWxzID09PSA0ID8gdGhpcy5yZXNpemVXaWR0aFJHQkEgOiB0aGlzLnJlc2l6ZVdpZHRoUkdCO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLmhlaWdodE9yaWdpbmFsID09PSB0aGlzLnRhcmdldEhlaWdodCkge1xuICAgICAgICAvLyBCeXBhc3MgdGhlIGhlaWdodCByZXNpemVyIHBhc3M6XG4gICAgICAgIHRoaXMucmVzaXplSGVpZ2h0ID0gdGhpcy5ieXBhc3NSZXNpemVyO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gU2V0dXAgdGhlIGhlaWdodCByZXNpemVyIHBhc3M6XG4gICAgICAgIHRoaXMucmF0aW9XZWlnaHRIZWlnaHRQYXNzID0gdGhpcy5oZWlnaHRPcmlnaW5hbCAvIHRoaXMudGFyZ2V0SGVpZ2h0O1xuICAgICAgICBpZiAodGhpcy5yYXRpb1dlaWdodEhlaWdodFBhc3MgPCAxICYmIHRoaXMuaW50ZXJwb2xhdGlvblBhc3MpIHtcbiAgICAgICAgICAgIHRoaXMuaW5pdGlhbGl6ZVNlY29uZFBhc3NCdWZmZXJzKHRydWUpO1xuICAgICAgICAgICAgdGhpcy5yZXNpemVIZWlnaHQgPSB0aGlzLnJlc2l6ZUhlaWdodEludGVycG9sYXRlZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaW5pdGlhbGl6ZVNlY29uZFBhc3NCdWZmZXJzKGZhbHNlKTtcbiAgICAgICAgICAgIHRoaXMucmVzaXplSGVpZ2h0ID1cbiAgICAgICAgICAgICAgICB0aGlzLmNvbG9yQ2hhbm5lbHMgPT09IDQgPyB0aGlzLnJlc2l6ZUhlaWdodFJHQkEgOiB0aGlzLnJlc2l6ZUhlaWdodFJHQjtcbiAgICAgICAgfVxuICAgIH1cbn07XG5SZXNpemUucHJvdG90eXBlLl9yZXNpemVXaWR0aEludGVycG9sYXRlZFJHQkNoYW5uZWxzID0gZnVuY3Rpb24gKGJ1ZmZlciwgZm91cnRoQ2hhbm5lbCkge1xuICAgIGNvbnN0IGNoYW5uZWxzTnVtID0gZm91cnRoQ2hhbm5lbCA/IDQgOiAzO1xuICAgIGNvbnN0IHJhdGlvV2VpZ2h0ID0gdGhpcy5yYXRpb1dlaWdodFdpZHRoUGFzcztcbiAgICBjb25zdCBvdXRwdXRCdWZmZXIgPSB0aGlzLndpZHRoQnVmZmVyO1xuICAgIGxldCB3ZWlnaHQgPSAwO1xuICAgIGxldCBmaW5hbE9mZnNldCA9IDA7XG4gICAgbGV0IHBpeGVsT2Zmc2V0ID0gMDtcbiAgICBsZXQgZmlyc3RXZWlnaHQgPSAwO1xuICAgIGxldCBzZWNvbmRXZWlnaHQgPSAwO1xuICAgIGxldCB0YXJnZXRQb3NpdGlvbjtcbiAgICAvLyBIYW5kbGUgZm9yIG9ubHkgb25lIGludGVycG9sYXRpb24gaW5wdXQgYmVpbmcgdmFsaWQgZm9yIHN0YXJ0IGNhbGN1bGF0aW9uOlxuICAgIGZvciAodGFyZ2V0UG9zaXRpb24gPSAwOyB3ZWlnaHQgPCAxIC8gMzsgdGFyZ2V0UG9zaXRpb24gKz0gY2hhbm5lbHNOdW0sIHdlaWdodCArPSByYXRpb1dlaWdodCkge1xuICAgICAgICBmb3IgKGZpbmFsT2Zmc2V0ID0gdGFyZ2V0UG9zaXRpb24sIHBpeGVsT2Zmc2V0ID0gMDsgZmluYWxPZmZzZXQgPCB0aGlzLndpZHRoUGFzc1Jlc3VsdFNpemU7IHBpeGVsT2Zmc2V0ICs9IHRoaXMub3JpZ2luYWxXaWR0aE11bHRpcGxpZWRCeUNoYW5uZWxzLFxuICAgICAgICAgICAgZmluYWxPZmZzZXQgKz0gdGhpcy50YXJnZXRXaWR0aE11bHRpcGxpZWRCeUNoYW5uZWxzKSB7XG4gICAgICAgICAgICBvdXRwdXRCdWZmZXJbZmluYWxPZmZzZXRdID0gYnVmZmVyW3BpeGVsT2Zmc2V0XTtcbiAgICAgICAgICAgIG91dHB1dEJ1ZmZlcltmaW5hbE9mZnNldCArIDFdID0gYnVmZmVyW3BpeGVsT2Zmc2V0ICsgMV07XG4gICAgICAgICAgICBvdXRwdXRCdWZmZXJbZmluYWxPZmZzZXQgKyAyXSA9IGJ1ZmZlcltwaXhlbE9mZnNldCArIDJdO1xuICAgICAgICAgICAgaWYgKGZvdXJ0aENoYW5uZWwpXG4gICAgICAgICAgICAgICAgb3V0cHV0QnVmZmVyW2ZpbmFsT2Zmc2V0ICsgM10gPSBidWZmZXJbcGl4ZWxPZmZzZXQgKyAzXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBBZGp1c3QgZm9yIG92ZXJzaG9vdCBvZiB0aGUgbGFzdCBwYXNzJ3MgY291bnRlcjpcbiAgICB3ZWlnaHQgLT0gMSAvIDM7XG4gICAgbGV0IGludGVycG9sYXRpb25XaWR0aFNvdXJjZVJlYWRTdG9wO1xuICAgIGZvciAoaW50ZXJwb2xhdGlvbldpZHRoU291cmNlUmVhZFN0b3AgPSB0aGlzLndpZHRoT3JpZ2luYWwgLSAxOyB3ZWlnaHQgPCBpbnRlcnBvbGF0aW9uV2lkdGhTb3VyY2VSZWFkU3RvcDsgdGFyZ2V0UG9zaXRpb24gKz0gY2hhbm5lbHNOdW0sIHdlaWdodCArPSByYXRpb1dlaWdodCkge1xuICAgICAgICAvLyBDYWxjdWxhdGUgd2VpZ2h0aW5nczpcbiAgICAgICAgc2Vjb25kV2VpZ2h0ID0gd2VpZ2h0ICUgMTtcbiAgICAgICAgZmlyc3RXZWlnaHQgPSAxIC0gc2Vjb25kV2VpZ2h0O1xuICAgICAgICAvLyBJbnRlcnBvbGF0ZTpcbiAgICAgICAgZm9yIChmaW5hbE9mZnNldCA9IHRhcmdldFBvc2l0aW9uLFxuICAgICAgICAgICAgcGl4ZWxPZmZzZXQgPSBNYXRoLmZsb29yKHdlaWdodCkgKiBjaGFubmVsc051bTsgZmluYWxPZmZzZXQgPCB0aGlzLndpZHRoUGFzc1Jlc3VsdFNpemU7IHBpeGVsT2Zmc2V0ICs9IHRoaXMub3JpZ2luYWxXaWR0aE11bHRpcGxpZWRCeUNoYW5uZWxzLFxuICAgICAgICAgICAgZmluYWxPZmZzZXQgKz0gdGhpcy50YXJnZXRXaWR0aE11bHRpcGxpZWRCeUNoYW5uZWxzKSB7XG4gICAgICAgICAgICBvdXRwdXRCdWZmZXJbZmluYWxPZmZzZXQgKyAwXSA9XG4gICAgICAgICAgICAgICAgYnVmZmVyW3BpeGVsT2Zmc2V0ICsgMF0gKiBmaXJzdFdlaWdodCArXG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlcltwaXhlbE9mZnNldCArIGNoYW5uZWxzTnVtICsgMF0gKiBzZWNvbmRXZWlnaHQ7XG4gICAgICAgICAgICBvdXRwdXRCdWZmZXJbZmluYWxPZmZzZXQgKyAxXSA9XG4gICAgICAgICAgICAgICAgYnVmZmVyW3BpeGVsT2Zmc2V0ICsgMV0gKiBmaXJzdFdlaWdodCArXG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlcltwaXhlbE9mZnNldCArIGNoYW5uZWxzTnVtICsgMV0gKiBzZWNvbmRXZWlnaHQ7XG4gICAgICAgICAgICBvdXRwdXRCdWZmZXJbZmluYWxPZmZzZXQgKyAyXSA9XG4gICAgICAgICAgICAgICAgYnVmZmVyW3BpeGVsT2Zmc2V0ICsgMl0gKiBmaXJzdFdlaWdodCArXG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlcltwaXhlbE9mZnNldCArIGNoYW5uZWxzTnVtICsgMl0gKiBzZWNvbmRXZWlnaHQ7XG4gICAgICAgICAgICBpZiAoZm91cnRoQ2hhbm5lbClcbiAgICAgICAgICAgICAgICBvdXRwdXRCdWZmZXJbZmluYWxPZmZzZXQgKyAzXSA9XG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlcltwaXhlbE9mZnNldCArIDNdICogZmlyc3RXZWlnaHQgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyW3BpeGVsT2Zmc2V0ICsgY2hhbm5lbHNOdW0gKyAzXSAqIHNlY29uZFdlaWdodDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBIYW5kbGUgZm9yIG9ubHkgb25lIGludGVycG9sYXRpb24gaW5wdXQgYmVpbmcgdmFsaWQgZm9yIGVuZCBjYWxjdWxhdGlvbjpcbiAgICBmb3IgKGludGVycG9sYXRpb25XaWR0aFNvdXJjZVJlYWRTdG9wID1cbiAgICAgICAgdGhpcy5vcmlnaW5hbFdpZHRoTXVsdGlwbGllZEJ5Q2hhbm5lbHMgLSBjaGFubmVsc051bTsgdGFyZ2V0UG9zaXRpb24gPCB0aGlzLnRhcmdldFdpZHRoTXVsdGlwbGllZEJ5Q2hhbm5lbHM7IHRhcmdldFBvc2l0aW9uICs9IGNoYW5uZWxzTnVtKSB7XG4gICAgICAgIGZvciAoZmluYWxPZmZzZXQgPSB0YXJnZXRQb3NpdGlvbixcbiAgICAgICAgICAgIHBpeGVsT2Zmc2V0ID0gaW50ZXJwb2xhdGlvbldpZHRoU291cmNlUmVhZFN0b3A7IGZpbmFsT2Zmc2V0IDwgdGhpcy53aWR0aFBhc3NSZXN1bHRTaXplOyBwaXhlbE9mZnNldCArPSB0aGlzLm9yaWdpbmFsV2lkdGhNdWx0aXBsaWVkQnlDaGFubmVscyxcbiAgICAgICAgICAgIGZpbmFsT2Zmc2V0ICs9IHRoaXMudGFyZ2V0V2lkdGhNdWx0aXBsaWVkQnlDaGFubmVscykge1xuICAgICAgICAgICAgb3V0cHV0QnVmZmVyW2ZpbmFsT2Zmc2V0XSA9IGJ1ZmZlcltwaXhlbE9mZnNldF07XG4gICAgICAgICAgICBvdXRwdXRCdWZmZXJbZmluYWxPZmZzZXQgKyAxXSA9IGJ1ZmZlcltwaXhlbE9mZnNldCArIDFdO1xuICAgICAgICAgICAgb3V0cHV0QnVmZmVyW2ZpbmFsT2Zmc2V0ICsgMl0gPSBidWZmZXJbcGl4ZWxPZmZzZXQgKyAyXTtcbiAgICAgICAgICAgIGlmIChmb3VydGhDaGFubmVsKVxuICAgICAgICAgICAgICAgIG91dHB1dEJ1ZmZlcltmaW5hbE9mZnNldCArIDNdID0gYnVmZmVyW3BpeGVsT2Zmc2V0ICsgM107XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dEJ1ZmZlcjtcbn07XG5SZXNpemUucHJvdG90eXBlLl9yZXNpemVXaWR0aFJHQkNoYW5uZWxzID0gZnVuY3Rpb24gKGJ1ZmZlciwgZm91cnRoQ2hhbm5lbCkge1xuICAgIGNvbnN0IGNoYW5uZWxzTnVtID0gZm91cnRoQ2hhbm5lbCA/IDQgOiAzO1xuICAgIGNvbnN0IHJhdGlvV2VpZ2h0ID0gdGhpcy5yYXRpb1dlaWdodFdpZHRoUGFzcztcbiAgICBjb25zdCByYXRpb1dlaWdodERpdmlzb3IgPSAxIC8gcmF0aW9XZWlnaHQ7XG4gICAgY29uc3QgbmV4dExpbmVPZmZzZXRPcmlnaW5hbFdpZHRoID0gdGhpcy5vcmlnaW5hbFdpZHRoTXVsdGlwbGllZEJ5Q2hhbm5lbHMgLSBjaGFubmVsc051bSArIDE7XG4gICAgY29uc3QgbmV4dExpbmVPZmZzZXRUYXJnZXRXaWR0aCA9IHRoaXMudGFyZ2V0V2lkdGhNdWx0aXBsaWVkQnlDaGFubmVscyAtIGNoYW5uZWxzTnVtICsgMTtcbiAgICBjb25zdCBvdXRwdXQgPSB0aGlzLm91dHB1dFdpZHRoV29ya0JlbmNoO1xuICAgIGNvbnN0IG91dHB1dEJ1ZmZlciA9IHRoaXMud2lkdGhCdWZmZXI7XG4gICAgY29uc3QgdHJ1c3R3b3J0aHlDb2xvcnNDb3VudCA9IHRoaXMub3V0cHV0V2lkdGhXb3JrQmVuY2hPcGFxdWVQaXhlbHNDb3VudDtcbiAgICBsZXQgd2VpZ2h0ID0gMDtcbiAgICBsZXQgYW1vdW50VG9OZXh0ID0gMDtcbiAgICBsZXQgYWN0dWFsUG9zaXRpb24gPSAwO1xuICAgIGxldCBjdXJyZW50UG9zaXRpb24gPSAwO1xuICAgIGxldCBsaW5lID0gMDtcbiAgICBsZXQgcGl4ZWxPZmZzZXQgPSAwO1xuICAgIGxldCBvdXRwdXRPZmZzZXQgPSAwO1xuICAgIGxldCBtdWx0aXBsaWVyID0gMTtcbiAgICBsZXQgciA9IDA7XG4gICAgbGV0IGcgPSAwO1xuICAgIGxldCBiID0gMDtcbiAgICBsZXQgYSA9IDA7XG4gICAgZG8ge1xuICAgICAgICBmb3IgKGxpbmUgPSAwOyBsaW5lIDwgdGhpcy5vcmlnaW5hbEhlaWdodE11bHRpcGxpZWRCeUNoYW5uZWxzOykge1xuICAgICAgICAgICAgb3V0cHV0W2xpbmUrK10gPSAwO1xuICAgICAgICAgICAgb3V0cHV0W2xpbmUrK10gPSAwO1xuICAgICAgICAgICAgb3V0cHV0W2xpbmUrK10gPSAwO1xuICAgICAgICAgICAgaWYgKGZvdXJ0aENoYW5uZWwpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXRbbGluZSsrXSA9IDA7XG4gICAgICAgICAgICAgICAgdHJ1c3R3b3J0aHlDb2xvcnNDb3VudFtsaW5lIC8gY2hhbm5lbHNOdW0gLSAxXSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgd2VpZ2h0ID0gcmF0aW9XZWlnaHQ7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGFtb3VudFRvTmV4dCA9IDEgKyBhY3R1YWxQb3NpdGlvbiAtIGN1cnJlbnRQb3NpdGlvbjtcbiAgICAgICAgICAgIG11bHRpcGxpZXIgPSBNYXRoLm1pbih3ZWlnaHQsIGFtb3VudFRvTmV4dCk7XG4gICAgICAgICAgICBmb3IgKGxpbmUgPSAwLCBwaXhlbE9mZnNldCA9IGFjdHVhbFBvc2l0aW9uOyBsaW5lIDwgdGhpcy5vcmlnaW5hbEhlaWdodE11bHRpcGxpZWRCeUNoYW5uZWxzOyBwaXhlbE9mZnNldCArPSBuZXh0TGluZU9mZnNldE9yaWdpbmFsV2lkdGgpIHtcbiAgICAgICAgICAgICAgICByID0gYnVmZmVyW3BpeGVsT2Zmc2V0XTtcbiAgICAgICAgICAgICAgICBnID0gYnVmZmVyWysrcGl4ZWxPZmZzZXRdO1xuICAgICAgICAgICAgICAgIGIgPSBidWZmZXJbKytwaXhlbE9mZnNldF07XG4gICAgICAgICAgICAgICAgYSA9IGZvdXJ0aENoYW5uZWwgPyBidWZmZXJbKytwaXhlbE9mZnNldF0gOiAyNTU7XG4gICAgICAgICAgICAgICAgLy8gSWdub3JlIFJHQiB2YWx1ZXMgaWYgcGl4ZWwgaXMgY29tcGxldGVseSB0cmFuc3BhcmVudFxuICAgICAgICAgICAgICAgIG91dHB1dFtsaW5lKytdICs9IChhID8gciA6IDApICogbXVsdGlwbGllcjtcbiAgICAgICAgICAgICAgICBvdXRwdXRbbGluZSsrXSArPSAoYSA/IGcgOiAwKSAqIG11bHRpcGxpZXI7XG4gICAgICAgICAgICAgICAgb3V0cHV0W2xpbmUrK10gKz0gKGEgPyBiIDogMCkgKiBtdWx0aXBsaWVyO1xuICAgICAgICAgICAgICAgIGlmIChmb3VydGhDaGFubmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dFtsaW5lKytdICs9IGEgKiBtdWx0aXBsaWVyO1xuICAgICAgICAgICAgICAgICAgICB0cnVzdHdvcnRoeUNvbG9yc0NvdW50W2xpbmUgLyBjaGFubmVsc051bSAtIDFdICs9IGEgPyBtdWx0aXBsaWVyIDogMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAod2VpZ2h0ID49IGFtb3VudFRvTmV4dCkge1xuICAgICAgICAgICAgICAgIGFjdHVhbFBvc2l0aW9uICs9IGNoYW5uZWxzTnVtO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRQb3NpdGlvbiA9IGFjdHVhbFBvc2l0aW9uO1xuICAgICAgICAgICAgICAgIHdlaWdodCAtPSBhbW91bnRUb05leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UG9zaXRpb24gKz0gd2VpZ2h0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IHdoaWxlICh3ZWlnaHQgPiAwICYmXG4gICAgICAgICAgICBhY3R1YWxQb3NpdGlvbiA8IHRoaXMub3JpZ2luYWxXaWR0aE11bHRpcGxpZWRCeUNoYW5uZWxzKTtcbiAgICAgICAgZm9yIChsaW5lID0gMCwgcGl4ZWxPZmZzZXQgPSBvdXRwdXRPZmZzZXQ7IGxpbmUgPCB0aGlzLm9yaWdpbmFsSGVpZ2h0TXVsdGlwbGllZEJ5Q2hhbm5lbHM7IHBpeGVsT2Zmc2V0ICs9IG5leHRMaW5lT2Zmc2V0VGFyZ2V0V2lkdGgpIHtcbiAgICAgICAgICAgIHdlaWdodCA9IGZvdXJ0aENoYW5uZWwgPyB0cnVzdHdvcnRoeUNvbG9yc0NvdW50W2xpbmUgLyBjaGFubmVsc051bV0gOiAxO1xuICAgICAgICAgICAgbXVsdGlwbGllciA9IGZvdXJ0aENoYW5uZWxcbiAgICAgICAgICAgICAgICA/IHdlaWdodFxuICAgICAgICAgICAgICAgICAgICA/IDEgLyB3ZWlnaHRcbiAgICAgICAgICAgICAgICAgICAgOiAwXG4gICAgICAgICAgICAgICAgOiByYXRpb1dlaWdodERpdmlzb3I7XG4gICAgICAgICAgICBvdXRwdXRCdWZmZXJbcGl4ZWxPZmZzZXRdID0gb3V0cHV0W2xpbmUrK10gKiBtdWx0aXBsaWVyO1xuICAgICAgICAgICAgb3V0cHV0QnVmZmVyWysrcGl4ZWxPZmZzZXRdID0gb3V0cHV0W2xpbmUrK10gKiBtdWx0aXBsaWVyO1xuICAgICAgICAgICAgb3V0cHV0QnVmZmVyWysrcGl4ZWxPZmZzZXRdID0gb3V0cHV0W2xpbmUrK10gKiBtdWx0aXBsaWVyO1xuICAgICAgICAgICAgaWYgKGZvdXJ0aENoYW5uZWwpXG4gICAgICAgICAgICAgICAgb3V0cHV0QnVmZmVyWysrcGl4ZWxPZmZzZXRdID0gb3V0cHV0W2xpbmUrK10gKiByYXRpb1dlaWdodERpdmlzb3I7XG4gICAgICAgIH1cbiAgICAgICAgb3V0cHV0T2Zmc2V0ICs9IGNoYW5uZWxzTnVtO1xuICAgIH0gd2hpbGUgKG91dHB1dE9mZnNldCA8IHRoaXMudGFyZ2V0V2lkdGhNdWx0aXBsaWVkQnlDaGFubmVscyk7XG4gICAgcmV0dXJuIG91dHB1dEJ1ZmZlcjtcbn07XG5SZXNpemUucHJvdG90eXBlLl9yZXNpemVIZWlnaHRSR0JDaGFubmVscyA9IGZ1bmN0aW9uIChidWZmZXIsIGZvdXJ0aENoYW5uZWwpIHtcbiAgICBjb25zdCByYXRpb1dlaWdodCA9IHRoaXMucmF0aW9XZWlnaHRIZWlnaHRQYXNzO1xuICAgIGNvbnN0IHJhdGlvV2VpZ2h0RGl2aXNvciA9IDEgLyByYXRpb1dlaWdodDtcbiAgICBjb25zdCBvdXRwdXQgPSB0aGlzLm91dHB1dEhlaWdodFdvcmtCZW5jaDtcbiAgICBjb25zdCBvdXRwdXRCdWZmZXIgPSB0aGlzLmhlaWdodEJ1ZmZlcjtcbiAgICBjb25zdCB0cnVzdHdvcnRoeUNvbG9yc0NvdW50ID0gdGhpcy5vdXRwdXRIZWlnaHRXb3JrQmVuY2hPcGFxdWVQaXhlbHNDb3VudDtcbiAgICBsZXQgd2VpZ2h0ID0gMDtcbiAgICBsZXQgYW1vdW50VG9OZXh0ID0gMDtcbiAgICBsZXQgYWN0dWFsUG9zaXRpb24gPSAwO1xuICAgIGxldCBjdXJyZW50UG9zaXRpb24gPSAwO1xuICAgIGxldCBwaXhlbE9mZnNldCA9IDA7XG4gICAgbGV0IG91dHB1dE9mZnNldCA9IDA7XG4gICAgbGV0IGNhcmV0ID0gMDtcbiAgICBsZXQgbXVsdGlwbGllciA9IDE7XG4gICAgbGV0IHIgPSAwO1xuICAgIGxldCBnID0gMDtcbiAgICBsZXQgYiA9IDA7XG4gICAgbGV0IGEgPSAwO1xuICAgIGRvIHtcbiAgICAgICAgZm9yIChwaXhlbE9mZnNldCA9IDA7IHBpeGVsT2Zmc2V0IDwgdGhpcy50YXJnZXRXaWR0aE11bHRpcGxpZWRCeUNoYW5uZWxzOykge1xuICAgICAgICAgICAgb3V0cHV0W3BpeGVsT2Zmc2V0KytdID0gMDtcbiAgICAgICAgICAgIG91dHB1dFtwaXhlbE9mZnNldCsrXSA9IDA7XG4gICAgICAgICAgICBvdXRwdXRbcGl4ZWxPZmZzZXQrK10gPSAwO1xuICAgICAgICAgICAgaWYgKGZvdXJ0aENoYW5uZWwpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXRbcGl4ZWxPZmZzZXQrK10gPSAwO1xuICAgICAgICAgICAgICAgIHRydXN0d29ydGh5Q29sb3JzQ291bnRbcGl4ZWxPZmZzZXQgLyA0IC0gMV0gPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHdlaWdodCA9IHJhdGlvV2VpZ2h0O1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBhbW91bnRUb05leHQgPSAxICsgYWN0dWFsUG9zaXRpb24gLSBjdXJyZW50UG9zaXRpb247XG4gICAgICAgICAgICBtdWx0aXBsaWVyID0gTWF0aC5taW4od2VpZ2h0LCBhbW91bnRUb05leHQpO1xuICAgICAgICAgICAgY2FyZXQgPSBhY3R1YWxQb3NpdGlvbjtcbiAgICAgICAgICAgIGZvciAocGl4ZWxPZmZzZXQgPSAwOyBwaXhlbE9mZnNldCA8IHRoaXMudGFyZ2V0V2lkdGhNdWx0aXBsaWVkQnlDaGFubmVsczspIHtcbiAgICAgICAgICAgICAgICByID0gYnVmZmVyW2NhcmV0KytdO1xuICAgICAgICAgICAgICAgIGcgPSBidWZmZXJbY2FyZXQrK107XG4gICAgICAgICAgICAgICAgYiA9IGJ1ZmZlcltjYXJldCsrXTtcbiAgICAgICAgICAgICAgICBhID0gZm91cnRoQ2hhbm5lbCA/IGJ1ZmZlcltjYXJldCsrXSA6IDI1NTtcbiAgICAgICAgICAgICAgICAvLyBJZ25vcmUgUkdCIHZhbHVlcyBpZiBwaXhlbCBpcyBjb21wbGV0ZWx5IHRyYW5zcGFyZW50XG4gICAgICAgICAgICAgICAgb3V0cHV0W3BpeGVsT2Zmc2V0KytdICs9IChhID8gciA6IDApICogbXVsdGlwbGllcjtcbiAgICAgICAgICAgICAgICBvdXRwdXRbcGl4ZWxPZmZzZXQrK10gKz0gKGEgPyBnIDogMCkgKiBtdWx0aXBsaWVyO1xuICAgICAgICAgICAgICAgIG91dHB1dFtwaXhlbE9mZnNldCsrXSArPSAoYSA/IGIgOiAwKSAqIG11bHRpcGxpZXI7XG4gICAgICAgICAgICAgICAgaWYgKGZvdXJ0aENoYW5uZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0W3BpeGVsT2Zmc2V0KytdICs9IGEgKiBtdWx0aXBsaWVyO1xuICAgICAgICAgICAgICAgICAgICB0cnVzdHdvcnRoeUNvbG9yc0NvdW50W3BpeGVsT2Zmc2V0IC8gNCAtIDFdICs9IGEgPyBtdWx0aXBsaWVyIDogMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAod2VpZ2h0ID49IGFtb3VudFRvTmV4dCkge1xuICAgICAgICAgICAgICAgIGFjdHVhbFBvc2l0aW9uID0gY2FyZXQ7XG4gICAgICAgICAgICAgICAgY3VycmVudFBvc2l0aW9uID0gYWN0dWFsUG9zaXRpb247XG4gICAgICAgICAgICAgICAgd2VpZ2h0IC09IGFtb3VudFRvTmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRQb3NpdGlvbiArPSB3ZWlnaHQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKHdlaWdodCA+IDAgJiYgYWN0dWFsUG9zaXRpb24gPCB0aGlzLndpZHRoUGFzc1Jlc3VsdFNpemUpO1xuICAgICAgICBmb3IgKHBpeGVsT2Zmc2V0ID0gMDsgcGl4ZWxPZmZzZXQgPCB0aGlzLnRhcmdldFdpZHRoTXVsdGlwbGllZEJ5Q2hhbm5lbHM7KSB7XG4gICAgICAgICAgICB3ZWlnaHQgPSBmb3VydGhDaGFubmVsID8gdHJ1c3R3b3J0aHlDb2xvcnNDb3VudFtwaXhlbE9mZnNldCAvIDRdIDogMTtcbiAgICAgICAgICAgIG11bHRpcGxpZXIgPSBmb3VydGhDaGFubmVsXG4gICAgICAgICAgICAgICAgPyB3ZWlnaHRcbiAgICAgICAgICAgICAgICAgICAgPyAxIC8gd2VpZ2h0XG4gICAgICAgICAgICAgICAgICAgIDogMFxuICAgICAgICAgICAgICAgIDogcmF0aW9XZWlnaHREaXZpc29yO1xuICAgICAgICAgICAgb3V0cHV0QnVmZmVyW291dHB1dE9mZnNldCsrXSA9IE1hdGgucm91bmQob3V0cHV0W3BpeGVsT2Zmc2V0KytdICogbXVsdGlwbGllcik7XG4gICAgICAgICAgICBvdXRwdXRCdWZmZXJbb3V0cHV0T2Zmc2V0KytdID0gTWF0aC5yb3VuZChvdXRwdXRbcGl4ZWxPZmZzZXQrK10gKiBtdWx0aXBsaWVyKTtcbiAgICAgICAgICAgIG91dHB1dEJ1ZmZlcltvdXRwdXRPZmZzZXQrK10gPSBNYXRoLnJvdW5kKG91dHB1dFtwaXhlbE9mZnNldCsrXSAqIG11bHRpcGxpZXIpO1xuICAgICAgICAgICAgaWYgKGZvdXJ0aENoYW5uZWwpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXRCdWZmZXJbb3V0cHV0T2Zmc2V0KytdID0gTWF0aC5yb3VuZChvdXRwdXRbcGl4ZWxPZmZzZXQrK10gKiByYXRpb1dlaWdodERpdmlzb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSB3aGlsZSAob3V0cHV0T2Zmc2V0IDwgdGhpcy5maW5hbFJlc3VsdFNpemUpO1xuICAgIHJldHVybiBvdXRwdXRCdWZmZXI7XG59O1xuUmVzaXplLnByb3RvdHlwZS5yZXNpemVXaWR0aEludGVycG9sYXRlZFJHQiA9IGZ1bmN0aW9uIChidWZmZXIpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVzaXplV2lkdGhJbnRlcnBvbGF0ZWRSR0JDaGFubmVscyhidWZmZXIsIGZhbHNlKTtcbn07XG5SZXNpemUucHJvdG90eXBlLnJlc2l6ZVdpZHRoSW50ZXJwb2xhdGVkUkdCQSA9IGZ1bmN0aW9uIChidWZmZXIpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVzaXplV2lkdGhJbnRlcnBvbGF0ZWRSR0JDaGFubmVscyhidWZmZXIsIHRydWUpO1xufTtcblJlc2l6ZS5wcm90b3R5cGUucmVzaXplV2lkdGhSR0IgPSBmdW5jdGlvbiAoYnVmZmVyKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jlc2l6ZVdpZHRoUkdCQ2hhbm5lbHMoYnVmZmVyLCBmYWxzZSk7XG59O1xuUmVzaXplLnByb3RvdHlwZS5yZXNpemVXaWR0aFJHQkEgPSBmdW5jdGlvbiAoYnVmZmVyKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jlc2l6ZVdpZHRoUkdCQ2hhbm5lbHMoYnVmZmVyLCB0cnVlKTtcbn07XG5SZXNpemUucHJvdG90eXBlLnJlc2l6ZUhlaWdodEludGVycG9sYXRlZCA9IGZ1bmN0aW9uIChidWZmZXIpIHtcbiAgICBjb25zdCByYXRpb1dlaWdodCA9IHRoaXMucmF0aW9XZWlnaHRIZWlnaHRQYXNzO1xuICAgIGNvbnN0IG91dHB1dEJ1ZmZlciA9IHRoaXMuaGVpZ2h0QnVmZmVyO1xuICAgIGxldCB3ZWlnaHQgPSAwO1xuICAgIGxldCBmaW5hbE9mZnNldCA9IDA7XG4gICAgbGV0IHBpeGVsT2Zmc2V0ID0gMDtcbiAgICBsZXQgcGl4ZWxPZmZzZXRBY2N1bXVsYXRlZCA9IDA7XG4gICAgbGV0IHBpeGVsT2Zmc2V0QWNjdW11bGF0ZWQyID0gMDtcbiAgICBsZXQgZmlyc3RXZWlnaHQgPSAwO1xuICAgIGxldCBzZWNvbmRXZWlnaHQgPSAwO1xuICAgIGxldCBpbnRlcnBvbGF0aW9uSGVpZ2h0U291cmNlUmVhZFN0b3A7XG4gICAgLy8gSGFuZGxlIGZvciBvbmx5IG9uZSBpbnRlcnBvbGF0aW9uIGlucHV0IGJlaW5nIHZhbGlkIGZvciBzdGFydCBjYWxjdWxhdGlvbjpcbiAgICBmb3IgKDsgd2VpZ2h0IDwgMSAvIDM7IHdlaWdodCArPSByYXRpb1dlaWdodCkge1xuICAgICAgICBmb3IgKHBpeGVsT2Zmc2V0ID0gMDsgcGl4ZWxPZmZzZXQgPCB0aGlzLnRhcmdldFdpZHRoTXVsdGlwbGllZEJ5Q2hhbm5lbHM7KSB7XG4gICAgICAgICAgICBvdXRwdXRCdWZmZXJbZmluYWxPZmZzZXQrK10gPSBNYXRoLnJvdW5kKGJ1ZmZlcltwaXhlbE9mZnNldCsrXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQWRqdXN0IGZvciBvdmVyc2hvb3Qgb2YgdGhlIGxhc3QgcGFzcydzIGNvdW50ZXI6XG4gICAgd2VpZ2h0IC09IDEgLyAzO1xuICAgIGZvciAoaW50ZXJwb2xhdGlvbkhlaWdodFNvdXJjZVJlYWRTdG9wID0gdGhpcy5oZWlnaHRPcmlnaW5hbCAtIDE7IHdlaWdodCA8IGludGVycG9sYXRpb25IZWlnaHRTb3VyY2VSZWFkU3RvcDsgd2VpZ2h0ICs9IHJhdGlvV2VpZ2h0KSB7XG4gICAgICAgIC8vIENhbGN1bGF0ZSB3ZWlnaHRpbmdzOlxuICAgICAgICBzZWNvbmRXZWlnaHQgPSB3ZWlnaHQgJSAxO1xuICAgICAgICBmaXJzdFdlaWdodCA9IDEgLSBzZWNvbmRXZWlnaHQ7XG4gICAgICAgIC8vIEludGVycG9sYXRlOlxuICAgICAgICBwaXhlbE9mZnNldEFjY3VtdWxhdGVkID1cbiAgICAgICAgICAgIE1hdGguZmxvb3Iod2VpZ2h0KSAqIHRoaXMudGFyZ2V0V2lkdGhNdWx0aXBsaWVkQnlDaGFubmVscztcbiAgICAgICAgcGl4ZWxPZmZzZXRBY2N1bXVsYXRlZDIgPVxuICAgICAgICAgICAgcGl4ZWxPZmZzZXRBY2N1bXVsYXRlZCArIHRoaXMudGFyZ2V0V2lkdGhNdWx0aXBsaWVkQnlDaGFubmVscztcbiAgICAgICAgZm9yIChwaXhlbE9mZnNldCA9IDA7IHBpeGVsT2Zmc2V0IDwgdGhpcy50YXJnZXRXaWR0aE11bHRpcGxpZWRCeUNoYW5uZWxzOyArK3BpeGVsT2Zmc2V0KSB7XG4gICAgICAgICAgICBvdXRwdXRCdWZmZXJbZmluYWxPZmZzZXQrK10gPSBNYXRoLnJvdW5kKGJ1ZmZlcltwaXhlbE9mZnNldEFjY3VtdWxhdGVkKytdICogZmlyc3RXZWlnaHQgK1xuICAgICAgICAgICAgICAgIGJ1ZmZlcltwaXhlbE9mZnNldEFjY3VtdWxhdGVkMisrXSAqIHNlY29uZFdlaWdodCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gSGFuZGxlIGZvciBvbmx5IG9uZSBpbnRlcnBvbGF0aW9uIGlucHV0IGJlaW5nIHZhbGlkIGZvciBlbmQgY2FsY3VsYXRpb246XG4gICAgd2hpbGUgKGZpbmFsT2Zmc2V0IDwgdGhpcy5maW5hbFJlc3VsdFNpemUpIHtcbiAgICAgICAgZm9yIChwaXhlbE9mZnNldCA9IDAsXG4gICAgICAgICAgICBwaXhlbE9mZnNldEFjY3VtdWxhdGVkID1cbiAgICAgICAgICAgICAgICBpbnRlcnBvbGF0aW9uSGVpZ2h0U291cmNlUmVhZFN0b3AgKlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRhcmdldFdpZHRoTXVsdGlwbGllZEJ5Q2hhbm5lbHM7IHBpeGVsT2Zmc2V0IDwgdGhpcy50YXJnZXRXaWR0aE11bHRpcGxpZWRCeUNoYW5uZWxzOyArK3BpeGVsT2Zmc2V0KSB7XG4gICAgICAgICAgICBvdXRwdXRCdWZmZXJbZmluYWxPZmZzZXQrK10gPSBNYXRoLnJvdW5kKGJ1ZmZlcltwaXhlbE9mZnNldEFjY3VtdWxhdGVkKytdKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0QnVmZmVyO1xufTtcblJlc2l6ZS5wcm90b3R5cGUucmVzaXplSGVpZ2h0UkdCID0gZnVuY3Rpb24gKGJ1ZmZlcikge1xuICAgIHJldHVybiB0aGlzLl9yZXNpemVIZWlnaHRSR0JDaGFubmVscyhidWZmZXIsIGZhbHNlKTtcbn07XG5SZXNpemUucHJvdG90eXBlLnJlc2l6ZUhlaWdodFJHQkEgPSBmdW5jdGlvbiAoYnVmZmVyKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jlc2l6ZUhlaWdodFJHQkNoYW5uZWxzKGJ1ZmZlciwgdHJ1ZSk7XG59O1xuUmVzaXplLnByb3RvdHlwZS5yZXNpemUgPSBmdW5jdGlvbiAoYnVmZmVyKSB7XG4gICAgdGhpcy5yZXNpemVDYWxsYmFjayh0aGlzLnJlc2l6ZUhlaWdodCh0aGlzLnJlc2l6ZVdpZHRoKGJ1ZmZlcikpKTtcbn07XG5SZXNpemUucHJvdG90eXBlLmJ5cGFzc1Jlc2l6ZXIgPSBmdW5jdGlvbiAoYnVmZmVyKSB7XG4gICAgLy8gSnVzdCByZXR1cm4gdGhlIGJ1ZmZlciBwYXNzZWQ6XG4gICAgcmV0dXJuIGJ1ZmZlcjtcbn07XG5SZXNpemUucHJvdG90eXBlLmluaXRpYWxpemVGaXJzdFBhc3NCdWZmZXJzID0gZnVuY3Rpb24gKEJJTElORUFSQWxnbykge1xuICAgIC8vIEluaXRpYWxpemUgdGhlIGludGVybmFsIHdpZHRoIHBhc3MgYnVmZmVyczpcbiAgICB0aGlzLndpZHRoQnVmZmVyID0gdGhpcy5nZW5lcmF0ZUZsb2F0QnVmZmVyKHRoaXMud2lkdGhQYXNzUmVzdWx0U2l6ZSk7XG4gICAgaWYgKCFCSUxJTkVBUkFsZ28pIHtcbiAgICAgICAgdGhpcy5vdXRwdXRXaWR0aFdvcmtCZW5jaCA9IHRoaXMuZ2VuZXJhdGVGbG9hdEJ1ZmZlcih0aGlzLm9yaWdpbmFsSGVpZ2h0TXVsdGlwbGllZEJ5Q2hhbm5lbHMpO1xuICAgICAgICBpZiAodGhpcy5jb2xvckNoYW5uZWxzID4gMykge1xuICAgICAgICAgICAgdGhpcy5vdXRwdXRXaWR0aFdvcmtCZW5jaE9wYXF1ZVBpeGVsc0NvdW50ID0gdGhpcy5nZW5lcmF0ZUZsb2F0NjRCdWZmZXIodGhpcy5oZWlnaHRPcmlnaW5hbCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuUmVzaXplLnByb3RvdHlwZS5pbml0aWFsaXplU2Vjb25kUGFzc0J1ZmZlcnMgPSBmdW5jdGlvbiAoQklMSU5FQVJBbGdvKSB7XG4gICAgLy8gSW5pdGlhbGl6ZSB0aGUgaW50ZXJuYWwgaGVpZ2h0IHBhc3MgYnVmZmVyczpcbiAgICB0aGlzLmhlaWdodEJ1ZmZlciA9IHRoaXMuZ2VuZXJhdGVVaW50OEJ1ZmZlcih0aGlzLmZpbmFsUmVzdWx0U2l6ZSk7XG4gICAgaWYgKCFCSUxJTkVBUkFsZ28pIHtcbiAgICAgICAgdGhpcy5vdXRwdXRIZWlnaHRXb3JrQmVuY2ggPSB0aGlzLmdlbmVyYXRlRmxvYXRCdWZmZXIodGhpcy50YXJnZXRXaWR0aE11bHRpcGxpZWRCeUNoYW5uZWxzKTtcbiAgICAgICAgaWYgKHRoaXMuY29sb3JDaGFubmVscyA+IDMpIHtcbiAgICAgICAgICAgIHRoaXMub3V0cHV0SGVpZ2h0V29ya0JlbmNoT3BhcXVlUGl4ZWxzQ291bnQgPSB0aGlzLmdlbmVyYXRlRmxvYXQ2NEJ1ZmZlcih0aGlzLnRhcmdldFdpZHRoKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5SZXNpemUucHJvdG90eXBlLmdlbmVyYXRlRmxvYXRCdWZmZXIgPSBmdW5jdGlvbiAoYnVmZmVyTGVuZ3RoKSB7XG4gICAgLy8gR2VuZXJhdGUgYSBmbG9hdDMyIHR5cGVkIGFycmF5IGJ1ZmZlcjpcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gbmV3IEZsb2F0MzJBcnJheShidWZmZXJMZW5ndGgpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG59O1xuUmVzaXplLnByb3RvdHlwZS5nZW5lcmF0ZUZsb2F0NjRCdWZmZXIgPSBmdW5jdGlvbiAoYnVmZmVyTGVuZ3RoKSB7XG4gICAgLy8gR2VuZXJhdGUgYSBmbG9hdDY0IHR5cGVkIGFycmF5IGJ1ZmZlcjpcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gbmV3IEZsb2F0NjRBcnJheShidWZmZXJMZW5ndGgpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG59O1xuUmVzaXplLnByb3RvdHlwZS5nZW5lcmF0ZVVpbnQ4QnVmZmVyID0gZnVuY3Rpb24gKGJ1ZmZlckxlbmd0aCkge1xuICAgIC8vIEdlbmVyYXRlIGEgdWludDggdHlwZWQgYXJyYXkgYnVmZmVyOlxuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShidWZmZXJMZW5ndGgpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gUmVzaXplO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVzaXplLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@jimp+plugin-resize@1.6.0/node_modules/@jimp/plugin-resize/dist/commonjs/modules/resize.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/@jimp+plugin-resize@1.6.0/node_modules/@jimp/plugin-resize/dist/commonjs/modules/resize2.js":
/*!****************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@jimp+plugin-resize@1.6.0/node_modules/@jimp/plugin-resize/dist/commonjs/modules/resize2.js ***!
  \****************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/* eslint-disable @typescript-eslint/no-explicit-any */\n/**\n * Copyright (c) 2015 Guyon Roche\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:</p>\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.operations = void 0;\nexports.operations = {\n    nearestNeighbor(src, dst) {\n        const wSrc = src.width;\n        const hSrc = src.height;\n        const wDst = dst.width;\n        const hDst = dst.height;\n        const bufSrc = src.data;\n        const bufDst = dst.data;\n        for (let i = 0; i < hDst; i++) {\n            for (let j = 0; j < wDst; j++) {\n                let posDst = (i * wDst + j) * 4;\n                const iSrc = Math.floor((i * hSrc) / hDst);\n                const jSrc = Math.floor((j * wSrc) / wDst);\n                let posSrc = (iSrc * wSrc + jSrc) * 4;\n                bufDst[posDst++] = bufSrc[posSrc++];\n                bufDst[posDst++] = bufSrc[posSrc++];\n                bufDst[posDst++] = bufSrc[posSrc++];\n                bufDst[posDst++] = bufSrc[posSrc++];\n            }\n        }\n    },\n    bilinearInterpolation(src, dst) {\n        const wSrc = src.width;\n        const hSrc = src.height;\n        const wDst = dst.width;\n        const hDst = dst.height;\n        const bufSrc = src.data;\n        const bufDst = dst.data;\n        const interpolate = function (k, kMin, vMin, kMax, vMax) {\n            // special case - k is integer\n            if (kMin === kMax) {\n                return vMin;\n            }\n            return Math.round((k - kMin) * vMax + (kMax - k) * vMin);\n        };\n        const assign = function (pos, offset, x, xMin, xMax, y, yMin, yMax) {\n            let posMin = (yMin * wSrc + xMin) * 4 + offset;\n            let posMax = (yMin * wSrc + xMax) * 4 + offset;\n            const vMin = interpolate(x, xMin, bufSrc[posMin], xMax, bufSrc[posMax]);\n            // special case, y is integer\n            if (yMax === yMin) {\n                bufDst[pos + offset] = vMin;\n            }\n            else {\n                posMin = (yMax * wSrc + xMin) * 4 + offset;\n                posMax = (yMax * wSrc + xMax) * 4 + offset;\n                const vMax = interpolate(x, xMin, bufSrc[posMin], xMax, bufSrc[posMax]);\n                bufDst[pos + offset] = interpolate(y, yMin, vMin, yMax, vMax);\n            }\n        };\n        for (let i = 0; i < hDst; i++) {\n            for (let j = 0; j < wDst; j++) {\n                const posDst = (i * wDst + j) * 4;\n                // x & y in src coordinates\n                const x = (j * wSrc) / wDst;\n                const xMin = Math.floor(x);\n                const xMax = Math.min(Math.ceil(x), wSrc - 1);\n                const y = (i * hSrc) / hDst;\n                const yMin = Math.floor(y);\n                const yMax = Math.min(Math.ceil(y), hSrc - 1);\n                assign(posDst, 0, x, xMin, xMax, y, yMin, yMax);\n                assign(posDst, 1, x, xMin, xMax, y, yMin, yMax);\n                assign(posDst, 2, x, xMin, xMax, y, yMin, yMax);\n                assign(posDst, 3, x, xMin, xMax, y, yMin, yMax);\n            }\n        }\n    },\n    _interpolate2D(src, dst, options, interpolate) {\n        const bufSrc = src.data;\n        const bufDst = dst.data;\n        const wSrc = src.width;\n        const hSrc = src.height;\n        const wDst = dst.width;\n        const hDst = dst.height;\n        // when dst smaller than src/2, interpolate first to a multiple between 0.5 and 1.0 src, then sum squares\n        const wM = Math.max(1, Math.floor(wSrc / wDst));\n        const wDst2 = wDst * wM;\n        const hM = Math.max(1, Math.floor(hSrc / hDst));\n        const hDst2 = hDst * hM;\n        // ===========================================================\n        // Pass 1 - interpolate rows\n        // buf1 has width of dst2 and height of src\n        const buf1 = Buffer.alloc(wDst2 * hSrc * 4);\n        for (let i = 0; i < hSrc; i++) {\n            for (let j = 0; j < wDst2; j++) {\n                // i in src coords, j in dst coords\n                // calculate x in src coords\n                // this interpolation requires 4 sample points and the two inner ones must be real\n                // the outer points can be fudged for the edges.\n                // therefore (wSrc-1)/wDst2\n                const x = (j * (wSrc - 1)) / wDst2;\n                const xPos = Math.floor(x);\n                const t = x - xPos;\n                const srcPos = (i * wSrc + xPos) * 4;\n                const buf1Pos = (i * wDst2 + j) * 4;\n                for (let k = 0; k < 4; k++) {\n                    const kPos = srcPos + k;\n                    const x0 = xPos > 0 ? bufSrc[kPos - 4] : 2 * bufSrc[kPos] - bufSrc[kPos + 4];\n                    const x1 = bufSrc[kPos];\n                    const x2 = bufSrc[kPos + 4];\n                    const x3 = xPos < wSrc - 2\n                        ? bufSrc[kPos + 8]\n                        : 2 * bufSrc[kPos + 4] - bufSrc[kPos];\n                    buf1[buf1Pos + k] = interpolate(x0, x1, x2, x3, t);\n                }\n            }\n        }\n        // this._writeFile(wDst2, hSrc, buf1, \"out/buf1.jpg\");\n        // ===========================================================\n        // Pass 2 - interpolate columns\n        // buf2 has width and height of dst2\n        const buf2 = Buffer.alloc(wDst2 * hDst2 * 4);\n        for (let i = 0; i < hDst2; i++) {\n            for (let j = 0; j < wDst2; j++) {\n                // i&j in dst2 coords\n                // calculate y in buf1 coords\n                // this interpolation requires 4 sample points and the two inner ones must be real\n                // the outer points can be fudged for the edges.\n                // therefore (hSrc-1)/hDst2\n                const y = (i * (hSrc - 1)) / hDst2;\n                const yPos = Math.floor(y);\n                const t = y - yPos;\n                const buf1Pos = (yPos * wDst2 + j) * 4;\n                const buf2Pos = (i * wDst2 + j) * 4;\n                for (let k = 0; k < 4; k++) {\n                    const kPos = buf1Pos + k;\n                    const y0 = yPos > 0\n                        ? buf1[kPos - wDst2 * 4]\n                        : 2 * buf1[kPos] - buf1[kPos + wDst2 * 4];\n                    const y1 = buf1[kPos];\n                    const y2 = buf1[kPos + wDst2 * 4];\n                    const y3 = yPos < hSrc - 2\n                        ? buf1[kPos + wDst2 * 8]\n                        : 2 * buf1[kPos + wDst2 * 4] - buf1[kPos];\n                    buf2[buf2Pos + k] = interpolate(y0, y1, y2, y3, t);\n                }\n            }\n        }\n        // this._writeFile(wDst2, hDst2, buf2, \"out/buf2.jpg\");\n        // ===========================================================\n        // Pass 3 - scale to dst\n        const m = wM * hM;\n        if (m > 1) {\n            for (let i = 0; i < hDst; i++) {\n                for (let j = 0; j < wDst; j++) {\n                    // i&j in dst bounded coords\n                    let r = 0;\n                    let g = 0;\n                    let b = 0;\n                    let a = 0;\n                    let realColors = 0;\n                    for (let y = 0; y < hM; y++) {\n                        const yPos = i * hM + y;\n                        for (let x = 0; x < wM; x++) {\n                            const xPos = j * wM + x;\n                            const xyPos = (yPos * wDst2 + xPos) * 4;\n                            const pixelAlpha = buf2[xyPos + 3];\n                            if (pixelAlpha) {\n                                r += buf2[xyPos];\n                                g += buf2[xyPos + 1];\n                                b += buf2[xyPos + 2];\n                                realColors++;\n                            }\n                            a += pixelAlpha;\n                        }\n                    }\n                    const pos = (i * wDst + j) * 4;\n                    bufDst[pos] = realColors ? Math.round(r / realColors) : 0;\n                    bufDst[pos + 1] = realColors ? Math.round(g / realColors) : 0;\n                    bufDst[pos + 2] = realColors ? Math.round(b / realColors) : 0;\n                    bufDst[pos + 3] = Math.round(a / m);\n                }\n            }\n        }\n        else {\n            // replace dst buffer with buf2\n            dst.data = buf2;\n        }\n    },\n    bicubicInterpolation(src, dst, options) {\n        const interpolateCubic = function (x0, x1, x2, x3, t) {\n            const a0 = x3 - x2 - x0 + x1;\n            const a1 = x0 - x1 - a0;\n            const a2 = x2 - x0;\n            const a3 = x1;\n            return Math.max(0, Math.min(255, a0 * (t * t * t) + a1 * (t * t) + a2 * t + a3));\n        };\n        return this._interpolate2D(src, dst, options, interpolateCubic);\n    },\n    hermiteInterpolation(src, dst, options) {\n        const interpolateHermite = function (x0, x1, x2, x3, t) {\n            const c0 = x1;\n            const c1 = 0.5 * (x2 - x0);\n            const c2 = x0 - 2.5 * x1 + 2 * x2 - 0.5 * x3;\n            const c3 = 0.5 * (x3 - x0) + 1.5 * (x1 - x2);\n            return Math.max(0, Math.min(255, Math.round(((c3 * t + c2) * t + c1) * t + c0)));\n        };\n        return this._interpolate2D(src, dst, options, interpolateHermite);\n    },\n    bezierInterpolation(src, dst, options) {\n        // between 2 points y(n), y(n+1), use next points out, y(n-1), y(n+2)\n        // to predict control points (a & b) to be placed at n+0.5\n        //  ya(n) = y(n) + (y(n+1)-y(n-1))/4\n        //  yb(n) = y(n+1) - (y(n+2)-y(n))/4\n        // then use std bezier to interpolate [n,n+1)\n        //  y(n+t) = y(n)*(1-t)^3 + 3 * ya(n)*(1-t)^2*t + 3 * yb(n)*(1-t)*t^2 + y(n+1)*t^3\n        //  note the 3* factor for the two control points\n        // for edge cases, can choose:\n        //  y(-1) = y(0) - 2*(y(1)-y(0))\n        //  y(w) = y(w-1) + 2*(y(w-1)-y(w-2))\n        // but can go with y(-1) = y(0) and y(w) = y(w-1)\n        const interpolateBezier = function (x0, x1, x2, x3, t) {\n            // x1, x2 are the knots, use x0 and x3 to calculate control points\n            const cp1 = x1 + (x2 - x0) / 4;\n            const cp2 = x2 - (x3 - x1) / 4;\n            const nt = 1 - t;\n            const c0 = x1 * nt * nt * nt;\n            const c1 = 3 * cp1 * nt * nt * t;\n            const c2 = 3 * cp2 * nt * t * t;\n            const c3 = x2 * t * t * t;\n            return Math.max(0, Math.min(255, Math.round(c0 + c1 + c2 + c3)));\n        };\n        return this._interpolate2D(src, dst, options, interpolateBezier);\n    },\n};\n//# sourceMappingURL=resize2.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BqaW1wK3BsdWdpbi1yZXNpemVAMS42LjAvbm9kZV9tb2R1bGVzL0BqaW1wL3BsdWdpbi1yZXNpemUvZGlzdC9jb21tb25qcy9tb2R1bGVzL3Jlc2l6ZTIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxrQkFBa0I7QUFDbEIsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFVBQVU7QUFDbEMsNEJBQTRCLFVBQVU7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixVQUFVO0FBQ2xDLDRCQUE0QixVQUFVO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsVUFBVTtBQUNsQyw0QkFBNEIsV0FBVztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxPQUFPO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFdBQVc7QUFDbkMsNEJBQTRCLFdBQVc7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsT0FBTztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsVUFBVTtBQUN0QyxnQ0FBZ0MsVUFBVTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsUUFBUTtBQUM1QztBQUNBLHdDQUF3QyxRQUFRO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvbWlrZXdlc3RoYWQvRGVza3RvcC9SZXBvcy9zcG9yYWRpYy1sYWJzLXRpbGUtZXh0cnVkZXIvbm9kZV9tb2R1bGVzLy5wbnBtL0BqaW1wK3BsdWdpbi1yZXNpemVAMS42LjAvbm9kZV9tb2R1bGVzL0BqaW1wL3BsdWdpbi1yZXNpemUvZGlzdC9jb21tb25qcy9tb2R1bGVzL3Jlc2l6ZTIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55ICovXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxNSBHdXlvbiBSb2NoZVxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczo8L3A+XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5vcGVyYXRpb25zID0gdm9pZCAwO1xuZXhwb3J0cy5vcGVyYXRpb25zID0ge1xuICAgIG5lYXJlc3ROZWlnaGJvcihzcmMsIGRzdCkge1xuICAgICAgICBjb25zdCB3U3JjID0gc3JjLndpZHRoO1xuICAgICAgICBjb25zdCBoU3JjID0gc3JjLmhlaWdodDtcbiAgICAgICAgY29uc3Qgd0RzdCA9IGRzdC53aWR0aDtcbiAgICAgICAgY29uc3QgaERzdCA9IGRzdC5oZWlnaHQ7XG4gICAgICAgIGNvbnN0IGJ1ZlNyYyA9IHNyYy5kYXRhO1xuICAgICAgICBjb25zdCBidWZEc3QgPSBkc3QuZGF0YTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBoRHN0OyBpKyspIHtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgd0RzdDsgaisrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHBvc0RzdCA9IChpICogd0RzdCArIGopICogNDtcbiAgICAgICAgICAgICAgICBjb25zdCBpU3JjID0gTWF0aC5mbG9vcigoaSAqIGhTcmMpIC8gaERzdCk7XG4gICAgICAgICAgICAgICAgY29uc3QgalNyYyA9IE1hdGguZmxvb3IoKGogKiB3U3JjKSAvIHdEc3QpO1xuICAgICAgICAgICAgICAgIGxldCBwb3NTcmMgPSAoaVNyYyAqIHdTcmMgKyBqU3JjKSAqIDQ7XG4gICAgICAgICAgICAgICAgYnVmRHN0W3Bvc0RzdCsrXSA9IGJ1ZlNyY1twb3NTcmMrK107XG4gICAgICAgICAgICAgICAgYnVmRHN0W3Bvc0RzdCsrXSA9IGJ1ZlNyY1twb3NTcmMrK107XG4gICAgICAgICAgICAgICAgYnVmRHN0W3Bvc0RzdCsrXSA9IGJ1ZlNyY1twb3NTcmMrK107XG4gICAgICAgICAgICAgICAgYnVmRHN0W3Bvc0RzdCsrXSA9IGJ1ZlNyY1twb3NTcmMrK107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGJpbGluZWFySW50ZXJwb2xhdGlvbihzcmMsIGRzdCkge1xuICAgICAgICBjb25zdCB3U3JjID0gc3JjLndpZHRoO1xuICAgICAgICBjb25zdCBoU3JjID0gc3JjLmhlaWdodDtcbiAgICAgICAgY29uc3Qgd0RzdCA9IGRzdC53aWR0aDtcbiAgICAgICAgY29uc3QgaERzdCA9IGRzdC5oZWlnaHQ7XG4gICAgICAgIGNvbnN0IGJ1ZlNyYyA9IHNyYy5kYXRhO1xuICAgICAgICBjb25zdCBidWZEc3QgPSBkc3QuZGF0YTtcbiAgICAgICAgY29uc3QgaW50ZXJwb2xhdGUgPSBmdW5jdGlvbiAoaywga01pbiwgdk1pbiwga01heCwgdk1heCkge1xuICAgICAgICAgICAgLy8gc3BlY2lhbCBjYXNlIC0gayBpcyBpbnRlZ2VyXG4gICAgICAgICAgICBpZiAoa01pbiA9PT0ga01heCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2TWluO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIE1hdGgucm91bmQoKGsgLSBrTWluKSAqIHZNYXggKyAoa01heCAtIGspICogdk1pbik7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGFzc2lnbiA9IGZ1bmN0aW9uIChwb3MsIG9mZnNldCwgeCwgeE1pbiwgeE1heCwgeSwgeU1pbiwgeU1heCkge1xuICAgICAgICAgICAgbGV0IHBvc01pbiA9ICh5TWluICogd1NyYyArIHhNaW4pICogNCArIG9mZnNldDtcbiAgICAgICAgICAgIGxldCBwb3NNYXggPSAoeU1pbiAqIHdTcmMgKyB4TWF4KSAqIDQgKyBvZmZzZXQ7XG4gICAgICAgICAgICBjb25zdCB2TWluID0gaW50ZXJwb2xhdGUoeCwgeE1pbiwgYnVmU3JjW3Bvc01pbl0sIHhNYXgsIGJ1ZlNyY1twb3NNYXhdKTtcbiAgICAgICAgICAgIC8vIHNwZWNpYWwgY2FzZSwgeSBpcyBpbnRlZ2VyXG4gICAgICAgICAgICBpZiAoeU1heCA9PT0geU1pbikge1xuICAgICAgICAgICAgICAgIGJ1ZkRzdFtwb3MgKyBvZmZzZXRdID0gdk1pbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHBvc01pbiA9ICh5TWF4ICogd1NyYyArIHhNaW4pICogNCArIG9mZnNldDtcbiAgICAgICAgICAgICAgICBwb3NNYXggPSAoeU1heCAqIHdTcmMgKyB4TWF4KSAqIDQgKyBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgY29uc3Qgdk1heCA9IGludGVycG9sYXRlKHgsIHhNaW4sIGJ1ZlNyY1twb3NNaW5dLCB4TWF4LCBidWZTcmNbcG9zTWF4XSk7XG4gICAgICAgICAgICAgICAgYnVmRHN0W3BvcyArIG9mZnNldF0gPSBpbnRlcnBvbGF0ZSh5LCB5TWluLCB2TWluLCB5TWF4LCB2TWF4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBoRHN0OyBpKyspIHtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgd0RzdDsgaisrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcG9zRHN0ID0gKGkgKiB3RHN0ICsgaikgKiA0O1xuICAgICAgICAgICAgICAgIC8vIHggJiB5IGluIHNyYyBjb29yZGluYXRlc1xuICAgICAgICAgICAgICAgIGNvbnN0IHggPSAoaiAqIHdTcmMpIC8gd0RzdDtcbiAgICAgICAgICAgICAgICBjb25zdCB4TWluID0gTWF0aC5mbG9vcih4KTtcbiAgICAgICAgICAgICAgICBjb25zdCB4TWF4ID0gTWF0aC5taW4oTWF0aC5jZWlsKHgpLCB3U3JjIC0gMSk7XG4gICAgICAgICAgICAgICAgY29uc3QgeSA9IChpICogaFNyYykgLyBoRHN0O1xuICAgICAgICAgICAgICAgIGNvbnN0IHlNaW4gPSBNYXRoLmZsb29yKHkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHlNYXggPSBNYXRoLm1pbihNYXRoLmNlaWwoeSksIGhTcmMgLSAxKTtcbiAgICAgICAgICAgICAgICBhc3NpZ24ocG9zRHN0LCAwLCB4LCB4TWluLCB4TWF4LCB5LCB5TWluLCB5TWF4KTtcbiAgICAgICAgICAgICAgICBhc3NpZ24ocG9zRHN0LCAxLCB4LCB4TWluLCB4TWF4LCB5LCB5TWluLCB5TWF4KTtcbiAgICAgICAgICAgICAgICBhc3NpZ24ocG9zRHN0LCAyLCB4LCB4TWluLCB4TWF4LCB5LCB5TWluLCB5TWF4KTtcbiAgICAgICAgICAgICAgICBhc3NpZ24ocG9zRHN0LCAzLCB4LCB4TWluLCB4TWF4LCB5LCB5TWluLCB5TWF4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgX2ludGVycG9sYXRlMkQoc3JjLCBkc3QsIG9wdGlvbnMsIGludGVycG9sYXRlKSB7XG4gICAgICAgIGNvbnN0IGJ1ZlNyYyA9IHNyYy5kYXRhO1xuICAgICAgICBjb25zdCBidWZEc3QgPSBkc3QuZGF0YTtcbiAgICAgICAgY29uc3Qgd1NyYyA9IHNyYy53aWR0aDtcbiAgICAgICAgY29uc3QgaFNyYyA9IHNyYy5oZWlnaHQ7XG4gICAgICAgIGNvbnN0IHdEc3QgPSBkc3Qud2lkdGg7XG4gICAgICAgIGNvbnN0IGhEc3QgPSBkc3QuaGVpZ2h0O1xuICAgICAgICAvLyB3aGVuIGRzdCBzbWFsbGVyIHRoYW4gc3JjLzIsIGludGVycG9sYXRlIGZpcnN0IHRvIGEgbXVsdGlwbGUgYmV0d2VlbiAwLjUgYW5kIDEuMCBzcmMsIHRoZW4gc3VtIHNxdWFyZXNcbiAgICAgICAgY29uc3Qgd00gPSBNYXRoLm1heCgxLCBNYXRoLmZsb29yKHdTcmMgLyB3RHN0KSk7XG4gICAgICAgIGNvbnN0IHdEc3QyID0gd0RzdCAqIHdNO1xuICAgICAgICBjb25zdCBoTSA9IE1hdGgubWF4KDEsIE1hdGguZmxvb3IoaFNyYyAvIGhEc3QpKTtcbiAgICAgICAgY29uc3QgaERzdDIgPSBoRHN0ICogaE07XG4gICAgICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgICAgIC8vIFBhc3MgMSAtIGludGVycG9sYXRlIHJvd3NcbiAgICAgICAgLy8gYnVmMSBoYXMgd2lkdGggb2YgZHN0MiBhbmQgaGVpZ2h0IG9mIHNyY1xuICAgICAgICBjb25zdCBidWYxID0gQnVmZmVyLmFsbG9jKHdEc3QyICogaFNyYyAqIDQpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGhTcmM7IGkrKykge1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB3RHN0MjsgaisrKSB7XG4gICAgICAgICAgICAgICAgLy8gaSBpbiBzcmMgY29vcmRzLCBqIGluIGRzdCBjb29yZHNcbiAgICAgICAgICAgICAgICAvLyBjYWxjdWxhdGUgeCBpbiBzcmMgY29vcmRzXG4gICAgICAgICAgICAgICAgLy8gdGhpcyBpbnRlcnBvbGF0aW9uIHJlcXVpcmVzIDQgc2FtcGxlIHBvaW50cyBhbmQgdGhlIHR3byBpbm5lciBvbmVzIG11c3QgYmUgcmVhbFxuICAgICAgICAgICAgICAgIC8vIHRoZSBvdXRlciBwb2ludHMgY2FuIGJlIGZ1ZGdlZCBmb3IgdGhlIGVkZ2VzLlxuICAgICAgICAgICAgICAgIC8vIHRoZXJlZm9yZSAod1NyYy0xKS93RHN0MlxuICAgICAgICAgICAgICAgIGNvbnN0IHggPSAoaiAqICh3U3JjIC0gMSkpIC8gd0RzdDI7XG4gICAgICAgICAgICAgICAgY29uc3QgeFBvcyA9IE1hdGguZmxvb3IoeCk7XG4gICAgICAgICAgICAgICAgY29uc3QgdCA9IHggLSB4UG9zO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNyY1BvcyA9IChpICogd1NyYyArIHhQb3MpICogNDtcbiAgICAgICAgICAgICAgICBjb25zdCBidWYxUG9zID0gKGkgKiB3RHN0MiArIGopICogNDtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IDQ7IGsrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBrUG9zID0gc3JjUG9zICsgaztcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeDAgPSB4UG9zID4gMCA/IGJ1ZlNyY1trUG9zIC0gNF0gOiAyICogYnVmU3JjW2tQb3NdIC0gYnVmU3JjW2tQb3MgKyA0XTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeDEgPSBidWZTcmNba1Bvc107XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHgyID0gYnVmU3JjW2tQb3MgKyA0XTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeDMgPSB4UG9zIDwgd1NyYyAtIDJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gYnVmU3JjW2tQb3MgKyA4XVxuICAgICAgICAgICAgICAgICAgICAgICAgOiAyICogYnVmU3JjW2tQb3MgKyA0XSAtIGJ1ZlNyY1trUG9zXTtcbiAgICAgICAgICAgICAgICAgICAgYnVmMVtidWYxUG9zICsga10gPSBpbnRlcnBvbGF0ZSh4MCwgeDEsIHgyLCB4MywgdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHRoaXMuX3dyaXRlRmlsZSh3RHN0MiwgaFNyYywgYnVmMSwgXCJvdXQvYnVmMS5qcGdcIik7XG4gICAgICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgICAgIC8vIFBhc3MgMiAtIGludGVycG9sYXRlIGNvbHVtbnNcbiAgICAgICAgLy8gYnVmMiBoYXMgd2lkdGggYW5kIGhlaWdodCBvZiBkc3QyXG4gICAgICAgIGNvbnN0IGJ1ZjIgPSBCdWZmZXIuYWxsb2Mod0RzdDIgKiBoRHN0MiAqIDQpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGhEc3QyOyBpKyspIHtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgd0RzdDI7IGorKykge1xuICAgICAgICAgICAgICAgIC8vIGkmaiBpbiBkc3QyIGNvb3Jkc1xuICAgICAgICAgICAgICAgIC8vIGNhbGN1bGF0ZSB5IGluIGJ1ZjEgY29vcmRzXG4gICAgICAgICAgICAgICAgLy8gdGhpcyBpbnRlcnBvbGF0aW9uIHJlcXVpcmVzIDQgc2FtcGxlIHBvaW50cyBhbmQgdGhlIHR3byBpbm5lciBvbmVzIG11c3QgYmUgcmVhbFxuICAgICAgICAgICAgICAgIC8vIHRoZSBvdXRlciBwb2ludHMgY2FuIGJlIGZ1ZGdlZCBmb3IgdGhlIGVkZ2VzLlxuICAgICAgICAgICAgICAgIC8vIHRoZXJlZm9yZSAoaFNyYy0xKS9oRHN0MlxuICAgICAgICAgICAgICAgIGNvbnN0IHkgPSAoaSAqIChoU3JjIC0gMSkpIC8gaERzdDI7XG4gICAgICAgICAgICAgICAgY29uc3QgeVBvcyA9IE1hdGguZmxvb3IoeSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdCA9IHkgLSB5UG9zO1xuICAgICAgICAgICAgICAgIGNvbnN0IGJ1ZjFQb3MgPSAoeVBvcyAqIHdEc3QyICsgaikgKiA0O1xuICAgICAgICAgICAgICAgIGNvbnN0IGJ1ZjJQb3MgPSAoaSAqIHdEc3QyICsgaikgKiA0O1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgNDsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGtQb3MgPSBidWYxUG9zICsgaztcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeTAgPSB5UG9zID4gMFxuICAgICAgICAgICAgICAgICAgICAgICAgPyBidWYxW2tQb3MgLSB3RHN0MiAqIDRdXG4gICAgICAgICAgICAgICAgICAgICAgICA6IDIgKiBidWYxW2tQb3NdIC0gYnVmMVtrUG9zICsgd0RzdDIgKiA0XTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeTEgPSBidWYxW2tQb3NdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB5MiA9IGJ1ZjFba1BvcyArIHdEc3QyICogNF07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHkzID0geVBvcyA8IGhTcmMgLSAyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGJ1ZjFba1BvcyArIHdEc3QyICogOF1cbiAgICAgICAgICAgICAgICAgICAgICAgIDogMiAqIGJ1ZjFba1BvcyArIHdEc3QyICogNF0gLSBidWYxW2tQb3NdO1xuICAgICAgICAgICAgICAgICAgICBidWYyW2J1ZjJQb3MgKyBrXSA9IGludGVycG9sYXRlKHkwLCB5MSwgeTIsIHkzLCB0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gdGhpcy5fd3JpdGVGaWxlKHdEc3QyLCBoRHN0MiwgYnVmMiwgXCJvdXQvYnVmMi5qcGdcIik7XG4gICAgICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgICAgIC8vIFBhc3MgMyAtIHNjYWxlIHRvIGRzdFxuICAgICAgICBjb25zdCBtID0gd00gKiBoTTtcbiAgICAgICAgaWYgKG0gPiAxKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGhEc3Q7IGkrKykge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgd0RzdDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGkmaiBpbiBkc3QgYm91bmRlZCBjb29yZHNcbiAgICAgICAgICAgICAgICAgICAgbGV0IHIgPSAwO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZyA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGxldCBiID0gMDtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGEgPSAwO1xuICAgICAgICAgICAgICAgICAgICBsZXQgcmVhbENvbG9ycyA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgaE07IHkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeVBvcyA9IGkgKiBoTSArIHk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHdNOyB4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB4UG9zID0gaiAqIHdNICsgeDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB4eVBvcyA9ICh5UG9zICogd0RzdDIgKyB4UG9zKSAqIDQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGl4ZWxBbHBoYSA9IGJ1ZjJbeHlQb3MgKyAzXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGl4ZWxBbHBoYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByICs9IGJ1ZjJbeHlQb3NdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnICs9IGJ1ZjJbeHlQb3MgKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYiArPSBidWYyW3h5UG9zICsgMl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWxDb2xvcnMrKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYSArPSBwaXhlbEFscGhhO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBvcyA9IChpICogd0RzdCArIGopICogNDtcbiAgICAgICAgICAgICAgICAgICAgYnVmRHN0W3Bvc10gPSByZWFsQ29sb3JzID8gTWF0aC5yb3VuZChyIC8gcmVhbENvbG9ycykgOiAwO1xuICAgICAgICAgICAgICAgICAgICBidWZEc3RbcG9zICsgMV0gPSByZWFsQ29sb3JzID8gTWF0aC5yb3VuZChnIC8gcmVhbENvbG9ycykgOiAwO1xuICAgICAgICAgICAgICAgICAgICBidWZEc3RbcG9zICsgMl0gPSByZWFsQ29sb3JzID8gTWF0aC5yb3VuZChiIC8gcmVhbENvbG9ycykgOiAwO1xuICAgICAgICAgICAgICAgICAgICBidWZEc3RbcG9zICsgM10gPSBNYXRoLnJvdW5kKGEgLyBtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyByZXBsYWNlIGRzdCBidWZmZXIgd2l0aCBidWYyXG4gICAgICAgICAgICBkc3QuZGF0YSA9IGJ1ZjI7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGJpY3ViaWNJbnRlcnBvbGF0aW9uKHNyYywgZHN0LCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGludGVycG9sYXRlQ3ViaWMgPSBmdW5jdGlvbiAoeDAsIHgxLCB4MiwgeDMsIHQpIHtcbiAgICAgICAgICAgIGNvbnN0IGEwID0geDMgLSB4MiAtIHgwICsgeDE7XG4gICAgICAgICAgICBjb25zdCBhMSA9IHgwIC0geDEgLSBhMDtcbiAgICAgICAgICAgIGNvbnN0IGEyID0geDIgLSB4MDtcbiAgICAgICAgICAgIGNvbnN0IGEzID0geDE7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5tYXgoMCwgTWF0aC5taW4oMjU1LCBhMCAqICh0ICogdCAqIHQpICsgYTEgKiAodCAqIHQpICsgYTIgKiB0ICsgYTMpKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludGVycG9sYXRlMkQoc3JjLCBkc3QsIG9wdGlvbnMsIGludGVycG9sYXRlQ3ViaWMpO1xuICAgIH0sXG4gICAgaGVybWl0ZUludGVycG9sYXRpb24oc3JjLCBkc3QsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgaW50ZXJwb2xhdGVIZXJtaXRlID0gZnVuY3Rpb24gKHgwLCB4MSwgeDIsIHgzLCB0KSB7XG4gICAgICAgICAgICBjb25zdCBjMCA9IHgxO1xuICAgICAgICAgICAgY29uc3QgYzEgPSAwLjUgKiAoeDIgLSB4MCk7XG4gICAgICAgICAgICBjb25zdCBjMiA9IHgwIC0gMi41ICogeDEgKyAyICogeDIgLSAwLjUgKiB4MztcbiAgICAgICAgICAgIGNvbnN0IGMzID0gMC41ICogKHgzIC0geDApICsgMS41ICogKHgxIC0geDIpO1xuICAgICAgICAgICAgcmV0dXJuIE1hdGgubWF4KDAsIE1hdGgubWluKDI1NSwgTWF0aC5yb3VuZCgoKGMzICogdCArIGMyKSAqIHQgKyBjMSkgKiB0ICsgYzApKSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnRlcnBvbGF0ZTJEKHNyYywgZHN0LCBvcHRpb25zLCBpbnRlcnBvbGF0ZUhlcm1pdGUpO1xuICAgIH0sXG4gICAgYmV6aWVySW50ZXJwb2xhdGlvbihzcmMsIGRzdCwgb3B0aW9ucykge1xuICAgICAgICAvLyBiZXR3ZWVuIDIgcG9pbnRzIHkobiksIHkobisxKSwgdXNlIG5leHQgcG9pbnRzIG91dCwgeShuLTEpLCB5KG4rMilcbiAgICAgICAgLy8gdG8gcHJlZGljdCBjb250cm9sIHBvaW50cyAoYSAmIGIpIHRvIGJlIHBsYWNlZCBhdCBuKzAuNVxuICAgICAgICAvLyAgeWEobikgPSB5KG4pICsgKHkobisxKS15KG4tMSkpLzRcbiAgICAgICAgLy8gIHliKG4pID0geShuKzEpIC0gKHkobisyKS15KG4pKS80XG4gICAgICAgIC8vIHRoZW4gdXNlIHN0ZCBiZXppZXIgdG8gaW50ZXJwb2xhdGUgW24sbisxKVxuICAgICAgICAvLyAgeShuK3QpID0geShuKSooMS10KV4zICsgMyAqIHlhKG4pKigxLXQpXjIqdCArIDMgKiB5YihuKSooMS10KSp0XjIgKyB5KG4rMSkqdF4zXG4gICAgICAgIC8vICBub3RlIHRoZSAzKiBmYWN0b3IgZm9yIHRoZSB0d28gY29udHJvbCBwb2ludHNcbiAgICAgICAgLy8gZm9yIGVkZ2UgY2FzZXMsIGNhbiBjaG9vc2U6XG4gICAgICAgIC8vICB5KC0xKSA9IHkoMCkgLSAyKih5KDEpLXkoMCkpXG4gICAgICAgIC8vICB5KHcpID0geSh3LTEpICsgMiooeSh3LTEpLXkody0yKSlcbiAgICAgICAgLy8gYnV0IGNhbiBnbyB3aXRoIHkoLTEpID0geSgwKSBhbmQgeSh3KSA9IHkody0xKVxuICAgICAgICBjb25zdCBpbnRlcnBvbGF0ZUJlemllciA9IGZ1bmN0aW9uICh4MCwgeDEsIHgyLCB4MywgdCkge1xuICAgICAgICAgICAgLy8geDEsIHgyIGFyZSB0aGUga25vdHMsIHVzZSB4MCBhbmQgeDMgdG8gY2FsY3VsYXRlIGNvbnRyb2wgcG9pbnRzXG4gICAgICAgICAgICBjb25zdCBjcDEgPSB4MSArICh4MiAtIHgwKSAvIDQ7XG4gICAgICAgICAgICBjb25zdCBjcDIgPSB4MiAtICh4MyAtIHgxKSAvIDQ7XG4gICAgICAgICAgICBjb25zdCBudCA9IDEgLSB0O1xuICAgICAgICAgICAgY29uc3QgYzAgPSB4MSAqIG50ICogbnQgKiBudDtcbiAgICAgICAgICAgIGNvbnN0IGMxID0gMyAqIGNwMSAqIG50ICogbnQgKiB0O1xuICAgICAgICAgICAgY29uc3QgYzIgPSAzICogY3AyICogbnQgKiB0ICogdDtcbiAgICAgICAgICAgIGNvbnN0IGMzID0geDIgKiB0ICogdCAqIHQ7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5tYXgoMCwgTWF0aC5taW4oMjU1LCBNYXRoLnJvdW5kKGMwICsgYzEgKyBjMiArIGMzKSkpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5faW50ZXJwb2xhdGUyRChzcmMsIGRzdCwgb3B0aW9ucywgaW50ZXJwb2xhdGVCZXppZXIpO1xuICAgIH0sXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVzaXplMi5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@jimp+plugin-resize@1.6.0/node_modules/@jimp/plugin-resize/dist/commonjs/modules/resize2.js\n");

/***/ })

};
;