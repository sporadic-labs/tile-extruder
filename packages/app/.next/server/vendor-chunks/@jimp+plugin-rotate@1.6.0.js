"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@jimp+plugin-rotate@1.6.0";
exports.ids = ["vendor-chunks/@jimp+plugin-rotate@1.6.0"];
exports.modules = {

/***/ "(ssr)/../../node_modules/.pnpm/@jimp+plugin-rotate@1.6.0/node_modules/@jimp/plugin-rotate/dist/commonjs/index.js":
/*!******************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@jimp+plugin-rotate@1.6.0/node_modules/@jimp/plugin-rotate/dist/commonjs/index.js ***!
  \******************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.methods = void 0;\nconst plugin_resize_1 = __webpack_require__(/*! @jimp/plugin-resize */ \"(ssr)/../../node_modules/.pnpm/@jimp+plugin-resize@1.6.0/node_modules/@jimp/plugin-resize/dist/commonjs/index.js\");\nconst utils_1 = __webpack_require__(/*! @jimp/utils */ \"(ssr)/../../node_modules/.pnpm/@jimp+utils@1.6.0/node_modules/@jimp/utils/dist/commonjs/index.js\");\nconst core_1 = __webpack_require__(/*! @jimp/core */ \"(ssr)/../../node_modules/.pnpm/@jimp+core@1.6.0/node_modules/@jimp/core/dist/commonjs/index.js\");\nconst plugin_crop_1 = __webpack_require__(/*! @jimp/plugin-crop */ \"(ssr)/../../node_modules/.pnpm/@jimp+plugin-crop@1.6.0/node_modules/@jimp/plugin-crop/dist/commonjs/index.js\");\nconst zod_1 = __webpack_require__(/*! zod */ \"(ssr)/../../node_modules/.pnpm/zod@3.24.1/node_modules/zod/lib/index.js\");\nconst RotateOptionsSchema = zod_1.z.union([\n    zod_1.z.number(),\n    zod_1.z.object({\n        /** the number of degrees to rotate the image by */\n        deg: zod_1.z.number(),\n        /** resize mode or a boolean, if false then the width and height of the image will not be changed */\n        mode: zod_1.z.union([zod_1.z.boolean(), zod_1.z.nativeEnum(plugin_resize_1.ResizeStrategy)]).optional(),\n    }),\n]);\n/** function to translate the x, y coordinate to the index of the pixel in the buffer */\nfunction createIdxTranslationFunction(w) {\n    return function (x, y) {\n        return (y * w + x) << 2;\n    };\n}\n/**\n * Rotates an image counter-clockwise by multiple of 90 degrees. NB: 'this' must be a Jimp object.\n *\n * This function is based on matrix rotation. Check this to get an initial idea how it works: https://stackoverflow.com/a/8664879/10561909\n *\n * @param deg the number of degrees to rotate the image by, it should be a multiple of 90\n */\nfunction matrixRotate(image, deg) {\n    if (Math.abs(deg) % 90 !== 0) {\n        throw new Error(\"Unsupported matrix rotation degree\");\n    }\n    const w = image.bitmap.width;\n    const h = image.bitmap.height;\n    // decide which rotation angle to use\n    let angle;\n    switch (deg) {\n        // 90 degree & -270 degree are same\n        case 90:\n        case -270:\n            angle = 90;\n            break;\n        case 180:\n        case -180:\n            angle = 180;\n            break;\n        case 270:\n        case -90:\n            angle = -90;\n            break;\n        default:\n            throw new Error(\"Unsupported matrix rotation degree\");\n    }\n    // After this switch block, angle will be 90, 180 or -90\n    // calculate the new width and height\n    const nW = angle === 180 ? w : h;\n    const nH = angle === 180 ? h : w;\n    const dstBuffer = Buffer.alloc(image.bitmap.data.length);\n    const srcIdxFunction = createIdxTranslationFunction(w);\n    const dstIdxFunction = createIdxTranslationFunction(nW);\n    for (let x = 0; x < w; x++) {\n        for (let y = 0; y < h; y++) {\n            const srcIdx = srcIdxFunction(x, y);\n            const pixelRGBA = image.bitmap.data.readUInt32BE(srcIdx);\n            let dstIdx;\n            switch (angle) {\n                case 90:\n                    dstIdx = dstIdxFunction(y, w - x - 1);\n                    break;\n                case -90:\n                    dstIdx = dstIdxFunction(h - y - 1, x);\n                    break;\n                case 180:\n                    dstIdx = dstIdxFunction(w - x - 1, h - y - 1);\n                    break;\n                default:\n                    throw new Error(\"Unsupported matrix rotation angle\");\n            }\n            dstBuffer.writeUInt32BE(pixelRGBA, dstIdx);\n        }\n    }\n    image.bitmap.data = dstBuffer;\n    image.bitmap.width = nW;\n    image.bitmap.height = nH;\n}\nfunction createTranslationFunction(deltaX, deltaY) {\n    return function (x, y) {\n        return {\n            x: x + deltaX,\n            y: y + deltaY,\n        };\n    };\n}\n/**\n * Rotates an image counter-clockwise by an arbitrary number of degrees. NB: 'this' must be a Jimp object.\n * @param {number} deg the number of degrees to rotate the image by\n */\nfunction advancedRotate(image, deg, mode) {\n    const rad = (deg * Math.PI) / 180;\n    const cosine = Math.cos(rad);\n    const sine = Math.sin(rad);\n    // the final width and height will change if resize == true\n    let w = image.bitmap.width;\n    let h = image.bitmap.height;\n    if (mode === true || typeof mode === \"string\") {\n        // resize the image to it maximum dimension and blit the existing image\n        // onto the center so that when it is rotated the image is kept in bounds\n        // http://stackoverflow.com/questions/3231176/how-to-get-size-of-a-rotated-rectangle\n        // Plus 1 border pixel to ensure to show all rotated result for some cases.\n        w =\n            Math.ceil(Math.abs(image.bitmap.width * cosine) +\n                Math.abs(image.bitmap.height * sine)) + 1;\n        h =\n            Math.ceil(Math.abs(image.bitmap.width * sine) +\n                Math.abs(image.bitmap.height * cosine)) + 1;\n        // Ensure destination to have even size to a better result.\n        if (w % 2 !== 0) {\n            w++;\n        }\n        if (h % 2 !== 0) {\n            h++;\n        }\n        const c = (0, utils_1.clone)(image);\n        image.scan((_, __, idx) => {\n            image.bitmap.data.writeUInt32BE(image.background, idx);\n        });\n        const max = Math.max(w, h, image.bitmap.width, image.bitmap.height);\n        image = plugin_resize_1.methods.resize(image, {\n            h: max,\n            w: max,\n            mode: mode === true ? undefined : mode,\n        });\n        image = (0, core_1.composite)(image, c, image.bitmap.width / 2 - c.bitmap.width / 2, image.bitmap.height / 2 - c.bitmap.height / 2);\n    }\n    const bW = image.bitmap.width;\n    const bH = image.bitmap.height;\n    const dstBuffer = Buffer.alloc(image.bitmap.data.length);\n    const translate2Cartesian = createTranslationFunction(-(bW / 2), -(bH / 2));\n    const translate2Screen = createTranslationFunction(bW / 2 + 0.5, bH / 2 + 0.5);\n    for (let y = 1; y <= bH; y++) {\n        for (let x = 1; x <= bW; x++) {\n            const cartesian = translate2Cartesian(x, y);\n            const source = translate2Screen(cosine * cartesian.x - sine * cartesian.y, cosine * cartesian.y + sine * cartesian.x);\n            const dstIdx = (bW * (y - 1) + x - 1) << 2;\n            if (source.x >= 0 && source.x < bW && source.y >= 0 && source.y < bH) {\n                const srcIdx = ((bW * (source.y | 0) + source.x) | 0) << 2;\n                const pixelRGBA = image.bitmap.data.readUInt32BE(srcIdx);\n                dstBuffer.writeUInt32BE(pixelRGBA, dstIdx);\n            }\n            else {\n                // reset off-image pixels\n                dstBuffer.writeUInt32BE(image.background, dstIdx);\n            }\n        }\n    }\n    image.bitmap.data = dstBuffer;\n    if (mode === true || typeof mode === \"string\") {\n        // now crop the image to the final size\n        const x = Math.max(bW / 2 - w / 2, 0);\n        const y = Math.max(bH / 2 - h / 2, 0);\n        image = plugin_crop_1.methods.crop(image, { x, y, w, h });\n    }\n}\nexports.methods = {\n    /**\n     * Rotates the image counter-clockwise by a number of degrees. By default the width and height of the image will be resized appropriately.\n     * @example\n     * ```ts\n     * import { Jimp } from \"jimp\";\n     *\n     * const image = await Jimp.read(\"test/image.png\");\n     *\n     * image.rotate(90);\n     * ```\n     */\n    rotate(image, options) {\n        const parsed = RotateOptionsSchema.parse(options);\n        const actualOptions = typeof parsed === \"number\" ? { deg: parsed } : parsed;\n        const { mode = true } = actualOptions;\n        let { deg } = actualOptions;\n        // No need to do extra rotation\n        deg %= 360;\n        // no rotation for 0, 360, -360, 720, -720, ...\n        if (deg % 360 === 0) {\n            return image;\n        }\n        // use matrixRotate if the angle is a multiple of 90 degrees (eg: 180 or -90) and resize is allowed or not needed.\n        const matrixRotateAllowed = deg % 90 === 0 &&\n            (mode || image.bitmap.width === image.bitmap.height || deg % 180 === 0);\n        if (matrixRotateAllowed) {\n            matrixRotate(image, deg);\n        }\n        else {\n            advancedRotate(image, deg, mode);\n        }\n        return image;\n    },\n};\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BqaW1wK3BsdWdpbi1yb3RhdGVAMS42LjAvbm9kZV9tb2R1bGVzL0BqaW1wL3BsdWdpbi1yb3RhdGUvZGlzdC9jb21tb25qcy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxlQUFlO0FBQ2Ysd0JBQXdCLG1CQUFPLENBQUMsNklBQXFCO0FBQ3JELGdCQUFnQixtQkFBTyxDQUFDLHFIQUFhO0FBQ3JDLGVBQWUsbUJBQU8sQ0FBQyxrSEFBWTtBQUNuQyxzQkFBc0IsbUJBQU8sQ0FBQyx1SUFBbUI7QUFDakQsY0FBYyxtQkFBTyxDQUFDLG9GQUFLO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0Isd0JBQXdCLE9BQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCLHdCQUF3QixTQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELFlBQVk7QUFDaEU7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsY0FBYztBQUMzRSxnQkFBZ0IsY0FBYztBQUM5QixjQUFjLE1BQU07QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL21pa2V3ZXN0aGFkL0Rlc2t0b3AvUmVwb3Mvc3BvcmFkaWMtbGFicy10aWxlLWV4dHJ1ZGVyL25vZGVfbW9kdWxlcy8ucG5wbS9AamltcCtwbHVnaW4tcm90YXRlQDEuNi4wL25vZGVfbW9kdWxlcy9AamltcC9wbHVnaW4tcm90YXRlL2Rpc3QvY29tbW9uanMvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLm1ldGhvZHMgPSB2b2lkIDA7XG5jb25zdCBwbHVnaW5fcmVzaXplXzEgPSByZXF1aXJlKFwiQGppbXAvcGx1Z2luLXJlc2l6ZVwiKTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiQGppbXAvdXRpbHNcIik7XG5jb25zdCBjb3JlXzEgPSByZXF1aXJlKFwiQGppbXAvY29yZVwiKTtcbmNvbnN0IHBsdWdpbl9jcm9wXzEgPSByZXF1aXJlKFwiQGppbXAvcGx1Z2luLWNyb3BcIik7XG5jb25zdCB6b2RfMSA9IHJlcXVpcmUoXCJ6b2RcIik7XG5jb25zdCBSb3RhdGVPcHRpb25zU2NoZW1hID0gem9kXzEuei51bmlvbihbXG4gICAgem9kXzEuei5udW1iZXIoKSxcbiAgICB6b2RfMS56Lm9iamVjdCh7XG4gICAgICAgIC8qKiB0aGUgbnVtYmVyIG9mIGRlZ3JlZXMgdG8gcm90YXRlIHRoZSBpbWFnZSBieSAqL1xuICAgICAgICBkZWc6IHpvZF8xLnoubnVtYmVyKCksXG4gICAgICAgIC8qKiByZXNpemUgbW9kZSBvciBhIGJvb2xlYW4sIGlmIGZhbHNlIHRoZW4gdGhlIHdpZHRoIGFuZCBoZWlnaHQgb2YgdGhlIGltYWdlIHdpbGwgbm90IGJlIGNoYW5nZWQgKi9cbiAgICAgICAgbW9kZTogem9kXzEuei51bmlvbihbem9kXzEuei5ib29sZWFuKCksIHpvZF8xLnoubmF0aXZlRW51bShwbHVnaW5fcmVzaXplXzEuUmVzaXplU3RyYXRlZ3kpXSkub3B0aW9uYWwoKSxcbiAgICB9KSxcbl0pO1xuLyoqIGZ1bmN0aW9uIHRvIHRyYW5zbGF0ZSB0aGUgeCwgeSBjb29yZGluYXRlIHRvIHRoZSBpbmRleCBvZiB0aGUgcGl4ZWwgaW4gdGhlIGJ1ZmZlciAqL1xuZnVuY3Rpb24gY3JlYXRlSWR4VHJhbnNsYXRpb25GdW5jdGlvbih3KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgIHJldHVybiAoeSAqIHcgKyB4KSA8PCAyO1xuICAgIH07XG59XG4vKipcbiAqIFJvdGF0ZXMgYW4gaW1hZ2UgY291bnRlci1jbG9ja3dpc2UgYnkgbXVsdGlwbGUgb2YgOTAgZGVncmVlcy4gTkI6ICd0aGlzJyBtdXN0IGJlIGEgSmltcCBvYmplY3QuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBpcyBiYXNlZCBvbiBtYXRyaXggcm90YXRpb24uIENoZWNrIHRoaXMgdG8gZ2V0IGFuIGluaXRpYWwgaWRlYSBob3cgaXQgd29ya3M6IGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS84NjY0ODc5LzEwNTYxOTA5XG4gKlxuICogQHBhcmFtIGRlZyB0aGUgbnVtYmVyIG9mIGRlZ3JlZXMgdG8gcm90YXRlIHRoZSBpbWFnZSBieSwgaXQgc2hvdWxkIGJlIGEgbXVsdGlwbGUgb2YgOTBcbiAqL1xuZnVuY3Rpb24gbWF0cml4Um90YXRlKGltYWdlLCBkZWcpIHtcbiAgICBpZiAoTWF0aC5hYnMoZGVnKSAlIDkwICE9PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIG1hdHJpeCByb3RhdGlvbiBkZWdyZWVcIik7XG4gICAgfVxuICAgIGNvbnN0IHcgPSBpbWFnZS5iaXRtYXAud2lkdGg7XG4gICAgY29uc3QgaCA9IGltYWdlLmJpdG1hcC5oZWlnaHQ7XG4gICAgLy8gZGVjaWRlIHdoaWNoIHJvdGF0aW9uIGFuZ2xlIHRvIHVzZVxuICAgIGxldCBhbmdsZTtcbiAgICBzd2l0Y2ggKGRlZykge1xuICAgICAgICAvLyA5MCBkZWdyZWUgJiAtMjcwIGRlZ3JlZSBhcmUgc2FtZVxuICAgICAgICBjYXNlIDkwOlxuICAgICAgICBjYXNlIC0yNzA6XG4gICAgICAgICAgICBhbmdsZSA9IDkwO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTgwOlxuICAgICAgICBjYXNlIC0xODA6XG4gICAgICAgICAgICBhbmdsZSA9IDE4MDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI3MDpcbiAgICAgICAgY2FzZSAtOTA6XG4gICAgICAgICAgICBhbmdsZSA9IC05MDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgbWF0cml4IHJvdGF0aW9uIGRlZ3JlZVwiKTtcbiAgICB9XG4gICAgLy8gQWZ0ZXIgdGhpcyBzd2l0Y2ggYmxvY2ssIGFuZ2xlIHdpbGwgYmUgOTAsIDE4MCBvciAtOTBcbiAgICAvLyBjYWxjdWxhdGUgdGhlIG5ldyB3aWR0aCBhbmQgaGVpZ2h0XG4gICAgY29uc3QgblcgPSBhbmdsZSA9PT0gMTgwID8gdyA6IGg7XG4gICAgY29uc3QgbkggPSBhbmdsZSA9PT0gMTgwID8gaCA6IHc7XG4gICAgY29uc3QgZHN0QnVmZmVyID0gQnVmZmVyLmFsbG9jKGltYWdlLmJpdG1hcC5kYXRhLmxlbmd0aCk7XG4gICAgY29uc3Qgc3JjSWR4RnVuY3Rpb24gPSBjcmVhdGVJZHhUcmFuc2xhdGlvbkZ1bmN0aW9uKHcpO1xuICAgIGNvbnN0IGRzdElkeEZ1bmN0aW9uID0gY3JlYXRlSWR4VHJhbnNsYXRpb25GdW5jdGlvbihuVyk7XG4gICAgZm9yIChsZXQgeCA9IDA7IHggPCB3OyB4KyspIHtcbiAgICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCBoOyB5KyspIHtcbiAgICAgICAgICAgIGNvbnN0IHNyY0lkeCA9IHNyY0lkeEZ1bmN0aW9uKHgsIHkpO1xuICAgICAgICAgICAgY29uc3QgcGl4ZWxSR0JBID0gaW1hZ2UuYml0bWFwLmRhdGEucmVhZFVJbnQzMkJFKHNyY0lkeCk7XG4gICAgICAgICAgICBsZXQgZHN0SWR4O1xuICAgICAgICAgICAgc3dpdGNoIChhbmdsZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgOTA6XG4gICAgICAgICAgICAgICAgICAgIGRzdElkeCA9IGRzdElkeEZ1bmN0aW9uKHksIHcgLSB4IC0gMSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLTkwOlxuICAgICAgICAgICAgICAgICAgICBkc3RJZHggPSBkc3RJZHhGdW5jdGlvbihoIC0geSAtIDEsIHgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDE4MDpcbiAgICAgICAgICAgICAgICAgICAgZHN0SWR4ID0gZHN0SWR4RnVuY3Rpb24odyAtIHggLSAxLCBoIC0geSAtIDEpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBtYXRyaXggcm90YXRpb24gYW5nbGVcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkc3RCdWZmZXIud3JpdGVVSW50MzJCRShwaXhlbFJHQkEsIGRzdElkeCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaW1hZ2UuYml0bWFwLmRhdGEgPSBkc3RCdWZmZXI7XG4gICAgaW1hZ2UuYml0bWFwLndpZHRoID0gblc7XG4gICAgaW1hZ2UuYml0bWFwLmhlaWdodCA9IG5IO1xufVxuZnVuY3Rpb24gY3JlYXRlVHJhbnNsYXRpb25GdW5jdGlvbihkZWx0YVgsIGRlbHRhWSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDogeCArIGRlbHRhWCxcbiAgICAgICAgICAgIHk6IHkgKyBkZWx0YVksXG4gICAgICAgIH07XG4gICAgfTtcbn1cbi8qKlxuICogUm90YXRlcyBhbiBpbWFnZSBjb3VudGVyLWNsb2Nrd2lzZSBieSBhbiBhcmJpdHJhcnkgbnVtYmVyIG9mIGRlZ3JlZXMuIE5COiAndGhpcycgbXVzdCBiZSBhIEppbXAgb2JqZWN0LlxuICogQHBhcmFtIHtudW1iZXJ9IGRlZyB0aGUgbnVtYmVyIG9mIGRlZ3JlZXMgdG8gcm90YXRlIHRoZSBpbWFnZSBieVxuICovXG5mdW5jdGlvbiBhZHZhbmNlZFJvdGF0ZShpbWFnZSwgZGVnLCBtb2RlKSB7XG4gICAgY29uc3QgcmFkID0gKGRlZyAqIE1hdGguUEkpIC8gMTgwO1xuICAgIGNvbnN0IGNvc2luZSA9IE1hdGguY29zKHJhZCk7XG4gICAgY29uc3Qgc2luZSA9IE1hdGguc2luKHJhZCk7XG4gICAgLy8gdGhlIGZpbmFsIHdpZHRoIGFuZCBoZWlnaHQgd2lsbCBjaGFuZ2UgaWYgcmVzaXplID09IHRydWVcbiAgICBsZXQgdyA9IGltYWdlLmJpdG1hcC53aWR0aDtcbiAgICBsZXQgaCA9IGltYWdlLmJpdG1hcC5oZWlnaHQ7XG4gICAgaWYgKG1vZGUgPT09IHRydWUgfHwgdHlwZW9mIG1vZGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgLy8gcmVzaXplIHRoZSBpbWFnZSB0byBpdCBtYXhpbXVtIGRpbWVuc2lvbiBhbmQgYmxpdCB0aGUgZXhpc3RpbmcgaW1hZ2VcbiAgICAgICAgLy8gb250byB0aGUgY2VudGVyIHNvIHRoYXQgd2hlbiBpdCBpcyByb3RhdGVkIHRoZSBpbWFnZSBpcyBrZXB0IGluIGJvdW5kc1xuICAgICAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzMyMzExNzYvaG93LXRvLWdldC1zaXplLW9mLWEtcm90YXRlZC1yZWN0YW5nbGVcbiAgICAgICAgLy8gUGx1cyAxIGJvcmRlciBwaXhlbCB0byBlbnN1cmUgdG8gc2hvdyBhbGwgcm90YXRlZCByZXN1bHQgZm9yIHNvbWUgY2FzZXMuXG4gICAgICAgIHcgPVxuICAgICAgICAgICAgTWF0aC5jZWlsKE1hdGguYWJzKGltYWdlLmJpdG1hcC53aWR0aCAqIGNvc2luZSkgK1xuICAgICAgICAgICAgICAgIE1hdGguYWJzKGltYWdlLmJpdG1hcC5oZWlnaHQgKiBzaW5lKSkgKyAxO1xuICAgICAgICBoID1cbiAgICAgICAgICAgIE1hdGguY2VpbChNYXRoLmFicyhpbWFnZS5iaXRtYXAud2lkdGggKiBzaW5lKSArXG4gICAgICAgICAgICAgICAgTWF0aC5hYnMoaW1hZ2UuYml0bWFwLmhlaWdodCAqIGNvc2luZSkpICsgMTtcbiAgICAgICAgLy8gRW5zdXJlIGRlc3RpbmF0aW9uIHRvIGhhdmUgZXZlbiBzaXplIHRvIGEgYmV0dGVyIHJlc3VsdC5cbiAgICAgICAgaWYgKHcgJSAyICE9PSAwKSB7XG4gICAgICAgICAgICB3Kys7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGggJSAyICE9PSAwKSB7XG4gICAgICAgICAgICBoKys7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYyA9ICgwLCB1dGlsc18xLmNsb25lKShpbWFnZSk7XG4gICAgICAgIGltYWdlLnNjYW4oKF8sIF9fLCBpZHgpID0+IHtcbiAgICAgICAgICAgIGltYWdlLmJpdG1hcC5kYXRhLndyaXRlVUludDMyQkUoaW1hZ2UuYmFja2dyb3VuZCwgaWR4KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IG1heCA9IE1hdGgubWF4KHcsIGgsIGltYWdlLmJpdG1hcC53aWR0aCwgaW1hZ2UuYml0bWFwLmhlaWdodCk7XG4gICAgICAgIGltYWdlID0gcGx1Z2luX3Jlc2l6ZV8xLm1ldGhvZHMucmVzaXplKGltYWdlLCB7XG4gICAgICAgICAgICBoOiBtYXgsXG4gICAgICAgICAgICB3OiBtYXgsXG4gICAgICAgICAgICBtb2RlOiBtb2RlID09PSB0cnVlID8gdW5kZWZpbmVkIDogbW9kZSxcbiAgICAgICAgfSk7XG4gICAgICAgIGltYWdlID0gKDAsIGNvcmVfMS5jb21wb3NpdGUpKGltYWdlLCBjLCBpbWFnZS5iaXRtYXAud2lkdGggLyAyIC0gYy5iaXRtYXAud2lkdGggLyAyLCBpbWFnZS5iaXRtYXAuaGVpZ2h0IC8gMiAtIGMuYml0bWFwLmhlaWdodCAvIDIpO1xuICAgIH1cbiAgICBjb25zdCBiVyA9IGltYWdlLmJpdG1hcC53aWR0aDtcbiAgICBjb25zdCBiSCA9IGltYWdlLmJpdG1hcC5oZWlnaHQ7XG4gICAgY29uc3QgZHN0QnVmZmVyID0gQnVmZmVyLmFsbG9jKGltYWdlLmJpdG1hcC5kYXRhLmxlbmd0aCk7XG4gICAgY29uc3QgdHJhbnNsYXRlMkNhcnRlc2lhbiA9IGNyZWF0ZVRyYW5zbGF0aW9uRnVuY3Rpb24oLShiVyAvIDIpLCAtKGJIIC8gMikpO1xuICAgIGNvbnN0IHRyYW5zbGF0ZTJTY3JlZW4gPSBjcmVhdGVUcmFuc2xhdGlvbkZ1bmN0aW9uKGJXIC8gMiArIDAuNSwgYkggLyAyICsgMC41KTtcbiAgICBmb3IgKGxldCB5ID0gMTsgeSA8PSBiSDsgeSsrKSB7XG4gICAgICAgIGZvciAobGV0IHggPSAxOyB4IDw9IGJXOyB4KyspIHtcbiAgICAgICAgICAgIGNvbnN0IGNhcnRlc2lhbiA9IHRyYW5zbGF0ZTJDYXJ0ZXNpYW4oeCwgeSk7XG4gICAgICAgICAgICBjb25zdCBzb3VyY2UgPSB0cmFuc2xhdGUyU2NyZWVuKGNvc2luZSAqIGNhcnRlc2lhbi54IC0gc2luZSAqIGNhcnRlc2lhbi55LCBjb3NpbmUgKiBjYXJ0ZXNpYW4ueSArIHNpbmUgKiBjYXJ0ZXNpYW4ueCk7XG4gICAgICAgICAgICBjb25zdCBkc3RJZHggPSAoYlcgKiAoeSAtIDEpICsgeCAtIDEpIDw8IDI7XG4gICAgICAgICAgICBpZiAoc291cmNlLnggPj0gMCAmJiBzb3VyY2UueCA8IGJXICYmIHNvdXJjZS55ID49IDAgJiYgc291cmNlLnkgPCBiSCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNyY0lkeCA9ICgoYlcgKiAoc291cmNlLnkgfCAwKSArIHNvdXJjZS54KSB8IDApIDw8IDI7XG4gICAgICAgICAgICAgICAgY29uc3QgcGl4ZWxSR0JBID0gaW1hZ2UuYml0bWFwLmRhdGEucmVhZFVJbnQzMkJFKHNyY0lkeCk7XG4gICAgICAgICAgICAgICAgZHN0QnVmZmVyLndyaXRlVUludDMyQkUocGl4ZWxSR0JBLCBkc3RJZHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gcmVzZXQgb2ZmLWltYWdlIHBpeGVsc1xuICAgICAgICAgICAgICAgIGRzdEJ1ZmZlci53cml0ZVVJbnQzMkJFKGltYWdlLmJhY2tncm91bmQsIGRzdElkeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaW1hZ2UuYml0bWFwLmRhdGEgPSBkc3RCdWZmZXI7XG4gICAgaWYgKG1vZGUgPT09IHRydWUgfHwgdHlwZW9mIG1vZGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgLy8gbm93IGNyb3AgdGhlIGltYWdlIHRvIHRoZSBmaW5hbCBzaXplXG4gICAgICAgIGNvbnN0IHggPSBNYXRoLm1heChiVyAvIDIgLSB3IC8gMiwgMCk7XG4gICAgICAgIGNvbnN0IHkgPSBNYXRoLm1heChiSCAvIDIgLSBoIC8gMiwgMCk7XG4gICAgICAgIGltYWdlID0gcGx1Z2luX2Nyb3BfMS5tZXRob2RzLmNyb3AoaW1hZ2UsIHsgeCwgeSwgdywgaCB9KTtcbiAgICB9XG59XG5leHBvcnRzLm1ldGhvZHMgPSB7XG4gICAgLyoqXG4gICAgICogUm90YXRlcyB0aGUgaW1hZ2UgY291bnRlci1jbG9ja3dpc2UgYnkgYSBudW1iZXIgb2YgZGVncmVlcy4gQnkgZGVmYXVsdCB0aGUgd2lkdGggYW5kIGhlaWdodCBvZiB0aGUgaW1hZ2Ugd2lsbCBiZSByZXNpemVkIGFwcHJvcHJpYXRlbHkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIGltcG9ydCB7IEppbXAgfSBmcm9tIFwiamltcFwiO1xuICAgICAqXG4gICAgICogY29uc3QgaW1hZ2UgPSBhd2FpdCBKaW1wLnJlYWQoXCJ0ZXN0L2ltYWdlLnBuZ1wiKTtcbiAgICAgKlxuICAgICAqIGltYWdlLnJvdGF0ZSg5MCk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgcm90YXRlKGltYWdlLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZCA9IFJvdGF0ZU9wdGlvbnNTY2hlbWEucGFyc2Uob3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IGFjdHVhbE9wdGlvbnMgPSB0eXBlb2YgcGFyc2VkID09PSBcIm51bWJlclwiID8geyBkZWc6IHBhcnNlZCB9IDogcGFyc2VkO1xuICAgICAgICBjb25zdCB7IG1vZGUgPSB0cnVlIH0gPSBhY3R1YWxPcHRpb25zO1xuICAgICAgICBsZXQgeyBkZWcgfSA9IGFjdHVhbE9wdGlvbnM7XG4gICAgICAgIC8vIE5vIG5lZWQgdG8gZG8gZXh0cmEgcm90YXRpb25cbiAgICAgICAgZGVnICU9IDM2MDtcbiAgICAgICAgLy8gbm8gcm90YXRpb24gZm9yIDAsIDM2MCwgLTM2MCwgNzIwLCAtNzIwLCAuLi5cbiAgICAgICAgaWYgKGRlZyAlIDM2MCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGltYWdlO1xuICAgICAgICB9XG4gICAgICAgIC8vIHVzZSBtYXRyaXhSb3RhdGUgaWYgdGhlIGFuZ2xlIGlzIGEgbXVsdGlwbGUgb2YgOTAgZGVncmVlcyAoZWc6IDE4MCBvciAtOTApIGFuZCByZXNpemUgaXMgYWxsb3dlZCBvciBub3QgbmVlZGVkLlxuICAgICAgICBjb25zdCBtYXRyaXhSb3RhdGVBbGxvd2VkID0gZGVnICUgOTAgPT09IDAgJiZcbiAgICAgICAgICAgIChtb2RlIHx8IGltYWdlLmJpdG1hcC53aWR0aCA9PT0gaW1hZ2UuYml0bWFwLmhlaWdodCB8fCBkZWcgJSAxODAgPT09IDApO1xuICAgICAgICBpZiAobWF0cml4Um90YXRlQWxsb3dlZCkge1xuICAgICAgICAgICAgbWF0cml4Um90YXRlKGltYWdlLCBkZWcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYWR2YW5jZWRSb3RhdGUoaW1hZ2UsIGRlZywgbW9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGltYWdlO1xuICAgIH0sXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@jimp+plugin-rotate@1.6.0/node_modules/@jimp/plugin-rotate/dist/commonjs/index.js\n");

/***/ })

};
;