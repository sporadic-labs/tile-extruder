/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/image-q@4.0.0";
exports.ids = ["vendor-chunks/image-q@4.0.0"];
exports.modules = {

/***/ "(ssr)/../../node_modules/.pnpm/image-q@4.0.0/node_modules/image-q/dist/cjs/image-q.cjs":
/*!****************************************************************************************!*\
  !*** ../../node_modules/.pnpm/image-q@4.0.0/node_modules/image-q/dist/cjs/image-q.cjs ***!
  \****************************************************************************************/
/***/ ((module) => {

eval("var __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __reExport = (target, module2, copyDefault, desc) => {\n  if (module2 && typeof module2 === \"object\" || typeof module2 === \"function\") {\n    for (let key of __getOwnPropNames(module2))\n      if (!__hasOwnProp.call(target, key) && (copyDefault || key !== \"default\"))\n        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });\n  }\n  return target;\n};\nvar __toCommonJS = /* @__PURE__ */ ((cache) => {\n  return (module2, temp) => {\n    return cache && cache.get(module2) || (temp = __reExport(__markAsModule({}), module2, 1), cache && cache.set(module2, temp), temp);\n  };\n})(typeof WeakMap !== \"undefined\" ? /* @__PURE__ */ new WeakMap() : 0);\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\n\n// src/index.ts\nvar src_exports = {};\n__export(src_exports, {\n  applyPalette: () => applyPalette,\n  applyPaletteSync: () => applyPaletteSync,\n  buildPalette: () => buildPalette,\n  buildPaletteSync: () => buildPaletteSync,\n  constants: () => constants_exports,\n  conversion: () => conversion_exports,\n  distance: () => distance_exports,\n  image: () => image_exports,\n  palette: () => palette_exports,\n  quality: () => quality_exports,\n  utils: () => utils_exports\n});\n\n// src/constants/index.ts\nvar constants_exports = {};\n__export(constants_exports, {\n  bt709: () => bt709_exports\n});\n\n// src/constants/bt709.ts\nvar bt709_exports = {};\n__export(bt709_exports, {\n  Y: () => Y,\n  x: () => x,\n  y: () => y\n});\nvar Y = /* @__PURE__ */ ((Y2) => {\n  Y2[Y2[\"RED\"] = 0.2126] = \"RED\";\n  Y2[Y2[\"GREEN\"] = 0.7152] = \"GREEN\";\n  Y2[Y2[\"BLUE\"] = 0.0722] = \"BLUE\";\n  Y2[Y2[\"WHITE\"] = 1] = \"WHITE\";\n  return Y2;\n})(Y || {});\nvar x = /* @__PURE__ */ ((x2) => {\n  x2[x2[\"RED\"] = 0.64] = \"RED\";\n  x2[x2[\"GREEN\"] = 0.3] = \"GREEN\";\n  x2[x2[\"BLUE\"] = 0.15] = \"BLUE\";\n  x2[x2[\"WHITE\"] = 0.3127] = \"WHITE\";\n  return x2;\n})(x || {});\nvar y = /* @__PURE__ */ ((y2) => {\n  y2[y2[\"RED\"] = 0.33] = \"RED\";\n  y2[y2[\"GREEN\"] = 0.6] = \"GREEN\";\n  y2[y2[\"BLUE\"] = 0.06] = \"BLUE\";\n  y2[y2[\"WHITE\"] = 0.329] = \"WHITE\";\n  return y2;\n})(y || {});\n\n// src/conversion/index.ts\nvar conversion_exports = {};\n__export(conversion_exports, {\n  lab2rgb: () => lab2rgb,\n  lab2xyz: () => lab2xyz,\n  rgb2hsl: () => rgb2hsl,\n  rgb2lab: () => rgb2lab,\n  rgb2xyz: () => rgb2xyz,\n  xyz2lab: () => xyz2lab,\n  xyz2rgb: () => xyz2rgb\n});\n\n// src/conversion/rgb2xyz.ts\nfunction correctGamma(n) {\n  return n > 0.04045 ? ((n + 0.055) / 1.055) ** 2.4 : n / 12.92;\n}\nfunction rgb2xyz(r, g, b) {\n  r = correctGamma(r / 255);\n  g = correctGamma(g / 255);\n  b = correctGamma(b / 255);\n  return {\n    x: r * 0.4124 + g * 0.3576 + b * 0.1805,\n    y: r * 0.2126 + g * 0.7152 + b * 0.0722,\n    z: r * 0.0193 + g * 0.1192 + b * 0.9505\n  };\n}\n\n// src/utils/arithmetic.ts\nvar arithmetic_exports = {};\n__export(arithmetic_exports, {\n  degrees2radians: () => degrees2radians,\n  inRange0to255: () => inRange0to255,\n  inRange0to255Rounded: () => inRange0to255Rounded,\n  intInRange: () => intInRange,\n  max3: () => max3,\n  min3: () => min3,\n  stableSort: () => stableSort\n});\nfunction degrees2radians(n) {\n  return n * (Math.PI / 180);\n}\nfunction max3(a, b, c) {\n  let m = a;\n  if (m < b)\n    m = b;\n  if (m < c)\n    m = c;\n  return m;\n}\nfunction min3(a, b, c) {\n  let m = a;\n  if (m > b)\n    m = b;\n  if (m > c)\n    m = c;\n  return m;\n}\nfunction intInRange(value, low, high) {\n  if (value > high)\n    value = high;\n  if (value < low)\n    value = low;\n  return value | 0;\n}\nfunction inRange0to255Rounded(n) {\n  n = Math.round(n);\n  if (n > 255)\n    n = 255;\n  else if (n < 0)\n    n = 0;\n  return n;\n}\nfunction inRange0to255(n) {\n  if (n > 255)\n    n = 255;\n  else if (n < 0)\n    n = 0;\n  return n;\n}\nfunction stableSort(arrayToSort, callback) {\n  const type = typeof arrayToSort[0];\n  let sorted;\n  if (type === \"number\" || type === \"string\") {\n    const ord = /* @__PURE__ */ Object.create(null);\n    for (let i = 0, l = arrayToSort.length; i < l; i++) {\n      const val = arrayToSort[i];\n      if (ord[val] || ord[val] === 0)\n        continue;\n      ord[val] = i;\n    }\n    sorted = arrayToSort.sort((a, b) => callback(a, b) || ord[a] - ord[b]);\n  } else {\n    const ord2 = arrayToSort.slice(0);\n    sorted = arrayToSort.sort((a, b) => callback(a, b) || ord2.indexOf(a) - ord2.indexOf(b));\n  }\n  return sorted;\n}\n\n// src/conversion/rgb2hsl.ts\nfunction rgb2hsl(r, g, b) {\n  const min = min3(r, g, b);\n  const max = max3(r, g, b);\n  const delta = max - min;\n  const l = (min + max) / 510;\n  let s = 0;\n  if (l > 0 && l < 1)\n    s = delta / (l < 0.5 ? max + min : 510 - max - min);\n  let h = 0;\n  if (delta > 0) {\n    if (max === r) {\n      h = (g - b) / delta;\n    } else if (max === g) {\n      h = 2 + (b - r) / delta;\n    } else {\n      h = 4 + (r - g) / delta;\n    }\n    h *= 60;\n    if (h < 0)\n      h += 360;\n  }\n  return { h, s, l };\n}\n\n// src/conversion/xyz2lab.ts\nvar refX = 0.95047;\nvar refY = 1;\nvar refZ = 1.08883;\nfunction pivot(n) {\n  return n > 8856e-6 ? n ** (1 / 3) : 7.787 * n + 16 / 116;\n}\nfunction xyz2lab(x2, y2, z) {\n  x2 = pivot(x2 / refX);\n  y2 = pivot(y2 / refY);\n  z = pivot(z / refZ);\n  if (116 * y2 - 16 < 0)\n    throw new Error(\"xxx\");\n  return {\n    L: Math.max(0, 116 * y2 - 16),\n    a: 500 * (x2 - y2),\n    b: 200 * (y2 - z)\n  };\n}\n\n// src/conversion/rgb2lab.ts\nfunction rgb2lab(r, g, b) {\n  const xyz = rgb2xyz(r, g, b);\n  return xyz2lab(xyz.x, xyz.y, xyz.z);\n}\n\n// src/conversion/lab2xyz.ts\nvar refX2 = 0.95047;\nvar refY2 = 1;\nvar refZ2 = 1.08883;\nfunction pivot2(n) {\n  return n > 0.206893034 ? n ** 3 : (n - 16 / 116) / 7.787;\n}\nfunction lab2xyz(L, a, b) {\n  const y2 = (L + 16) / 116;\n  const x2 = a / 500 + y2;\n  const z = y2 - b / 200;\n  return {\n    x: refX2 * pivot2(x2),\n    y: refY2 * pivot2(y2),\n    z: refZ2 * pivot2(z)\n  };\n}\n\n// src/conversion/xyz2rgb.ts\nfunction correctGamma2(n) {\n  return n > 31308e-7 ? 1.055 * n ** (1 / 2.4) - 0.055 : 12.92 * n;\n}\nfunction xyz2rgb(x2, y2, z) {\n  const r = correctGamma2(x2 * 3.2406 + y2 * -1.5372 + z * -0.4986);\n  const g = correctGamma2(x2 * -0.9689 + y2 * 1.8758 + z * 0.0415);\n  const b = correctGamma2(x2 * 0.0557 + y2 * -0.204 + z * 1.057);\n  return {\n    r: inRange0to255Rounded(r * 255),\n    g: inRange0to255Rounded(g * 255),\n    b: inRange0to255Rounded(b * 255)\n  };\n}\n\n// src/conversion/lab2rgb.ts\nfunction lab2rgb(L, a, b) {\n  const xyz = lab2xyz(L, a, b);\n  return xyz2rgb(xyz.x, xyz.y, xyz.z);\n}\n\n// src/distance/index.ts\nvar distance_exports = {};\n__export(distance_exports, {\n  AbstractDistanceCalculator: () => AbstractDistanceCalculator,\n  AbstractEuclidean: () => AbstractEuclidean,\n  AbstractManhattan: () => AbstractManhattan,\n  CIE94GraphicArts: () => CIE94GraphicArts,\n  CIE94Textiles: () => CIE94Textiles,\n  CIEDE2000: () => CIEDE2000,\n  CMetric: () => CMetric,\n  Euclidean: () => Euclidean,\n  EuclideanBT709: () => EuclideanBT709,\n  EuclideanBT709NoAlpha: () => EuclideanBT709NoAlpha,\n  Manhattan: () => Manhattan,\n  ManhattanBT709: () => ManhattanBT709,\n  ManhattanNommyde: () => ManhattanNommyde,\n  PNGQuant: () => PNGQuant\n});\n\n// src/distance/distanceCalculator.ts\nvar AbstractDistanceCalculator = class {\n  constructor() {\n    __publicField(this, \"_maxDistance\");\n    __publicField(this, \"_whitePoint\");\n    this._setDefaults();\n    this.setWhitePoint(255, 255, 255, 255);\n  }\n  setWhitePoint(r, g, b, a) {\n    this._whitePoint = {\n      r: r > 0 ? 255 / r : 0,\n      g: g > 0 ? 255 / g : 0,\n      b: b > 0 ? 255 / b : 0,\n      a: a > 0 ? 255 / a : 0\n    };\n    this._maxDistance = this.calculateRaw(r, g, b, a, 0, 0, 0, 0);\n  }\n  calculateNormalized(colorA, colorB) {\n    return this.calculateRaw(colorA.r, colorA.g, colorA.b, colorA.a, colorB.r, colorB.g, colorB.b, colorB.a) / this._maxDistance;\n  }\n};\n\n// src/distance/cie94.ts\nvar AbstractCIE94 = class extends AbstractDistanceCalculator {\n  calculateRaw(r1, g1, b1, a1, r2, g2, b2, a2) {\n    const lab1 = rgb2lab(inRange0to255(r1 * this._whitePoint.r), inRange0to255(g1 * this._whitePoint.g), inRange0to255(b1 * this._whitePoint.b));\n    const lab2 = rgb2lab(inRange0to255(r2 * this._whitePoint.r), inRange0to255(g2 * this._whitePoint.g), inRange0to255(b2 * this._whitePoint.b));\n    const dL = lab1.L - lab2.L;\n    const dA = lab1.a - lab2.a;\n    const dB = lab1.b - lab2.b;\n    const c1 = Math.sqrt(lab1.a * lab1.a + lab1.b * lab1.b);\n    const c2 = Math.sqrt(lab2.a * lab2.a + lab2.b * lab2.b);\n    const dC = c1 - c2;\n    let deltaH = dA * dA + dB * dB - dC * dC;\n    deltaH = deltaH < 0 ? 0 : Math.sqrt(deltaH);\n    const dAlpha = (a2 - a1) * this._whitePoint.a * this._kA;\n    return Math.sqrt((dL / this._Kl) ** 2 + (dC / (1 + this._K1 * c1)) ** 2 + (deltaH / (1 + this._K2 * c1)) ** 2 + dAlpha ** 2);\n  }\n};\nvar CIE94Textiles = class extends AbstractCIE94 {\n  _setDefaults() {\n    this._Kl = 2;\n    this._K1 = 0.048;\n    this._K2 = 0.014;\n    this._kA = 0.25 * 50 / 255;\n  }\n};\nvar CIE94GraphicArts = class extends AbstractCIE94 {\n  _setDefaults() {\n    this._Kl = 1;\n    this._K1 = 0.045;\n    this._K2 = 0.015;\n    this._kA = 0.25 * 100 / 255;\n  }\n};\n\n// src/distance/ciede2000.ts\nvar _CIEDE2000 = class extends AbstractDistanceCalculator {\n  _setDefaults() {\n  }\n  static _calculatehp(b, ap) {\n    const hp = Math.atan2(b, ap);\n    if (hp >= 0)\n      return hp;\n    return hp + _CIEDE2000._deg360InRad;\n  }\n  static _calculateRT(ahp, aCp) {\n    const aCp_to_7 = aCp ** 7;\n    const R_C = 2 * Math.sqrt(aCp_to_7 / (aCp_to_7 + _CIEDE2000._pow25to7));\n    const delta_theta = _CIEDE2000._deg30InRad * Math.exp(-(((ahp - _CIEDE2000._deg275InRad) / _CIEDE2000._deg25InRad) ** 2));\n    return -Math.sin(2 * delta_theta) * R_C;\n  }\n  static _calculateT(ahp) {\n    return 1 - 0.17 * Math.cos(ahp - _CIEDE2000._deg30InRad) + 0.24 * Math.cos(ahp * 2) + 0.32 * Math.cos(ahp * 3 + _CIEDE2000._deg6InRad) - 0.2 * Math.cos(ahp * 4 - _CIEDE2000._deg63InRad);\n  }\n  static _calculate_ahp(C1pC2p, h_bar, h1p, h2p) {\n    const hpSum = h1p + h2p;\n    if (C1pC2p === 0)\n      return hpSum;\n    if (h_bar <= _CIEDE2000._deg180InRad)\n      return hpSum / 2;\n    if (hpSum < _CIEDE2000._deg360InRad) {\n      return (hpSum + _CIEDE2000._deg360InRad) / 2;\n    }\n    return (hpSum - _CIEDE2000._deg360InRad) / 2;\n  }\n  static _calculate_dHp(C1pC2p, h_bar, h2p, h1p) {\n    let dhp;\n    if (C1pC2p === 0) {\n      dhp = 0;\n    } else if (h_bar <= _CIEDE2000._deg180InRad) {\n      dhp = h2p - h1p;\n    } else if (h2p <= h1p) {\n      dhp = h2p - h1p + _CIEDE2000._deg360InRad;\n    } else {\n      dhp = h2p - h1p - _CIEDE2000._deg360InRad;\n    }\n    return 2 * Math.sqrt(C1pC2p) * Math.sin(dhp / 2);\n  }\n  calculateRaw(r1, g1, b1, a1, r2, g2, b2, a2) {\n    const lab1 = rgb2lab(inRange0to255(r1 * this._whitePoint.r), inRange0to255(g1 * this._whitePoint.g), inRange0to255(b1 * this._whitePoint.b));\n    const lab2 = rgb2lab(inRange0to255(r2 * this._whitePoint.r), inRange0to255(g2 * this._whitePoint.g), inRange0to255(b2 * this._whitePoint.b));\n    const dA = (a2 - a1) * this._whitePoint.a * _CIEDE2000._kA;\n    const dE2 = this.calculateRawInLab(lab1, lab2);\n    return Math.sqrt(dE2 + dA * dA);\n  }\n  calculateRawInLab(Lab1, Lab2) {\n    const L1 = Lab1.L;\n    const a1 = Lab1.a;\n    const b1 = Lab1.b;\n    const L2 = Lab2.L;\n    const a2 = Lab2.a;\n    const b2 = Lab2.b;\n    const C1 = Math.sqrt(a1 * a1 + b1 * b1);\n    const C2 = Math.sqrt(a2 * a2 + b2 * b2);\n    const pow_a_C1_C2_to_7 = ((C1 + C2) / 2) ** 7;\n    const G = 0.5 * (1 - Math.sqrt(pow_a_C1_C2_to_7 / (pow_a_C1_C2_to_7 + _CIEDE2000._pow25to7)));\n    const a1p = (1 + G) * a1;\n    const a2p = (1 + G) * a2;\n    const C1p = Math.sqrt(a1p * a1p + b1 * b1);\n    const C2p = Math.sqrt(a2p * a2p + b2 * b2);\n    const C1pC2p = C1p * C2p;\n    const h1p = _CIEDE2000._calculatehp(b1, a1p);\n    const h2p = _CIEDE2000._calculatehp(b2, a2p);\n    const h_bar = Math.abs(h1p - h2p);\n    const dLp = L2 - L1;\n    const dCp = C2p - C1p;\n    const dHp = _CIEDE2000._calculate_dHp(C1pC2p, h_bar, h2p, h1p);\n    const ahp = _CIEDE2000._calculate_ahp(C1pC2p, h_bar, h1p, h2p);\n    const T = _CIEDE2000._calculateT(ahp);\n    const aCp = (C1p + C2p) / 2;\n    const aLp_minus_50_square = ((L1 + L2) / 2 - 50) ** 2;\n    const S_L = 1 + 0.015 * aLp_minus_50_square / Math.sqrt(20 + aLp_minus_50_square);\n    const S_C = 1 + 0.045 * aCp;\n    const S_H = 1 + 0.015 * T * aCp;\n    const R_T = _CIEDE2000._calculateRT(ahp, aCp);\n    const dLpSL = dLp / S_L;\n    const dCpSC = dCp / S_C;\n    const dHpSH = dHp / S_H;\n    return dLpSL ** 2 + dCpSC ** 2 + dHpSH ** 2 + R_T * dCpSC * dHpSH;\n  }\n};\nvar CIEDE2000 = _CIEDE2000;\n__publicField(CIEDE2000, \"_kA\", 0.25 * 100 / 255);\n__publicField(CIEDE2000, \"_pow25to7\", 25 ** 7);\n__publicField(CIEDE2000, \"_deg360InRad\", degrees2radians(360));\n__publicField(CIEDE2000, \"_deg180InRad\", degrees2radians(180));\n__publicField(CIEDE2000, \"_deg30InRad\", degrees2radians(30));\n__publicField(CIEDE2000, \"_deg6InRad\", degrees2radians(6));\n__publicField(CIEDE2000, \"_deg63InRad\", degrees2radians(63));\n__publicField(CIEDE2000, \"_deg275InRad\", degrees2radians(275));\n__publicField(CIEDE2000, \"_deg25InRad\", degrees2radians(25));\n\n// src/distance/cmetric.ts\nvar CMetric = class extends AbstractDistanceCalculator {\n  calculateRaw(r1, g1, b1, a1, r2, g2, b2, a2) {\n    const rmean = (r1 + r2) / 2 * this._whitePoint.r;\n    const r = (r1 - r2) * this._whitePoint.r;\n    const g = (g1 - g2) * this._whitePoint.g;\n    const b = (b1 - b2) * this._whitePoint.b;\n    const dE = ((512 + rmean) * r * r >> 8) + 4 * g * g + ((767 - rmean) * b * b >> 8);\n    const dA = (a2 - a1) * this._whitePoint.a;\n    return Math.sqrt(dE + dA * dA);\n  }\n  _setDefaults() {\n  }\n};\n\n// src/distance/euclidean.ts\nvar AbstractEuclidean = class extends AbstractDistanceCalculator {\n  calculateRaw(r1, g1, b1, a1, r2, g2, b2, a2) {\n    const dR = r2 - r1;\n    const dG = g2 - g1;\n    const dB = b2 - b1;\n    const dA = a2 - a1;\n    return Math.sqrt(this._kR * dR * dR + this._kG * dG * dG + this._kB * dB * dB + this._kA * dA * dA);\n  }\n};\nvar Euclidean = class extends AbstractEuclidean {\n  _setDefaults() {\n    this._kR = 1;\n    this._kG = 1;\n    this._kB = 1;\n    this._kA = 1;\n  }\n};\nvar EuclideanBT709 = class extends AbstractEuclidean {\n  _setDefaults() {\n    this._kR = 0.2126 /* RED */;\n    this._kG = 0.7152 /* GREEN */;\n    this._kB = 0.0722 /* BLUE */;\n    this._kA = 1;\n  }\n};\nvar EuclideanBT709NoAlpha = class extends AbstractEuclidean {\n  _setDefaults() {\n    this._kR = 0.2126 /* RED */;\n    this._kG = 0.7152 /* GREEN */;\n    this._kB = 0.0722 /* BLUE */;\n    this._kA = 0;\n  }\n};\n\n// src/distance/manhattan.ts\nvar AbstractManhattan = class extends AbstractDistanceCalculator {\n  calculateRaw(r1, g1, b1, a1, r2, g2, b2, a2) {\n    let dR = r2 - r1;\n    let dG = g2 - g1;\n    let dB = b2 - b1;\n    let dA = a2 - a1;\n    if (dR < 0)\n      dR = 0 - dR;\n    if (dG < 0)\n      dG = 0 - dG;\n    if (dB < 0)\n      dB = 0 - dB;\n    if (dA < 0)\n      dA = 0 - dA;\n    return this._kR * dR + this._kG * dG + this._kB * dB + this._kA * dA;\n  }\n};\nvar Manhattan = class extends AbstractManhattan {\n  _setDefaults() {\n    this._kR = 1;\n    this._kG = 1;\n    this._kB = 1;\n    this._kA = 1;\n  }\n};\nvar ManhattanNommyde = class extends AbstractManhattan {\n  _setDefaults() {\n    this._kR = 0.4984;\n    this._kG = 0.8625;\n    this._kB = 0.2979;\n    this._kA = 1;\n  }\n};\nvar ManhattanBT709 = class extends AbstractManhattan {\n  _setDefaults() {\n    this._kR = 0.2126 /* RED */;\n    this._kG = 0.7152 /* GREEN */;\n    this._kB = 0.0722 /* BLUE */;\n    this._kA = 1;\n  }\n};\n\n// src/distance/pngQuant.ts\nvar PNGQuant = class extends AbstractDistanceCalculator {\n  calculateRaw(r1, g1, b1, a1, r2, g2, b2, a2) {\n    const alphas = (a2 - a1) * this._whitePoint.a;\n    return this._colordifferenceCh(r1 * this._whitePoint.r, r2 * this._whitePoint.r, alphas) + this._colordifferenceCh(g1 * this._whitePoint.g, g2 * this._whitePoint.g, alphas) + this._colordifferenceCh(b1 * this._whitePoint.b, b2 * this._whitePoint.b, alphas);\n  }\n  _colordifferenceCh(x2, y2, alphas) {\n    const black = x2 - y2;\n    const white = black + alphas;\n    return black * black + white * white;\n  }\n  _setDefaults() {\n  }\n};\n\n// src/palette/index.ts\nvar palette_exports = {};\n__export(palette_exports, {\n  AbstractPaletteQuantizer: () => AbstractPaletteQuantizer,\n  ColorHistogram: () => ColorHistogram,\n  NeuQuant: () => NeuQuant,\n  NeuQuantFloat: () => NeuQuantFloat,\n  RGBQuant: () => RGBQuant,\n  WuColorCube: () => WuColorCube,\n  WuQuant: () => WuQuant\n});\n\n// src/palette/paletteQuantizer.ts\nvar AbstractPaletteQuantizer = class {\n  quantizeSync() {\n    for (const value of this.quantize()) {\n      if (value.palette) {\n        return value.palette;\n      }\n    }\n    throw new Error(\"unreachable\");\n  }\n};\n\n// src/utils/point.ts\nvar Point = class {\n  constructor() {\n    __publicField(this, \"r\");\n    __publicField(this, \"g\");\n    __publicField(this, \"b\");\n    __publicField(this, \"a\");\n    __publicField(this, \"uint32\");\n    __publicField(this, \"rgba\");\n    this.uint32 = -1 >>> 0;\n    this.r = this.g = this.b = this.a = 0;\n    this.rgba = new Array(4);\n    this.rgba[0] = 0;\n    this.rgba[1] = 0;\n    this.rgba[2] = 0;\n    this.rgba[3] = 0;\n  }\n  static createByQuadruplet(quadruplet) {\n    const point = new Point();\n    point.r = quadruplet[0] | 0;\n    point.g = quadruplet[1] | 0;\n    point.b = quadruplet[2] | 0;\n    point.a = quadruplet[3] | 0;\n    point._loadUINT32();\n    point._loadQuadruplet();\n    return point;\n  }\n  static createByRGBA(red, green, blue, alpha) {\n    const point = new Point();\n    point.r = red | 0;\n    point.g = green | 0;\n    point.b = blue | 0;\n    point.a = alpha | 0;\n    point._loadUINT32();\n    point._loadQuadruplet();\n    return point;\n  }\n  static createByUint32(uint32) {\n    const point = new Point();\n    point.uint32 = uint32 >>> 0;\n    point._loadRGBA();\n    point._loadQuadruplet();\n    return point;\n  }\n  from(point) {\n    this.r = point.r;\n    this.g = point.g;\n    this.b = point.b;\n    this.a = point.a;\n    this.uint32 = point.uint32;\n    this.rgba[0] = point.r;\n    this.rgba[1] = point.g;\n    this.rgba[2] = point.b;\n    this.rgba[3] = point.a;\n  }\n  getLuminosity(useAlphaChannel) {\n    let r = this.r;\n    let g = this.g;\n    let b = this.b;\n    if (useAlphaChannel) {\n      r = Math.min(255, 255 - this.a + this.a * r / 255);\n      g = Math.min(255, 255 - this.a + this.a * g / 255);\n      b = Math.min(255, 255 - this.a + this.a * b / 255);\n    }\n    return r * 0.2126 /* RED */ + g * 0.7152 /* GREEN */ + b * 0.0722 /* BLUE */;\n  }\n  _loadUINT32() {\n    this.uint32 = (this.a << 24 | this.b << 16 | this.g << 8 | this.r) >>> 0;\n  }\n  _loadRGBA() {\n    this.r = this.uint32 & 255;\n    this.g = this.uint32 >>> 8 & 255;\n    this.b = this.uint32 >>> 16 & 255;\n    this.a = this.uint32 >>> 24 & 255;\n  }\n  _loadQuadruplet() {\n    this.rgba[0] = this.r;\n    this.rgba[1] = this.g;\n    this.rgba[2] = this.b;\n    this.rgba[3] = this.a;\n  }\n};\n\n// src/utils/pointContainer.ts\nvar PointContainer = class {\n  constructor() {\n    __publicField(this, \"_pointArray\");\n    __publicField(this, \"_width\");\n    __publicField(this, \"_height\");\n    this._width = 0;\n    this._height = 0;\n    this._pointArray = [];\n  }\n  getWidth() {\n    return this._width;\n  }\n  getHeight() {\n    return this._height;\n  }\n  setWidth(width) {\n    this._width = width;\n  }\n  setHeight(height) {\n    this._height = height;\n  }\n  getPointArray() {\n    return this._pointArray;\n  }\n  clone() {\n    const clone = new PointContainer();\n    clone._width = this._width;\n    clone._height = this._height;\n    for (let i = 0, l = this._pointArray.length; i < l; i++) {\n      clone._pointArray[i] = Point.createByUint32(this._pointArray[i].uint32 | 0);\n    }\n    return clone;\n  }\n  toUint32Array() {\n    const l = this._pointArray.length;\n    const uint32Array = new Uint32Array(l);\n    for (let i = 0; i < l; i++) {\n      uint32Array[i] = this._pointArray[i].uint32;\n    }\n    return uint32Array;\n  }\n  toUint8Array() {\n    return new Uint8Array(this.toUint32Array().buffer);\n  }\n  static fromHTMLImageElement(img) {\n    const width = img.naturalWidth;\n    const height = img.naturalHeight;\n    const canvas = document.createElement(\"canvas\");\n    canvas.width = width;\n    canvas.height = height;\n    const ctx = canvas.getContext(\"2d\");\n    ctx.drawImage(img, 0, 0, width, height, 0, 0, width, height);\n    return PointContainer.fromHTMLCanvasElement(canvas);\n  }\n  static fromHTMLCanvasElement(canvas) {\n    const width = canvas.width;\n    const height = canvas.height;\n    const ctx = canvas.getContext(\"2d\");\n    const imgData = ctx.getImageData(0, 0, width, height);\n    return PointContainer.fromImageData(imgData);\n  }\n  static fromImageData(imageData) {\n    const width = imageData.width;\n    const height = imageData.height;\n    return PointContainer.fromUint8Array(imageData.data, width, height);\n  }\n  static fromUint8Array(uint8Array, width, height) {\n    switch (Object.prototype.toString.call(uint8Array)) {\n      case \"[object Uint8ClampedArray]\":\n      case \"[object Uint8Array]\":\n        break;\n      default:\n        uint8Array = new Uint8Array(uint8Array);\n    }\n    const uint32Array = new Uint32Array(uint8Array.buffer);\n    return PointContainer.fromUint32Array(uint32Array, width, height);\n  }\n  static fromUint32Array(uint32Array, width, height) {\n    const container = new PointContainer();\n    container._width = width;\n    container._height = height;\n    for (let i = 0, l = uint32Array.length; i < l; i++) {\n      container._pointArray[i] = Point.createByUint32(uint32Array[i] | 0);\n    }\n    return container;\n  }\n  static fromBuffer(buffer, width, height) {\n    const uint32Array = new Uint32Array(buffer.buffer, buffer.byteOffset, buffer.byteLength / Uint32Array.BYTES_PER_ELEMENT);\n    return PointContainer.fromUint32Array(uint32Array, width, height);\n  }\n};\n\n// src/utils/palette.ts\nvar hueGroups = 10;\nfunction hueGroup(hue, segmentsNumber) {\n  const maxHue = 360;\n  const seg = maxHue / segmentsNumber;\n  const half = seg / 2;\n  for (let i = 1, mid = seg - half; i < segmentsNumber; i++, mid += seg) {\n    if (hue >= mid && hue < mid + seg)\n      return i;\n  }\n  return 0;\n}\nvar Palette = class {\n  constructor() {\n    __publicField(this, \"_pointContainer\");\n    __publicField(this, \"_pointArray\", []);\n    __publicField(this, \"_i32idx\", {});\n    this._pointContainer = new PointContainer();\n    this._pointContainer.setHeight(1);\n    this._pointArray = this._pointContainer.getPointArray();\n  }\n  add(color) {\n    this._pointArray.push(color);\n    this._pointContainer.setWidth(this._pointArray.length);\n  }\n  has(color) {\n    for (let i = this._pointArray.length - 1; i >= 0; i--) {\n      if (color.uint32 === this._pointArray[i].uint32)\n        return true;\n    }\n    return false;\n  }\n  getNearestColor(colorDistanceCalculator, color) {\n    return this._pointArray[this._getNearestIndex(colorDistanceCalculator, color) | 0];\n  }\n  getPointContainer() {\n    return this._pointContainer;\n  }\n  _nearestPointFromCache(key) {\n    return typeof this._i32idx[key] === \"number\" ? this._i32idx[key] : -1;\n  }\n  _getNearestIndex(colorDistanceCalculator, point) {\n    let idx = this._nearestPointFromCache(\"\" + point.uint32);\n    if (idx >= 0)\n      return idx;\n    let minimalDistance = Number.MAX_VALUE;\n    idx = 0;\n    for (let i = 0, l = this._pointArray.length; i < l; i++) {\n      const p = this._pointArray[i];\n      const distance = colorDistanceCalculator.calculateRaw(point.r, point.g, point.b, point.a, p.r, p.g, p.b, p.a);\n      if (distance < minimalDistance) {\n        minimalDistance = distance;\n        idx = i;\n      }\n    }\n    this._i32idx[point.uint32] = idx;\n    return idx;\n  }\n  sort() {\n    this._i32idx = {};\n    this._pointArray.sort((a, b) => {\n      const hslA = rgb2hsl(a.r, a.g, a.b);\n      const hslB = rgb2hsl(b.r, b.g, b.b);\n      const hueA = a.r === a.g && a.g === a.b ? 0 : 1 + hueGroup(hslA.h, hueGroups);\n      const hueB = b.r === b.g && b.g === b.b ? 0 : 1 + hueGroup(hslB.h, hueGroups);\n      const hueDiff = hueB - hueA;\n      if (hueDiff)\n        return -hueDiff;\n      const lA = a.getLuminosity(true);\n      const lB = b.getLuminosity(true);\n      if (lB - lA !== 0)\n        return lB - lA;\n      const satDiff = (hslB.s * 100 | 0) - (hslA.s * 100 | 0);\n      if (satDiff)\n        return -satDiff;\n      return 0;\n    });\n  }\n};\n\n// src/utils/index.ts\nvar utils_exports = {};\n__export(utils_exports, {\n  HueStatistics: () => HueStatistics,\n  Palette: () => Palette,\n  Point: () => Point,\n  PointContainer: () => PointContainer,\n  ProgressTracker: () => ProgressTracker,\n  arithmetic: () => arithmetic_exports\n});\n\n// src/utils/hueStatistics.ts\nvar HueGroup = class {\n  constructor() {\n    __publicField(this, \"num\", 0);\n    __publicField(this, \"cols\", []);\n  }\n};\nvar HueStatistics = class {\n  constructor(numGroups, minCols) {\n    __publicField(this, \"_numGroups\");\n    __publicField(this, \"_minCols\");\n    __publicField(this, \"_stats\");\n    __publicField(this, \"_groupsFull\");\n    this._numGroups = numGroups;\n    this._minCols = minCols;\n    this._stats = [];\n    for (let i = 0; i <= numGroups; i++) {\n      this._stats[i] = new HueGroup();\n    }\n    this._groupsFull = 0;\n  }\n  check(i32) {\n    if (this._groupsFull === this._numGroups + 1) {\n      this.check = () => {\n      };\n    }\n    const r = i32 & 255;\n    const g = i32 >>> 8 & 255;\n    const b = i32 >>> 16 & 255;\n    const hg = r === g && g === b ? 0 : 1 + hueGroup(rgb2hsl(r, g, b).h, this._numGroups);\n    const gr = this._stats[hg];\n    const min = this._minCols;\n    gr.num++;\n    if (gr.num > min) {\n      return;\n    }\n    if (gr.num === min) {\n      this._groupsFull++;\n    }\n    if (gr.num <= min) {\n      this._stats[hg].cols.push(i32);\n    }\n  }\n  injectIntoDictionary(histG) {\n    for (let i = 0; i <= this._numGroups; i++) {\n      if (this._stats[i].num <= this._minCols) {\n        this._stats[i].cols.forEach((col) => {\n          if (!histG[col]) {\n            histG[col] = 1;\n          } else {\n            histG[col]++;\n          }\n        });\n      }\n    }\n  }\n  injectIntoArray(histG) {\n    for (let i = 0; i <= this._numGroups; i++) {\n      if (this._stats[i].num <= this._minCols) {\n        this._stats[i].cols.forEach((col) => {\n          if (histG.indexOf(col) === -1) {\n            histG.push(col);\n          }\n        });\n      }\n    }\n  }\n};\n\n// src/utils/progressTracker.ts\nvar _ProgressTracker = class {\n  constructor(valueRange, progressRange) {\n    __publicField(this, \"progress\");\n    __publicField(this, \"_step\");\n    __publicField(this, \"_range\");\n    __publicField(this, \"_last\");\n    __publicField(this, \"_progressRange\");\n    this._range = valueRange;\n    this._progressRange = progressRange;\n    this._step = Math.max(1, this._range / (_ProgressTracker.steps + 1) | 0);\n    this._last = -this._step;\n    this.progress = 0;\n  }\n  shouldNotify(current) {\n    if (current - this._last >= this._step) {\n      this._last = current;\n      this.progress = Math.min(this._progressRange * this._last / this._range, this._progressRange);\n      return true;\n    }\n    return false;\n  }\n};\nvar ProgressTracker = _ProgressTracker;\n__publicField(ProgressTracker, \"steps\", 100);\n\n// src/palette/neuquant/neuquant.ts\nvar networkBiasShift = 3;\nvar Neuron = class {\n  constructor(defaultValue) {\n    __publicField(this, \"r\");\n    __publicField(this, \"g\");\n    __publicField(this, \"b\");\n    __publicField(this, \"a\");\n    this.r = this.g = this.b = this.a = defaultValue;\n  }\n  toPoint() {\n    return Point.createByRGBA(this.r >> networkBiasShift, this.g >> networkBiasShift, this.b >> networkBiasShift, this.a >> networkBiasShift);\n  }\n  subtract(r, g, b, a) {\n    this.r -= r | 0;\n    this.g -= g | 0;\n    this.b -= b | 0;\n    this.a -= a | 0;\n  }\n};\nvar _NeuQuant = class extends AbstractPaletteQuantizer {\n  constructor(colorDistanceCalculator, colors = 256) {\n    super();\n    __publicField(this, \"_pointArray\");\n    __publicField(this, \"_networkSize\");\n    __publicField(this, \"_network\");\n    __publicField(this, \"_sampleFactor\");\n    __publicField(this, \"_radPower\");\n    __publicField(this, \"_freq\");\n    __publicField(this, \"_bias\");\n    __publicField(this, \"_distance\");\n    this._distance = colorDistanceCalculator;\n    this._pointArray = [];\n    this._sampleFactor = 1;\n    this._networkSize = colors;\n    this._distance.setWhitePoint(255 << networkBiasShift, 255 << networkBiasShift, 255 << networkBiasShift, 255 << networkBiasShift);\n  }\n  sample(pointContainer) {\n    this._pointArray = this._pointArray.concat(pointContainer.getPointArray());\n  }\n  *quantize() {\n    this._init();\n    yield* this._learn();\n    yield {\n      palette: this._buildPalette(),\n      progress: 100\n    };\n  }\n  _init() {\n    this._freq = [];\n    this._bias = [];\n    this._radPower = [];\n    this._network = [];\n    for (let i = 0; i < this._networkSize; i++) {\n      this._network[i] = new Neuron((i << networkBiasShift + 8) / this._networkSize | 0);\n      this._freq[i] = _NeuQuant._initialBias / this._networkSize | 0;\n      this._bias[i] = 0;\n    }\n  }\n  *_learn() {\n    let sampleFactor = this._sampleFactor;\n    const pointsNumber = this._pointArray.length;\n    if (pointsNumber < _NeuQuant._minpicturebytes)\n      sampleFactor = 1;\n    const alphadec = 30 + (sampleFactor - 1) / 3 | 0;\n    const pointsToSample = pointsNumber / sampleFactor | 0;\n    let delta = pointsToSample / _NeuQuant._nCycles | 0;\n    let alpha = _NeuQuant._initAlpha;\n    let radius = (this._networkSize >> 3) * _NeuQuant._radiusBias;\n    let rad = radius >> _NeuQuant._radiusBiasShift;\n    if (rad <= 1)\n      rad = 0;\n    for (let i = 0; i < rad; i++) {\n      this._radPower[i] = alpha * ((rad * rad - i * i) * _NeuQuant._radBias / (rad * rad)) >>> 0;\n    }\n    let step;\n    if (pointsNumber < _NeuQuant._minpicturebytes) {\n      step = 1;\n    } else if (pointsNumber % _NeuQuant._prime1 !== 0) {\n      step = _NeuQuant._prime1;\n    } else if (pointsNumber % _NeuQuant._prime2 !== 0) {\n      step = _NeuQuant._prime2;\n    } else if (pointsNumber % _NeuQuant._prime3 !== 0) {\n      step = _NeuQuant._prime3;\n    } else {\n      step = _NeuQuant._prime4;\n    }\n    const tracker = new ProgressTracker(pointsToSample, 99);\n    for (let i = 0, pointIndex = 0; i < pointsToSample; ) {\n      if (tracker.shouldNotify(i)) {\n        yield {\n          progress: tracker.progress\n        };\n      }\n      const point = this._pointArray[pointIndex];\n      const b = point.b << networkBiasShift;\n      const g = point.g << networkBiasShift;\n      const r = point.r << networkBiasShift;\n      const a = point.a << networkBiasShift;\n      const neuronIndex = this._contest(b, g, r, a);\n      this._alterSingle(alpha, neuronIndex, b, g, r, a);\n      if (rad !== 0)\n        this._alterNeighbour(rad, neuronIndex, b, g, r, a);\n      pointIndex += step;\n      if (pointIndex >= pointsNumber)\n        pointIndex -= pointsNumber;\n      i++;\n      if (delta === 0)\n        delta = 1;\n      if (i % delta === 0) {\n        alpha -= alpha / alphadec | 0;\n        radius -= radius / _NeuQuant._radiusDecrease | 0;\n        rad = radius >> _NeuQuant._radiusBiasShift;\n        if (rad <= 1)\n          rad = 0;\n        for (let j = 0; j < rad; j++) {\n          this._radPower[j] = alpha * ((rad * rad - j * j) * _NeuQuant._radBias / (rad * rad)) >>> 0;\n        }\n      }\n    }\n  }\n  _buildPalette() {\n    const palette = new Palette();\n    this._network.forEach((neuron) => {\n      palette.add(neuron.toPoint());\n    });\n    palette.sort();\n    return palette;\n  }\n  _alterNeighbour(rad, i, b, g, r, al) {\n    let lo = i - rad;\n    if (lo < -1)\n      lo = -1;\n    let hi = i + rad;\n    if (hi > this._networkSize)\n      hi = this._networkSize;\n    let j = i + 1;\n    let k = i - 1;\n    let m = 1;\n    while (j < hi || k > lo) {\n      const a = this._radPower[m++] / _NeuQuant._alphaRadBias;\n      if (j < hi) {\n        const p = this._network[j++];\n        p.subtract(a * (p.r - r), a * (p.g - g), a * (p.b - b), a * (p.a - al));\n      }\n      if (k > lo) {\n        const p = this._network[k--];\n        p.subtract(a * (p.r - r), a * (p.g - g), a * (p.b - b), a * (p.a - al));\n      }\n    }\n  }\n  _alterSingle(alpha, i, b, g, r, a) {\n    alpha /= _NeuQuant._initAlpha;\n    const n = this._network[i];\n    n.subtract(alpha * (n.r - r), alpha * (n.g - g), alpha * (n.b - b), alpha * (n.a - a));\n  }\n  _contest(b, g, r, a) {\n    const multiplier = 255 * 4 << networkBiasShift;\n    let bestd = ~(1 << 31);\n    let bestbiasd = bestd;\n    let bestpos = -1;\n    let bestbiaspos = bestpos;\n    for (let i = 0; i < this._networkSize; i++) {\n      const n = this._network[i];\n      const dist = this._distance.calculateNormalized(n, { r, g, b, a }) * multiplier | 0;\n      if (dist < bestd) {\n        bestd = dist;\n        bestpos = i;\n      }\n      const biasdist = dist - (this._bias[i] >> _NeuQuant._initialBiasShift - networkBiasShift);\n      if (biasdist < bestbiasd) {\n        bestbiasd = biasdist;\n        bestbiaspos = i;\n      }\n      const betafreq = this._freq[i] >> _NeuQuant._betaShift;\n      this._freq[i] -= betafreq;\n      this._bias[i] += betafreq << _NeuQuant._gammaShift;\n    }\n    this._freq[bestpos] += _NeuQuant._beta;\n    this._bias[bestpos] -= _NeuQuant._betaGamma;\n    return bestbiaspos;\n  }\n};\nvar NeuQuant = _NeuQuant;\n__publicField(NeuQuant, \"_prime1\", 499);\n__publicField(NeuQuant, \"_prime2\", 491);\n__publicField(NeuQuant, \"_prime3\", 487);\n__publicField(NeuQuant, \"_prime4\", 503);\n__publicField(NeuQuant, \"_minpicturebytes\", _NeuQuant._prime4);\n__publicField(NeuQuant, \"_nCycles\", 100);\n__publicField(NeuQuant, \"_initialBiasShift\", 16);\n__publicField(NeuQuant, \"_initialBias\", 1 << _NeuQuant._initialBiasShift);\n__publicField(NeuQuant, \"_gammaShift\", 10);\n__publicField(NeuQuant, \"_betaShift\", 10);\n__publicField(NeuQuant, \"_beta\", _NeuQuant._initialBias >> _NeuQuant._betaShift);\n__publicField(NeuQuant, \"_betaGamma\", _NeuQuant._initialBias << _NeuQuant._gammaShift - _NeuQuant._betaShift);\n__publicField(NeuQuant, \"_radiusBiasShift\", 6);\n__publicField(NeuQuant, \"_radiusBias\", 1 << _NeuQuant._radiusBiasShift);\n__publicField(NeuQuant, \"_radiusDecrease\", 30);\n__publicField(NeuQuant, \"_alphaBiasShift\", 10);\n__publicField(NeuQuant, \"_initAlpha\", 1 << _NeuQuant._alphaBiasShift);\n__publicField(NeuQuant, \"_radBiasShift\", 8);\n__publicField(NeuQuant, \"_radBias\", 1 << _NeuQuant._radBiasShift);\n__publicField(NeuQuant, \"_alphaRadBiasShift\", _NeuQuant._alphaBiasShift + _NeuQuant._radBiasShift);\n__publicField(NeuQuant, \"_alphaRadBias\", 1 << _NeuQuant._alphaRadBiasShift);\n\n// src/palette/neuquant/neuquantFloat.ts\nvar networkBiasShift2 = 3;\nvar NeuronFloat = class {\n  constructor(defaultValue) {\n    __publicField(this, \"r\");\n    __publicField(this, \"g\");\n    __publicField(this, \"b\");\n    __publicField(this, \"a\");\n    this.r = this.g = this.b = this.a = defaultValue;\n  }\n  toPoint() {\n    return Point.createByRGBA(this.r >> networkBiasShift2, this.g >> networkBiasShift2, this.b >> networkBiasShift2, this.a >> networkBiasShift2);\n  }\n  subtract(r, g, b, a) {\n    this.r -= r;\n    this.g -= g;\n    this.b -= b;\n    this.a -= a;\n  }\n};\nvar _NeuQuantFloat = class extends AbstractPaletteQuantizer {\n  constructor(colorDistanceCalculator, colors = 256) {\n    super();\n    __publicField(this, \"_pointArray\");\n    __publicField(this, \"_networkSize\");\n    __publicField(this, \"_network\");\n    __publicField(this, \"_sampleFactor\");\n    __publicField(this, \"_radPower\");\n    __publicField(this, \"_freq\");\n    __publicField(this, \"_bias\");\n    __publicField(this, \"_distance\");\n    this._distance = colorDistanceCalculator;\n    this._pointArray = [];\n    this._sampleFactor = 1;\n    this._networkSize = colors;\n    this._distance.setWhitePoint(255 << networkBiasShift2, 255 << networkBiasShift2, 255 << networkBiasShift2, 255 << networkBiasShift2);\n  }\n  sample(pointContainer) {\n    this._pointArray = this._pointArray.concat(pointContainer.getPointArray());\n  }\n  *quantize() {\n    this._init();\n    yield* this._learn();\n    yield {\n      palette: this._buildPalette(),\n      progress: 100\n    };\n  }\n  _init() {\n    this._freq = [];\n    this._bias = [];\n    this._radPower = [];\n    this._network = [];\n    for (let i = 0; i < this._networkSize; i++) {\n      this._network[i] = new NeuronFloat((i << networkBiasShift2 + 8) / this._networkSize);\n      this._freq[i] = _NeuQuantFloat._initialBias / this._networkSize;\n      this._bias[i] = 0;\n    }\n  }\n  *_learn() {\n    let sampleFactor = this._sampleFactor;\n    const pointsNumber = this._pointArray.length;\n    if (pointsNumber < _NeuQuantFloat._minpicturebytes)\n      sampleFactor = 1;\n    const alphadec = 30 + (sampleFactor - 1) / 3;\n    const pointsToSample = pointsNumber / sampleFactor;\n    let delta = pointsToSample / _NeuQuantFloat._nCycles | 0;\n    let alpha = _NeuQuantFloat._initAlpha;\n    let radius = (this._networkSize >> 3) * _NeuQuantFloat._radiusBias;\n    let rad = radius >> _NeuQuantFloat._radiusBiasShift;\n    if (rad <= 1)\n      rad = 0;\n    for (let i = 0; i < rad; i++) {\n      this._radPower[i] = alpha * ((rad * rad - i * i) * _NeuQuantFloat._radBias / (rad * rad));\n    }\n    let step;\n    if (pointsNumber < _NeuQuantFloat._minpicturebytes) {\n      step = 1;\n    } else if (pointsNumber % _NeuQuantFloat._prime1 !== 0) {\n      step = _NeuQuantFloat._prime1;\n    } else if (pointsNumber % _NeuQuantFloat._prime2 !== 0) {\n      step = _NeuQuantFloat._prime2;\n    } else if (pointsNumber % _NeuQuantFloat._prime3 !== 0) {\n      step = _NeuQuantFloat._prime3;\n    } else {\n      step = _NeuQuantFloat._prime4;\n    }\n    const tracker = new ProgressTracker(pointsToSample, 99);\n    for (let i = 0, pointIndex = 0; i < pointsToSample; ) {\n      if (tracker.shouldNotify(i)) {\n        yield {\n          progress: tracker.progress\n        };\n      }\n      const point = this._pointArray[pointIndex];\n      const b = point.b << networkBiasShift2;\n      const g = point.g << networkBiasShift2;\n      const r = point.r << networkBiasShift2;\n      const a = point.a << networkBiasShift2;\n      const neuronIndex = this._contest(b, g, r, a);\n      this._alterSingle(alpha, neuronIndex, b, g, r, a);\n      if (rad !== 0)\n        this._alterNeighbour(rad, neuronIndex, b, g, r, a);\n      pointIndex += step;\n      if (pointIndex >= pointsNumber)\n        pointIndex -= pointsNumber;\n      i++;\n      if (delta === 0)\n        delta = 1;\n      if (i % delta === 0) {\n        alpha -= alpha / alphadec;\n        radius -= radius / _NeuQuantFloat._radiusDecrease;\n        rad = radius >> _NeuQuantFloat._radiusBiasShift;\n        if (rad <= 1)\n          rad = 0;\n        for (let j = 0; j < rad; j++) {\n          this._radPower[j] = alpha * ((rad * rad - j * j) * _NeuQuantFloat._radBias / (rad * rad));\n        }\n      }\n    }\n  }\n  _buildPalette() {\n    const palette = new Palette();\n    this._network.forEach((neuron) => {\n      palette.add(neuron.toPoint());\n    });\n    palette.sort();\n    return palette;\n  }\n  _alterNeighbour(rad, i, b, g, r, al) {\n    let lo = i - rad;\n    if (lo < -1)\n      lo = -1;\n    let hi = i + rad;\n    if (hi > this._networkSize)\n      hi = this._networkSize;\n    let j = i + 1;\n    let k = i - 1;\n    let m = 1;\n    while (j < hi || k > lo) {\n      const a = this._radPower[m++] / _NeuQuantFloat._alphaRadBias;\n      if (j < hi) {\n        const p = this._network[j++];\n        p.subtract(a * (p.r - r), a * (p.g - g), a * (p.b - b), a * (p.a - al));\n      }\n      if (k > lo) {\n        const p = this._network[k--];\n        p.subtract(a * (p.r - r), a * (p.g - g), a * (p.b - b), a * (p.a - al));\n      }\n    }\n  }\n  _alterSingle(alpha, i, b, g, r, a) {\n    alpha /= _NeuQuantFloat._initAlpha;\n    const n = this._network[i];\n    n.subtract(alpha * (n.r - r), alpha * (n.g - g), alpha * (n.b - b), alpha * (n.a - a));\n  }\n  _contest(b, g, r, al) {\n    const multiplier = 255 * 4 << networkBiasShift2;\n    let bestd = ~(1 << 31);\n    let bestbiasd = bestd;\n    let bestpos = -1;\n    let bestbiaspos = bestpos;\n    for (let i = 0; i < this._networkSize; i++) {\n      const n = this._network[i];\n      const dist = this._distance.calculateNormalized(n, { r, g, b, a: al }) * multiplier;\n      if (dist < bestd) {\n        bestd = dist;\n        bestpos = i;\n      }\n      const biasdist = dist - (this._bias[i] >> _NeuQuantFloat._initialBiasShift - networkBiasShift2);\n      if (biasdist < bestbiasd) {\n        bestbiasd = biasdist;\n        bestbiaspos = i;\n      }\n      const betafreq = this._freq[i] >> _NeuQuantFloat._betaShift;\n      this._freq[i] -= betafreq;\n      this._bias[i] += betafreq << _NeuQuantFloat._gammaShift;\n    }\n    this._freq[bestpos] += _NeuQuantFloat._beta;\n    this._bias[bestpos] -= _NeuQuantFloat._betaGamma;\n    return bestbiaspos;\n  }\n};\nvar NeuQuantFloat = _NeuQuantFloat;\n__publicField(NeuQuantFloat, \"_prime1\", 499);\n__publicField(NeuQuantFloat, \"_prime2\", 491);\n__publicField(NeuQuantFloat, \"_prime3\", 487);\n__publicField(NeuQuantFloat, \"_prime4\", 503);\n__publicField(NeuQuantFloat, \"_minpicturebytes\", _NeuQuantFloat._prime4);\n__publicField(NeuQuantFloat, \"_nCycles\", 100);\n__publicField(NeuQuantFloat, \"_initialBiasShift\", 16);\n__publicField(NeuQuantFloat, \"_initialBias\", 1 << _NeuQuantFloat._initialBiasShift);\n__publicField(NeuQuantFloat, \"_gammaShift\", 10);\n__publicField(NeuQuantFloat, \"_betaShift\", 10);\n__publicField(NeuQuantFloat, \"_beta\", _NeuQuantFloat._initialBias >> _NeuQuantFloat._betaShift);\n__publicField(NeuQuantFloat, \"_betaGamma\", _NeuQuantFloat._initialBias << _NeuQuantFloat._gammaShift - _NeuQuantFloat._betaShift);\n__publicField(NeuQuantFloat, \"_radiusBiasShift\", 6);\n__publicField(NeuQuantFloat, \"_radiusBias\", 1 << _NeuQuantFloat._radiusBiasShift);\n__publicField(NeuQuantFloat, \"_radiusDecrease\", 30);\n__publicField(NeuQuantFloat, \"_alphaBiasShift\", 10);\n__publicField(NeuQuantFloat, \"_initAlpha\", 1 << _NeuQuantFloat._alphaBiasShift);\n__publicField(NeuQuantFloat, \"_radBiasShift\", 8);\n__publicField(NeuQuantFloat, \"_radBias\", 1 << _NeuQuantFloat._radBiasShift);\n__publicField(NeuQuantFloat, \"_alphaRadBiasShift\", _NeuQuantFloat._alphaBiasShift + _NeuQuantFloat._radBiasShift);\n__publicField(NeuQuantFloat, \"_alphaRadBias\", 1 << _NeuQuantFloat._alphaRadBiasShift);\n\n// src/palette/rgbquant/colorHistogram.ts\nvar _ColorHistogram = class {\n  constructor(method, colors) {\n    __publicField(this, \"_method\");\n    __publicField(this, \"_hueStats\");\n    __publicField(this, \"_histogram\");\n    __publicField(this, \"_initColors\");\n    __publicField(this, \"_minHueCols\");\n    this._method = method;\n    this._minHueCols = colors << 2;\n    this._initColors = colors << 2;\n    this._hueStats = new HueStatistics(_ColorHistogram._hueGroups, this._minHueCols);\n    this._histogram = /* @__PURE__ */ Object.create(null);\n  }\n  sample(pointContainer) {\n    switch (this._method) {\n      case 1:\n        this._colorStats1D(pointContainer);\n        break;\n      case 2:\n        this._colorStats2D(pointContainer);\n        break;\n    }\n  }\n  getImportanceSortedColorsIDXI32() {\n    const sorted = stableSort(Object.keys(this._histogram), (a, b) => this._histogram[b] - this._histogram[a]);\n    if (sorted.length === 0) {\n      return [];\n    }\n    let idxi32;\n    switch (this._method) {\n      case 1:\n        const initialColorsLimit = Math.min(sorted.length, this._initColors);\n        const last = sorted[initialColorsLimit - 1];\n        const freq = this._histogram[last];\n        idxi32 = sorted.slice(0, initialColorsLimit);\n        let pos = initialColorsLimit;\n        const len = sorted.length;\n        while (pos < len && this._histogram[sorted[pos]] === freq) {\n          idxi32.push(sorted[pos++]);\n        }\n        this._hueStats.injectIntoArray(idxi32);\n        break;\n      case 2:\n        idxi32 = sorted;\n        break;\n      default:\n        throw new Error(\"Incorrect method\");\n    }\n    return idxi32.map((v) => +v);\n  }\n  _colorStats1D(pointContainer) {\n    const histG = this._histogram;\n    const pointArray = pointContainer.getPointArray();\n    const len = pointArray.length;\n    for (let i = 0; i < len; i++) {\n      const col = pointArray[i].uint32;\n      this._hueStats.check(col);\n      if (col in histG) {\n        histG[col]++;\n      } else {\n        histG[col] = 1;\n      }\n    }\n  }\n  _colorStats2D(pointContainer) {\n    const width = pointContainer.getWidth();\n    const height = pointContainer.getHeight();\n    const pointArray = pointContainer.getPointArray();\n    const boxW = _ColorHistogram._boxSize[0];\n    const boxH = _ColorHistogram._boxSize[1];\n    const area = boxW * boxH;\n    const boxes = this._makeBoxes(width, height, boxW, boxH);\n    const histG = this._histogram;\n    boxes.forEach((box) => {\n      let effc = Math.round(box.w * box.h / area) * _ColorHistogram._boxPixels;\n      if (effc < 2)\n        effc = 2;\n      const histL = {};\n      this._iterateBox(box, width, (i) => {\n        const col = pointArray[i].uint32;\n        this._hueStats.check(col);\n        if (col in histG) {\n          histG[col]++;\n        } else if (col in histL) {\n          if (++histL[col] >= effc) {\n            histG[col] = histL[col];\n          }\n        } else {\n          histL[col] = 1;\n        }\n      });\n    });\n    this._hueStats.injectIntoDictionary(histG);\n  }\n  _iterateBox(bbox, wid, fn) {\n    const b = bbox;\n    const i0 = b.y * wid + b.x;\n    const i1 = (b.y + b.h - 1) * wid + (b.x + b.w - 1);\n    const incr = wid - b.w + 1;\n    let cnt = 0;\n    let i = i0;\n    do {\n      fn.call(this, i);\n      i += ++cnt % b.w === 0 ? incr : 1;\n    } while (i <= i1);\n  }\n  _makeBoxes(width, height, stepX, stepY) {\n    const wrem = width % stepX;\n    const hrem = height % stepY;\n    const xend = width - wrem;\n    const yend = height - hrem;\n    const boxesArray = [];\n    for (let y2 = 0; y2 < height; y2 += stepY) {\n      for (let x2 = 0; x2 < width; x2 += stepX) {\n        boxesArray.push({\n          x: x2,\n          y: y2,\n          w: x2 === xend ? wrem : stepX,\n          h: y2 === yend ? hrem : stepY\n        });\n      }\n    }\n    return boxesArray;\n  }\n};\nvar ColorHistogram = _ColorHistogram;\n__publicField(ColorHistogram, \"_boxSize\", [64, 64]);\n__publicField(ColorHistogram, \"_boxPixels\", 2);\n__publicField(ColorHistogram, \"_hueGroups\", 10);\n\n// src/palette/rgbquant/rgbquant.ts\nvar RemovedColor = class {\n  constructor(index, color, distance) {\n    __publicField(this, \"index\");\n    __publicField(this, \"color\");\n    __publicField(this, \"distance\");\n    this.index = index;\n    this.color = color;\n    this.distance = distance;\n  }\n};\nvar RGBQuant = class extends AbstractPaletteQuantizer {\n  constructor(colorDistanceCalculator, colors = 256, method = 2) {\n    super();\n    __publicField(this, \"_colors\");\n    __publicField(this, \"_initialDistance\");\n    __publicField(this, \"_distanceIncrement\");\n    __publicField(this, \"_histogram\");\n    __publicField(this, \"_distance\");\n    this._distance = colorDistanceCalculator;\n    this._colors = colors;\n    this._histogram = new ColorHistogram(method, colors);\n    this._initialDistance = 0.01;\n    this._distanceIncrement = 5e-3;\n  }\n  sample(image) {\n    this._histogram.sample(image);\n  }\n  *quantize() {\n    const idxi32 = this._histogram.getImportanceSortedColorsIDXI32();\n    if (idxi32.length === 0) {\n      throw new Error(\"No colors in image\");\n    }\n    yield* this._buildPalette(idxi32);\n  }\n  *_buildPalette(idxi32) {\n    const palette = new Palette();\n    const colorArray = palette.getPointContainer().getPointArray();\n    const usageArray = new Array(idxi32.length);\n    for (let i = 0; i < idxi32.length; i++) {\n      colorArray.push(Point.createByUint32(idxi32[i]));\n      usageArray[i] = 1;\n    }\n    const len = colorArray.length;\n    const memDist = [];\n    let palLen = len;\n    let thold = this._initialDistance;\n    const tracker = new ProgressTracker(palLen - this._colors, 99);\n    while (palLen > this._colors) {\n      memDist.length = 0;\n      for (let i = 0; i < len; i++) {\n        if (tracker.shouldNotify(len - palLen)) {\n          yield {\n            progress: tracker.progress\n          };\n        }\n        if (usageArray[i] === 0)\n          continue;\n        const pxi = colorArray[i];\n        for (let j = i + 1; j < len; j++) {\n          if (usageArray[j] === 0)\n            continue;\n          const pxj = colorArray[j];\n          const dist = this._distance.calculateNormalized(pxi, pxj);\n          if (dist < thold) {\n            memDist.push(new RemovedColor(j, pxj, dist));\n            usageArray[j] = 0;\n            palLen--;\n          }\n        }\n      }\n      thold += palLen > this._colors * 3 ? this._initialDistance : this._distanceIncrement;\n    }\n    if (palLen < this._colors) {\n      stableSort(memDist, (a, b) => b.distance - a.distance);\n      let k = 0;\n      while (palLen < this._colors && k < memDist.length) {\n        const removedColor = memDist[k];\n        usageArray[removedColor.index] = 1;\n        palLen++;\n        k++;\n      }\n    }\n    let colors = colorArray.length;\n    for (let colorIndex = colors - 1; colorIndex >= 0; colorIndex--) {\n      if (usageArray[colorIndex] === 0) {\n        if (colorIndex !== colors - 1) {\n          colorArray[colorIndex] = colorArray[colors - 1];\n        }\n        --colors;\n      }\n    }\n    colorArray.length = colors;\n    palette.sort();\n    yield {\n      palette,\n      progress: 100\n    };\n  }\n};\n\n// src/palette/wu/wuQuant.ts\nfunction createArray1D(dimension1) {\n  const a = [];\n  for (let k = 0; k < dimension1; k++) {\n    a[k] = 0;\n  }\n  return a;\n}\nfunction createArray4D(dimension1, dimension2, dimension3, dimension4) {\n  const a = new Array(dimension1);\n  for (let i = 0; i < dimension1; i++) {\n    a[i] = new Array(dimension2);\n    for (let j = 0; j < dimension2; j++) {\n      a[i][j] = new Array(dimension3);\n      for (let k = 0; k < dimension3; k++) {\n        a[i][j][k] = new Array(dimension4);\n        for (let l = 0; l < dimension4; l++) {\n          a[i][j][k][l] = 0;\n        }\n      }\n    }\n  }\n  return a;\n}\nfunction createArray3D(dimension1, dimension2, dimension3) {\n  const a = new Array(dimension1);\n  for (let i = 0; i < dimension1; i++) {\n    a[i] = new Array(dimension2);\n    for (let j = 0; j < dimension2; j++) {\n      a[i][j] = new Array(dimension3);\n      for (let k = 0; k < dimension3; k++) {\n        a[i][j][k] = 0;\n      }\n    }\n  }\n  return a;\n}\nfunction fillArray3D(a, dimension1, dimension2, dimension3, value) {\n  for (let i = 0; i < dimension1; i++) {\n    a[i] = [];\n    for (let j = 0; j < dimension2; j++) {\n      a[i][j] = [];\n      for (let k = 0; k < dimension3; k++) {\n        a[i][j][k] = value;\n      }\n    }\n  }\n}\nfunction fillArray1D(a, dimension1, value) {\n  for (let i = 0; i < dimension1; i++) {\n    a[i] = value;\n  }\n}\nvar WuColorCube = class {\n  constructor() {\n    __publicField(this, \"redMinimum\");\n    __publicField(this, \"redMaximum\");\n    __publicField(this, \"greenMinimum\");\n    __publicField(this, \"greenMaximum\");\n    __publicField(this, \"blueMinimum\");\n    __publicField(this, \"blueMaximum\");\n    __publicField(this, \"volume\");\n    __publicField(this, \"alphaMinimum\");\n    __publicField(this, \"alphaMaximum\");\n  }\n};\nvar _WuQuant = class extends AbstractPaletteQuantizer {\n  constructor(colorDistanceCalculator, colors = 256, significantBitsPerChannel = 5) {\n    super();\n    __publicField(this, \"_reds\");\n    __publicField(this, \"_greens\");\n    __publicField(this, \"_blues\");\n    __publicField(this, \"_alphas\");\n    __publicField(this, \"_sums\");\n    __publicField(this, \"_weights\");\n    __publicField(this, \"_momentsRed\");\n    __publicField(this, \"_momentsGreen\");\n    __publicField(this, \"_momentsBlue\");\n    __publicField(this, \"_momentsAlpha\");\n    __publicField(this, \"_moments\");\n    __publicField(this, \"_table\");\n    __publicField(this, \"_pixels\");\n    __publicField(this, \"_cubes\");\n    __publicField(this, \"_colors\");\n    __publicField(this, \"_significantBitsPerChannel\");\n    __publicField(this, \"_maxSideIndex\");\n    __publicField(this, \"_alphaMaxSideIndex\");\n    __publicField(this, \"_sideSize\");\n    __publicField(this, \"_alphaSideSize\");\n    __publicField(this, \"_distance\");\n    this._distance = colorDistanceCalculator;\n    this._setQuality(significantBitsPerChannel);\n    this._initialize(colors);\n  }\n  sample(image) {\n    const pointArray = image.getPointArray();\n    for (let i = 0, l = pointArray.length; i < l; i++) {\n      this._addColor(pointArray[i]);\n    }\n    this._pixels = this._pixels.concat(pointArray);\n  }\n  *quantize() {\n    yield* this._preparePalette();\n    const palette = new Palette();\n    for (let paletteIndex = 0; paletteIndex < this._colors; paletteIndex++) {\n      if (this._sums[paletteIndex] > 0) {\n        const sum = this._sums[paletteIndex];\n        const r = this._reds[paletteIndex] / sum;\n        const g = this._greens[paletteIndex] / sum;\n        const b = this._blues[paletteIndex] / sum;\n        const a = this._alphas[paletteIndex] / sum;\n        const color = Point.createByRGBA(r | 0, g | 0, b | 0, a | 0);\n        palette.add(color);\n      }\n    }\n    palette.sort();\n    yield {\n      palette,\n      progress: 100\n    };\n  }\n  *_preparePalette() {\n    yield* this._calculateMoments();\n    let next = 0;\n    const volumeVariance = createArray1D(this._colors);\n    for (let cubeIndex = 1; cubeIndex < this._colors; ++cubeIndex) {\n      if (this._cut(this._cubes[next], this._cubes[cubeIndex])) {\n        volumeVariance[next] = this._cubes[next].volume > 1 ? this._calculateVariance(this._cubes[next]) : 0;\n        volumeVariance[cubeIndex] = this._cubes[cubeIndex].volume > 1 ? this._calculateVariance(this._cubes[cubeIndex]) : 0;\n      } else {\n        volumeVariance[next] = 0;\n        cubeIndex--;\n      }\n      next = 0;\n      let temp = volumeVariance[0];\n      for (let index = 1; index <= cubeIndex; ++index) {\n        if (volumeVariance[index] > temp) {\n          temp = volumeVariance[index];\n          next = index;\n        }\n      }\n      if (temp <= 0) {\n        this._colors = cubeIndex + 1;\n        break;\n      }\n    }\n    const lookupRed = [];\n    const lookupGreen = [];\n    const lookupBlue = [];\n    const lookupAlpha = [];\n    for (let k = 0; k < this._colors; ++k) {\n      const weight = _WuQuant._volume(this._cubes[k], this._weights);\n      if (weight > 0) {\n        lookupRed[k] = _WuQuant._volume(this._cubes[k], this._momentsRed) / weight | 0;\n        lookupGreen[k] = _WuQuant._volume(this._cubes[k], this._momentsGreen) / weight | 0;\n        lookupBlue[k] = _WuQuant._volume(this._cubes[k], this._momentsBlue) / weight | 0;\n        lookupAlpha[k] = _WuQuant._volume(this._cubes[k], this._momentsAlpha) / weight | 0;\n      } else {\n        lookupRed[k] = 0;\n        lookupGreen[k] = 0;\n        lookupBlue[k] = 0;\n        lookupAlpha[k] = 0;\n      }\n    }\n    this._reds = createArray1D(this._colors + 1);\n    this._greens = createArray1D(this._colors + 1);\n    this._blues = createArray1D(this._colors + 1);\n    this._alphas = createArray1D(this._colors + 1);\n    this._sums = createArray1D(this._colors + 1);\n    for (let index = 0, l = this._pixels.length; index < l; index++) {\n      const color = this._pixels[index];\n      const match = -1;\n      let bestMatch = match;\n      let bestDistance = Number.MAX_VALUE;\n      for (let lookup = 0; lookup < this._colors; lookup++) {\n        const foundRed = lookupRed[lookup];\n        const foundGreen = lookupGreen[lookup];\n        const foundBlue = lookupBlue[lookup];\n        const foundAlpha = lookupAlpha[lookup];\n        const distance = this._distance.calculateRaw(foundRed, foundGreen, foundBlue, foundAlpha, color.r, color.g, color.b, color.a);\n        if (distance < bestDistance) {\n          bestDistance = distance;\n          bestMatch = lookup;\n        }\n      }\n      this._reds[bestMatch] += color.r;\n      this._greens[bestMatch] += color.g;\n      this._blues[bestMatch] += color.b;\n      this._alphas[bestMatch] += color.a;\n      this._sums[bestMatch]++;\n    }\n  }\n  _addColor(color) {\n    const bitsToRemove = 8 - this._significantBitsPerChannel;\n    const indexRed = (color.r >> bitsToRemove) + 1;\n    const indexGreen = (color.g >> bitsToRemove) + 1;\n    const indexBlue = (color.b >> bitsToRemove) + 1;\n    const indexAlpha = (color.a >> bitsToRemove) + 1;\n    this._weights[indexAlpha][indexRed][indexGreen][indexBlue]++;\n    this._momentsRed[indexAlpha][indexRed][indexGreen][indexBlue] += color.r;\n    this._momentsGreen[indexAlpha][indexRed][indexGreen][indexBlue] += color.g;\n    this._momentsBlue[indexAlpha][indexRed][indexGreen][indexBlue] += color.b;\n    this._momentsAlpha[indexAlpha][indexRed][indexGreen][indexBlue] += color.a;\n    this._moments[indexAlpha][indexRed][indexGreen][indexBlue] += this._table[color.r] + this._table[color.g] + this._table[color.b] + this._table[color.a];\n  }\n  *_calculateMoments() {\n    const area = [];\n    const areaRed = [];\n    const areaGreen = [];\n    const areaBlue = [];\n    const areaAlpha = [];\n    const area2 = [];\n    const xarea = createArray3D(this._sideSize, this._sideSize, this._sideSize);\n    const xareaRed = createArray3D(this._sideSize, this._sideSize, this._sideSize);\n    const xareaGreen = createArray3D(this._sideSize, this._sideSize, this._sideSize);\n    const xareaBlue = createArray3D(this._sideSize, this._sideSize, this._sideSize);\n    const xareaAlpha = createArray3D(this._sideSize, this._sideSize, this._sideSize);\n    const xarea2 = createArray3D(this._sideSize, this._sideSize, this._sideSize);\n    let trackerProgress = 0;\n    const tracker = new ProgressTracker(this._alphaMaxSideIndex * this._maxSideIndex, 99);\n    for (let alphaIndex = 1; alphaIndex <= this._alphaMaxSideIndex; ++alphaIndex) {\n      fillArray3D(xarea, this._sideSize, this._sideSize, this._sideSize, 0);\n      fillArray3D(xareaRed, this._sideSize, this._sideSize, this._sideSize, 0);\n      fillArray3D(xareaGreen, this._sideSize, this._sideSize, this._sideSize, 0);\n      fillArray3D(xareaBlue, this._sideSize, this._sideSize, this._sideSize, 0);\n      fillArray3D(xareaAlpha, this._sideSize, this._sideSize, this._sideSize, 0);\n      fillArray3D(xarea2, this._sideSize, this._sideSize, this._sideSize, 0);\n      for (let redIndex = 1; redIndex <= this._maxSideIndex; ++redIndex, ++trackerProgress) {\n        if (tracker.shouldNotify(trackerProgress)) {\n          yield {\n            progress: tracker.progress\n          };\n        }\n        fillArray1D(area, this._sideSize, 0);\n        fillArray1D(areaRed, this._sideSize, 0);\n        fillArray1D(areaGreen, this._sideSize, 0);\n        fillArray1D(areaBlue, this._sideSize, 0);\n        fillArray1D(areaAlpha, this._sideSize, 0);\n        fillArray1D(area2, this._sideSize, 0);\n        for (let greenIndex = 1; greenIndex <= this._maxSideIndex; ++greenIndex) {\n          let line = 0;\n          let lineRed = 0;\n          let lineGreen = 0;\n          let lineBlue = 0;\n          let lineAlpha = 0;\n          let line2 = 0;\n          for (let blueIndex = 1; blueIndex <= this._maxSideIndex; ++blueIndex) {\n            line += this._weights[alphaIndex][redIndex][greenIndex][blueIndex];\n            lineRed += this._momentsRed[alphaIndex][redIndex][greenIndex][blueIndex];\n            lineGreen += this._momentsGreen[alphaIndex][redIndex][greenIndex][blueIndex];\n            lineBlue += this._momentsBlue[alphaIndex][redIndex][greenIndex][blueIndex];\n            lineAlpha += this._momentsAlpha[alphaIndex][redIndex][greenIndex][blueIndex];\n            line2 += this._moments[alphaIndex][redIndex][greenIndex][blueIndex];\n            area[blueIndex] += line;\n            areaRed[blueIndex] += lineRed;\n            areaGreen[blueIndex] += lineGreen;\n            areaBlue[blueIndex] += lineBlue;\n            areaAlpha[blueIndex] += lineAlpha;\n            area2[blueIndex] += line2;\n            xarea[redIndex][greenIndex][blueIndex] = xarea[redIndex - 1][greenIndex][blueIndex] + area[blueIndex];\n            xareaRed[redIndex][greenIndex][blueIndex] = xareaRed[redIndex - 1][greenIndex][blueIndex] + areaRed[blueIndex];\n            xareaGreen[redIndex][greenIndex][blueIndex] = xareaGreen[redIndex - 1][greenIndex][blueIndex] + areaGreen[blueIndex];\n            xareaBlue[redIndex][greenIndex][blueIndex] = xareaBlue[redIndex - 1][greenIndex][blueIndex] + areaBlue[blueIndex];\n            xareaAlpha[redIndex][greenIndex][blueIndex] = xareaAlpha[redIndex - 1][greenIndex][blueIndex] + areaAlpha[blueIndex];\n            xarea2[redIndex][greenIndex][blueIndex] = xarea2[redIndex - 1][greenIndex][blueIndex] + area2[blueIndex];\n            this._weights[alphaIndex][redIndex][greenIndex][blueIndex] = this._weights[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xarea[redIndex][greenIndex][blueIndex];\n            this._momentsRed[alphaIndex][redIndex][greenIndex][blueIndex] = this._momentsRed[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xareaRed[redIndex][greenIndex][blueIndex];\n            this._momentsGreen[alphaIndex][redIndex][greenIndex][blueIndex] = this._momentsGreen[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xareaGreen[redIndex][greenIndex][blueIndex];\n            this._momentsBlue[alphaIndex][redIndex][greenIndex][blueIndex] = this._momentsBlue[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xareaBlue[redIndex][greenIndex][blueIndex];\n            this._momentsAlpha[alphaIndex][redIndex][greenIndex][blueIndex] = this._momentsAlpha[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xareaAlpha[redIndex][greenIndex][blueIndex];\n            this._moments[alphaIndex][redIndex][greenIndex][blueIndex] = this._moments[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xarea2[redIndex][greenIndex][blueIndex];\n          }\n        }\n      }\n    }\n  }\n  static _volumeFloat(cube, moment) {\n    return moment[cube.alphaMaximum][cube.redMaximum][cube.greenMaximum][cube.blueMaximum] - moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] - moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] - moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] - (moment[cube.alphaMaximum][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] - moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);\n  }\n  static _volume(cube, moment) {\n    return _WuQuant._volumeFloat(cube, moment) | 0;\n  }\n  static _top(cube, direction, position, moment) {\n    let result;\n    switch (direction) {\n      case _WuQuant._alpha:\n        result = moment[position][cube.redMaximum][cube.greenMaximum][cube.blueMaximum] - moment[position][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] - moment[position][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] + moment[position][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] - (moment[position][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] - moment[position][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] - moment[position][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] + moment[position][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);\n        break;\n      case _WuQuant._red:\n        result = moment[cube.alphaMaximum][position][cube.greenMaximum][cube.blueMaximum] - moment[cube.alphaMaximum][position][cube.greenMinimum][cube.blueMaximum] - moment[cube.alphaMinimum][position][cube.greenMaximum][cube.blueMaximum] + moment[cube.alphaMinimum][position][cube.greenMinimum][cube.blueMaximum] - (moment[cube.alphaMaximum][position][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMaximum][position][cube.greenMinimum][cube.blueMinimum] - moment[cube.alphaMinimum][position][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMinimum][position][cube.greenMinimum][cube.blueMinimum]);\n        break;\n      case _WuQuant._green:\n        result = moment[cube.alphaMaximum][cube.redMaximum][position][cube.blueMaximum] - moment[cube.alphaMaximum][cube.redMinimum][position][cube.blueMaximum] - moment[cube.alphaMinimum][cube.redMaximum][position][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMinimum][position][cube.blueMaximum] - (moment[cube.alphaMaximum][cube.redMaximum][position][cube.blueMinimum] - moment[cube.alphaMaximum][cube.redMinimum][position][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMaximum][position][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMinimum][position][cube.blueMinimum]);\n        break;\n      case _WuQuant._blue:\n        result = moment[cube.alphaMaximum][cube.redMaximum][cube.greenMaximum][position] - moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][position] - moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][position] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][position] - (moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][position] - moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][position] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][position] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][position]);\n        break;\n      default:\n        throw new Error(\"impossible\");\n    }\n    return result | 0;\n  }\n  static _bottom(cube, direction, moment) {\n    switch (direction) {\n      case _WuQuant._alpha:\n        return -moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] - (-moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);\n      case _WuQuant._red:\n        return -moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] - (-moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);\n      case _WuQuant._green:\n        return -moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] - (-moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);\n      case _WuQuant._blue:\n        return -moment[cube.alphaMaximum][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum] - (-moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);\n      default:\n        return 0;\n    }\n  }\n  _calculateVariance(cube) {\n    const volumeRed = _WuQuant._volume(cube, this._momentsRed);\n    const volumeGreen = _WuQuant._volume(cube, this._momentsGreen);\n    const volumeBlue = _WuQuant._volume(cube, this._momentsBlue);\n    const volumeAlpha = _WuQuant._volume(cube, this._momentsAlpha);\n    const volumeMoment = _WuQuant._volumeFloat(cube, this._moments);\n    const volumeWeight = _WuQuant._volume(cube, this._weights);\n    const distance = volumeRed * volumeRed + volumeGreen * volumeGreen + volumeBlue * volumeBlue + volumeAlpha * volumeAlpha;\n    return volumeMoment - distance / volumeWeight;\n  }\n  _maximize(cube, direction, first, last, wholeRed, wholeGreen, wholeBlue, wholeAlpha, wholeWeight) {\n    const bottomRed = _WuQuant._bottom(cube, direction, this._momentsRed) | 0;\n    const bottomGreen = _WuQuant._bottom(cube, direction, this._momentsGreen) | 0;\n    const bottomBlue = _WuQuant._bottom(cube, direction, this._momentsBlue) | 0;\n    const bottomAlpha = _WuQuant._bottom(cube, direction, this._momentsAlpha) | 0;\n    const bottomWeight = _WuQuant._bottom(cube, direction, this._weights) | 0;\n    let result = 0;\n    let cutPosition = -1;\n    for (let position = first; position < last; ++position) {\n      let halfRed = bottomRed + _WuQuant._top(cube, direction, position, this._momentsRed);\n      let halfGreen = bottomGreen + _WuQuant._top(cube, direction, position, this._momentsGreen);\n      let halfBlue = bottomBlue + _WuQuant._top(cube, direction, position, this._momentsBlue);\n      let halfAlpha = bottomAlpha + _WuQuant._top(cube, direction, position, this._momentsAlpha);\n      let halfWeight = bottomWeight + _WuQuant._top(cube, direction, position, this._weights);\n      if (halfWeight !== 0) {\n        let halfDistance = halfRed * halfRed + halfGreen * halfGreen + halfBlue * halfBlue + halfAlpha * halfAlpha;\n        let temp = halfDistance / halfWeight;\n        halfRed = wholeRed - halfRed;\n        halfGreen = wholeGreen - halfGreen;\n        halfBlue = wholeBlue - halfBlue;\n        halfAlpha = wholeAlpha - halfAlpha;\n        halfWeight = wholeWeight - halfWeight;\n        if (halfWeight !== 0) {\n          halfDistance = halfRed * halfRed + halfGreen * halfGreen + halfBlue * halfBlue + halfAlpha * halfAlpha;\n          temp += halfDistance / halfWeight;\n          if (temp > result) {\n            result = temp;\n            cutPosition = position;\n          }\n        }\n      }\n    }\n    return { max: result, position: cutPosition };\n  }\n  _cut(first, second) {\n    let direction;\n    const wholeRed = _WuQuant._volume(first, this._momentsRed);\n    const wholeGreen = _WuQuant._volume(first, this._momentsGreen);\n    const wholeBlue = _WuQuant._volume(first, this._momentsBlue);\n    const wholeAlpha = _WuQuant._volume(first, this._momentsAlpha);\n    const wholeWeight = _WuQuant._volume(first, this._weights);\n    const red = this._maximize(first, _WuQuant._red, first.redMinimum + 1, first.redMaximum, wholeRed, wholeGreen, wholeBlue, wholeAlpha, wholeWeight);\n    const green = this._maximize(first, _WuQuant._green, first.greenMinimum + 1, first.greenMaximum, wholeRed, wholeGreen, wholeBlue, wholeAlpha, wholeWeight);\n    const blue = this._maximize(first, _WuQuant._blue, first.blueMinimum + 1, first.blueMaximum, wholeRed, wholeGreen, wholeBlue, wholeAlpha, wholeWeight);\n    const alpha = this._maximize(first, _WuQuant._alpha, first.alphaMinimum + 1, first.alphaMaximum, wholeRed, wholeGreen, wholeBlue, wholeAlpha, wholeWeight);\n    if (alpha.max >= red.max && alpha.max >= green.max && alpha.max >= blue.max) {\n      direction = _WuQuant._alpha;\n      if (alpha.position < 0)\n        return false;\n    } else if (red.max >= alpha.max && red.max >= green.max && red.max >= blue.max) {\n      direction = _WuQuant._red;\n    } else if (green.max >= alpha.max && green.max >= red.max && green.max >= blue.max) {\n      direction = _WuQuant._green;\n    } else {\n      direction = _WuQuant._blue;\n    }\n    second.redMaximum = first.redMaximum;\n    second.greenMaximum = first.greenMaximum;\n    second.blueMaximum = first.blueMaximum;\n    second.alphaMaximum = first.alphaMaximum;\n    switch (direction) {\n      case _WuQuant._red:\n        second.redMinimum = first.redMaximum = red.position;\n        second.greenMinimum = first.greenMinimum;\n        second.blueMinimum = first.blueMinimum;\n        second.alphaMinimum = first.alphaMinimum;\n        break;\n      case _WuQuant._green:\n        second.greenMinimum = first.greenMaximum = green.position;\n        second.redMinimum = first.redMinimum;\n        second.blueMinimum = first.blueMinimum;\n        second.alphaMinimum = first.alphaMinimum;\n        break;\n      case _WuQuant._blue:\n        second.blueMinimum = first.blueMaximum = blue.position;\n        second.redMinimum = first.redMinimum;\n        second.greenMinimum = first.greenMinimum;\n        second.alphaMinimum = first.alphaMinimum;\n        break;\n      case _WuQuant._alpha:\n        second.alphaMinimum = first.alphaMaximum = alpha.position;\n        second.blueMinimum = first.blueMinimum;\n        second.redMinimum = first.redMinimum;\n        second.greenMinimum = first.greenMinimum;\n        break;\n    }\n    first.volume = (first.redMaximum - first.redMinimum) * (first.greenMaximum - first.greenMinimum) * (first.blueMaximum - first.blueMinimum) * (first.alphaMaximum - first.alphaMinimum);\n    second.volume = (second.redMaximum - second.redMinimum) * (second.greenMaximum - second.greenMinimum) * (second.blueMaximum - second.blueMinimum) * (second.alphaMaximum - second.alphaMinimum);\n    return true;\n  }\n  _initialize(colors) {\n    this._colors = colors;\n    this._cubes = [];\n    for (let cubeIndex = 0; cubeIndex < colors; cubeIndex++) {\n      this._cubes[cubeIndex] = new WuColorCube();\n    }\n    this._cubes[0].redMinimum = 0;\n    this._cubes[0].greenMinimum = 0;\n    this._cubes[0].blueMinimum = 0;\n    this._cubes[0].alphaMinimum = 0;\n    this._cubes[0].redMaximum = this._maxSideIndex;\n    this._cubes[0].greenMaximum = this._maxSideIndex;\n    this._cubes[0].blueMaximum = this._maxSideIndex;\n    this._cubes[0].alphaMaximum = this._alphaMaxSideIndex;\n    this._weights = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize);\n    this._momentsRed = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize);\n    this._momentsGreen = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize);\n    this._momentsBlue = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize);\n    this._momentsAlpha = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize);\n    this._moments = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize);\n    this._table = [];\n    for (let tableIndex = 0; tableIndex < 256; ++tableIndex) {\n      this._table[tableIndex] = tableIndex * tableIndex;\n    }\n    this._pixels = [];\n  }\n  _setQuality(significantBitsPerChannel = 5) {\n    this._significantBitsPerChannel = significantBitsPerChannel;\n    this._maxSideIndex = 1 << this._significantBitsPerChannel;\n    this._alphaMaxSideIndex = this._maxSideIndex;\n    this._sideSize = this._maxSideIndex + 1;\n    this._alphaSideSize = this._alphaMaxSideIndex + 1;\n  }\n};\nvar WuQuant = _WuQuant;\n__publicField(WuQuant, \"_alpha\", 3);\n__publicField(WuQuant, \"_red\", 2);\n__publicField(WuQuant, \"_green\", 1);\n__publicField(WuQuant, \"_blue\", 0);\n\n// src/image/index.ts\nvar image_exports = {};\n__export(image_exports, {\n  AbstractImageQuantizer: () => AbstractImageQuantizer,\n  ErrorDiffusionArray: () => ErrorDiffusionArray,\n  ErrorDiffusionArrayKernel: () => ErrorDiffusionArrayKernel,\n  ErrorDiffusionRiemersma: () => ErrorDiffusionRiemersma,\n  NearestColor: () => NearestColor\n});\n\n// src/image/imageQuantizer.ts\nvar AbstractImageQuantizer = class {\n  quantizeSync(pointContainer, palette) {\n    for (const value of this.quantize(pointContainer, palette)) {\n      if (value.pointContainer) {\n        return value.pointContainer;\n      }\n    }\n    throw new Error(\"unreachable\");\n  }\n};\n\n// src/image/nearestColor.ts\nvar NearestColor = class extends AbstractImageQuantizer {\n  constructor(colorDistanceCalculator) {\n    super();\n    __publicField(this, \"_distance\");\n    this._distance = colorDistanceCalculator;\n  }\n  *quantize(pointContainer, palette) {\n    const pointArray = pointContainer.getPointArray();\n    const width = pointContainer.getWidth();\n    const height = pointContainer.getHeight();\n    const tracker = new ProgressTracker(height, 99);\n    for (let y2 = 0; y2 < height; y2++) {\n      if (tracker.shouldNotify(y2)) {\n        yield {\n          progress: tracker.progress\n        };\n      }\n      for (let x2 = 0, idx = y2 * width; x2 < width; x2++, idx++) {\n        const point = pointArray[idx];\n        point.from(palette.getNearestColor(this._distance, point));\n      }\n    }\n    yield {\n      pointContainer,\n      progress: 100\n    };\n  }\n};\n\n// src/image/array.ts\nvar ErrorDiffusionArrayKernel = /* @__PURE__ */ ((ErrorDiffusionArrayKernel2) => {\n  ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2[\"FloydSteinberg\"] = 0] = \"FloydSteinberg\";\n  ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2[\"FalseFloydSteinberg\"] = 1] = \"FalseFloydSteinberg\";\n  ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2[\"Stucki\"] = 2] = \"Stucki\";\n  ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2[\"Atkinson\"] = 3] = \"Atkinson\";\n  ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2[\"Jarvis\"] = 4] = \"Jarvis\";\n  ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2[\"Burkes\"] = 5] = \"Burkes\";\n  ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2[\"Sierra\"] = 6] = \"Sierra\";\n  ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2[\"TwoSierra\"] = 7] = \"TwoSierra\";\n  ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2[\"SierraLite\"] = 8] = \"SierraLite\";\n  return ErrorDiffusionArrayKernel2;\n})(ErrorDiffusionArrayKernel || {});\nvar ErrorDiffusionArray = class extends AbstractImageQuantizer {\n  constructor(colorDistanceCalculator, kernel, serpentine = true, minimumColorDistanceToDither = 0, calculateErrorLikeGIMP = false) {\n    super();\n    __publicField(this, \"_minColorDistance\");\n    __publicField(this, \"_serpentine\");\n    __publicField(this, \"_kernel\");\n    __publicField(this, \"_calculateErrorLikeGIMP\");\n    __publicField(this, \"_distance\");\n    this._setKernel(kernel);\n    this._distance = colorDistanceCalculator;\n    this._minColorDistance = minimumColorDistanceToDither;\n    this._serpentine = serpentine;\n    this._calculateErrorLikeGIMP = calculateErrorLikeGIMP;\n  }\n  *quantize(pointContainer, palette) {\n    const pointArray = pointContainer.getPointArray();\n    const originalPoint = new Point();\n    const width = pointContainer.getWidth();\n    const height = pointContainer.getHeight();\n    const errorLines = [];\n    let dir = 1;\n    let maxErrorLines = 1;\n    for (const kernel of this._kernel) {\n      const kernelErrorLines = kernel[2] + 1;\n      if (maxErrorLines < kernelErrorLines)\n        maxErrorLines = kernelErrorLines;\n    }\n    for (let i = 0; i < maxErrorLines; i++) {\n      this._fillErrorLine(errorLines[i] = [], width);\n    }\n    const tracker = new ProgressTracker(height, 99);\n    for (let y2 = 0; y2 < height; y2++) {\n      if (tracker.shouldNotify(y2)) {\n        yield {\n          progress: tracker.progress\n        };\n      }\n      if (this._serpentine)\n        dir *= -1;\n      const lni = y2 * width;\n      const xStart = dir === 1 ? 0 : width - 1;\n      const xEnd = dir === 1 ? width : -1;\n      this._fillErrorLine(errorLines[0], width);\n      errorLines.push(errorLines.shift());\n      const errorLine = errorLines[0];\n      for (let x2 = xStart, idx = lni + xStart; x2 !== xEnd; x2 += dir, idx += dir) {\n        const point = pointArray[idx];\n        const error = errorLine[x2];\n        originalPoint.from(point);\n        const correctedPoint = Point.createByRGBA(inRange0to255Rounded(point.r + error[0]), inRange0to255Rounded(point.g + error[1]), inRange0to255Rounded(point.b + error[2]), inRange0to255Rounded(point.a + error[3]));\n        const palettePoint = palette.getNearestColor(this._distance, correctedPoint);\n        point.from(palettePoint);\n        if (this._minColorDistance) {\n          const dist = this._distance.calculateNormalized(originalPoint, palettePoint);\n          if (dist < this._minColorDistance)\n            continue;\n        }\n        let er;\n        let eg;\n        let eb;\n        let ea;\n        if (this._calculateErrorLikeGIMP) {\n          er = correctedPoint.r - palettePoint.r;\n          eg = correctedPoint.g - palettePoint.g;\n          eb = correctedPoint.b - palettePoint.b;\n          ea = correctedPoint.a - palettePoint.a;\n        } else {\n          er = originalPoint.r - palettePoint.r;\n          eg = originalPoint.g - palettePoint.g;\n          eb = originalPoint.b - palettePoint.b;\n          ea = originalPoint.a - palettePoint.a;\n        }\n        const dStart = dir === 1 ? 0 : this._kernel.length - 1;\n        const dEnd = dir === 1 ? this._kernel.length : -1;\n        for (let i = dStart; i !== dEnd; i += dir) {\n          const x1 = this._kernel[i][1] * dir;\n          const y1 = this._kernel[i][2];\n          if (x1 + x2 >= 0 && x1 + x2 < width && y1 + y2 >= 0 && y1 + y2 < height) {\n            const d = this._kernel[i][0];\n            const e = errorLines[y1][x1 + x2];\n            e[0] += er * d;\n            e[1] += eg * d;\n            e[2] += eb * d;\n            e[3] += ea * d;\n          }\n        }\n      }\n    }\n    yield {\n      pointContainer,\n      progress: 100\n    };\n  }\n  _fillErrorLine(errorLine, width) {\n    if (errorLine.length > width) {\n      errorLine.length = width;\n    }\n    const l = errorLine.length;\n    for (let i = 0; i < l; i++) {\n      const error = errorLine[i];\n      error[0] = error[1] = error[2] = error[3] = 0;\n    }\n    for (let i = l; i < width; i++) {\n      errorLine[i] = [0, 0, 0, 0];\n    }\n  }\n  _setKernel(kernel) {\n    switch (kernel) {\n      case 0 /* FloydSteinberg */:\n        this._kernel = [\n          [7 / 16, 1, 0],\n          [3 / 16, -1, 1],\n          [5 / 16, 0, 1],\n          [1 / 16, 1, 1]\n        ];\n        break;\n      case 1 /* FalseFloydSteinberg */:\n        this._kernel = [\n          [3 / 8, 1, 0],\n          [3 / 8, 0, 1],\n          [2 / 8, 1, 1]\n        ];\n        break;\n      case 2 /* Stucki */:\n        this._kernel = [\n          [8 / 42, 1, 0],\n          [4 / 42, 2, 0],\n          [2 / 42, -2, 1],\n          [4 / 42, -1, 1],\n          [8 / 42, 0, 1],\n          [4 / 42, 1, 1],\n          [2 / 42, 2, 1],\n          [1 / 42, -2, 2],\n          [2 / 42, -1, 2],\n          [4 / 42, 0, 2],\n          [2 / 42, 1, 2],\n          [1 / 42, 2, 2]\n        ];\n        break;\n      case 3 /* Atkinson */:\n        this._kernel = [\n          [1 / 8, 1, 0],\n          [1 / 8, 2, 0],\n          [1 / 8, -1, 1],\n          [1 / 8, 0, 1],\n          [1 / 8, 1, 1],\n          [1 / 8, 0, 2]\n        ];\n        break;\n      case 4 /* Jarvis */:\n        this._kernel = [\n          [7 / 48, 1, 0],\n          [5 / 48, 2, 0],\n          [3 / 48, -2, 1],\n          [5 / 48, -1, 1],\n          [7 / 48, 0, 1],\n          [5 / 48, 1, 1],\n          [3 / 48, 2, 1],\n          [1 / 48, -2, 2],\n          [3 / 48, -1, 2],\n          [5 / 48, 0, 2],\n          [3 / 48, 1, 2],\n          [1 / 48, 2, 2]\n        ];\n        break;\n      case 5 /* Burkes */:\n        this._kernel = [\n          [8 / 32, 1, 0],\n          [4 / 32, 2, 0],\n          [2 / 32, -2, 1],\n          [4 / 32, -1, 1],\n          [8 / 32, 0, 1],\n          [4 / 32, 1, 1],\n          [2 / 32, 2, 1]\n        ];\n        break;\n      case 6 /* Sierra */:\n        this._kernel = [\n          [5 / 32, 1, 0],\n          [3 / 32, 2, 0],\n          [2 / 32, -2, 1],\n          [4 / 32, -1, 1],\n          [5 / 32, 0, 1],\n          [4 / 32, 1, 1],\n          [2 / 32, 2, 1],\n          [2 / 32, -1, 2],\n          [3 / 32, 0, 2],\n          [2 / 32, 1, 2]\n        ];\n        break;\n      case 7 /* TwoSierra */:\n        this._kernel = [\n          [4 / 16, 1, 0],\n          [3 / 16, 2, 0],\n          [1 / 16, -2, 1],\n          [2 / 16, -1, 1],\n          [3 / 16, 0, 1],\n          [2 / 16, 1, 1],\n          [1 / 16, 2, 1]\n        ];\n        break;\n      case 8 /* SierraLite */:\n        this._kernel = [\n          [2 / 4, 1, 0],\n          [1 / 4, -1, 1],\n          [1 / 4, 0, 1]\n        ];\n        break;\n      default:\n        throw new Error(`ErrorDiffusionArray: unknown kernel = ${kernel}`);\n    }\n  }\n};\n\n// src/image/spaceFillingCurves/hilbertCurve.ts\nfunction* hilbertCurve(width, height, callback) {\n  const maxBound = Math.max(width, height);\n  const level = Math.floor(Math.log(maxBound) / Math.log(2) + 1);\n  const tracker = new ProgressTracker(width * height, 99);\n  const data = {\n    width,\n    height,\n    level,\n    callback,\n    tracker,\n    index: 0,\n    x: 0,\n    y: 0\n  };\n  yield* walkHilbert(data, 1 /* UP */);\n  visit(data, 0 /* NONE */);\n}\nfunction* walkHilbert(data, direction) {\n  if (data.level < 1)\n    return;\n  if (data.tracker.shouldNotify(data.index)) {\n    yield { progress: data.tracker.progress };\n  }\n  data.level--;\n  switch (direction) {\n    case 2 /* LEFT */:\n      yield* walkHilbert(data, 1 /* UP */);\n      visit(data, 3 /* RIGHT */);\n      yield* walkHilbert(data, 2 /* LEFT */);\n      visit(data, 4 /* DOWN */);\n      yield* walkHilbert(data, 2 /* LEFT */);\n      visit(data, 2 /* LEFT */);\n      yield* walkHilbert(data, 4 /* DOWN */);\n      break;\n    case 3 /* RIGHT */:\n      yield* walkHilbert(data, 4 /* DOWN */);\n      visit(data, 2 /* LEFT */);\n      yield* walkHilbert(data, 3 /* RIGHT */);\n      visit(data, 1 /* UP */);\n      yield* walkHilbert(data, 3 /* RIGHT */);\n      visit(data, 3 /* RIGHT */);\n      yield* walkHilbert(data, 1 /* UP */);\n      break;\n    case 1 /* UP */:\n      yield* walkHilbert(data, 2 /* LEFT */);\n      visit(data, 4 /* DOWN */);\n      yield* walkHilbert(data, 1 /* UP */);\n      visit(data, 3 /* RIGHT */);\n      yield* walkHilbert(data, 1 /* UP */);\n      visit(data, 1 /* UP */);\n      yield* walkHilbert(data, 3 /* RIGHT */);\n      break;\n    case 4 /* DOWN */:\n      yield* walkHilbert(data, 3 /* RIGHT */);\n      visit(data, 1 /* UP */);\n      yield* walkHilbert(data, 4 /* DOWN */);\n      visit(data, 2 /* LEFT */);\n      yield* walkHilbert(data, 4 /* DOWN */);\n      visit(data, 4 /* DOWN */);\n      yield* walkHilbert(data, 2 /* LEFT */);\n      break;\n    default:\n      break;\n  }\n  data.level++;\n}\nfunction visit(data, direction) {\n  if (data.x >= 0 && data.x < data.width && data.y >= 0 && data.y < data.height) {\n    data.callback(data.x, data.y);\n    data.index++;\n  }\n  switch (direction) {\n    case 2 /* LEFT */:\n      data.x--;\n      break;\n    case 3 /* RIGHT */:\n      data.x++;\n      break;\n    case 1 /* UP */:\n      data.y--;\n      break;\n    case 4 /* DOWN */:\n      data.y++;\n      break;\n  }\n}\n\n// src/image/riemersma.ts\nvar ErrorDiffusionRiemersma = class extends AbstractImageQuantizer {\n  constructor(colorDistanceCalculator, errorQueueSize = 16, errorPropagation = 1) {\n    super();\n    __publicField(this, \"_distance\");\n    __publicField(this, \"_weights\");\n    __publicField(this, \"_errorQueueSize\");\n    this._distance = colorDistanceCalculator;\n    this._errorQueueSize = errorQueueSize;\n    this._weights = ErrorDiffusionRiemersma._createWeights(errorPropagation, errorQueueSize);\n  }\n  *quantize(pointContainer, palette) {\n    const pointArray = pointContainer.getPointArray();\n    const width = pointContainer.getWidth();\n    const height = pointContainer.getHeight();\n    const errorQueue = [];\n    let head = 0;\n    for (let i = 0; i < this._errorQueueSize; i++) {\n      errorQueue[i] = { r: 0, g: 0, b: 0, a: 0 };\n    }\n    yield* hilbertCurve(width, height, (x2, y2) => {\n      const p = pointArray[x2 + y2 * width];\n      let { r, g, b, a } = p;\n      for (let i = 0; i < this._errorQueueSize; i++) {\n        const weight = this._weights[i];\n        const e = errorQueue[(i + head) % this._errorQueueSize];\n        r += e.r * weight;\n        g += e.g * weight;\n        b += e.b * weight;\n        a += e.a * weight;\n      }\n      const correctedPoint = Point.createByRGBA(inRange0to255Rounded(r), inRange0to255Rounded(g), inRange0to255Rounded(b), inRange0to255Rounded(a));\n      const quantizedPoint = palette.getNearestColor(this._distance, correctedPoint);\n      head = (head + 1) % this._errorQueueSize;\n      const tail = (head + this._errorQueueSize - 1) % this._errorQueueSize;\n      errorQueue[tail].r = p.r - quantizedPoint.r;\n      errorQueue[tail].g = p.g - quantizedPoint.g;\n      errorQueue[tail].b = p.b - quantizedPoint.b;\n      errorQueue[tail].a = p.a - quantizedPoint.a;\n      p.from(quantizedPoint);\n    });\n    yield {\n      pointContainer,\n      progress: 100\n    };\n  }\n  static _createWeights(errorPropagation, errorQueueSize) {\n    const weights = [];\n    const multiplier = Math.exp(Math.log(errorQueueSize) / (errorQueueSize - 1));\n    for (let i = 0, next = 1; i < errorQueueSize; i++) {\n      weights[i] = (next + 0.5 | 0) / errorQueueSize * errorPropagation;\n      next *= multiplier;\n    }\n    return weights;\n  }\n};\n\n// src/quality/index.ts\nvar quality_exports = {};\n__export(quality_exports, {\n  ssim: () => ssim\n});\n\n// src/quality/ssim.ts\nvar K1 = 0.01;\nvar K2 = 0.03;\nfunction ssim(image1, image2) {\n  if (image1.getHeight() !== image2.getHeight() || image1.getWidth() !== image2.getWidth()) {\n    throw new Error(\"Images have different sizes!\");\n  }\n  const bitsPerComponent = 8;\n  const L = (1 << bitsPerComponent) - 1;\n  const c1 = (K1 * L) ** 2;\n  const c2 = (K2 * L) ** 2;\n  let numWindows = 0;\n  let mssim = 0;\n  iterate(image1, image2, (lumaValues1, lumaValues2, averageLumaValue1, averageLumaValue2) => {\n    let sigxy = 0;\n    let sigsqx = 0;\n    let sigsqy = 0;\n    for (let i = 0; i < lumaValues1.length; i++) {\n      sigsqx += (lumaValues1[i] - averageLumaValue1) ** 2;\n      sigsqy += (lumaValues2[i] - averageLumaValue2) ** 2;\n      sigxy += (lumaValues1[i] - averageLumaValue1) * (lumaValues2[i] - averageLumaValue2);\n    }\n    const numPixelsInWin = lumaValues1.length - 1;\n    sigsqx /= numPixelsInWin;\n    sigsqy /= numPixelsInWin;\n    sigxy /= numPixelsInWin;\n    const numerator = (2 * averageLumaValue1 * averageLumaValue2 + c1) * (2 * sigxy + c2);\n    const denominator = (averageLumaValue1 ** 2 + averageLumaValue2 ** 2 + c1) * (sigsqx + sigsqy + c2);\n    const ssim2 = numerator / denominator;\n    mssim += ssim2;\n    numWindows++;\n  });\n  return mssim / numWindows;\n}\nfunction iterate(image1, image2, callback) {\n  const windowSize = 8;\n  const width = image1.getWidth();\n  const height = image1.getHeight();\n  for (let y2 = 0; y2 < height; y2 += windowSize) {\n    for (let x2 = 0; x2 < width; x2 += windowSize) {\n      const windowWidth = Math.min(windowSize, width - x2);\n      const windowHeight = Math.min(windowSize, height - y2);\n      const lumaValues1 = calculateLumaValuesForWindow(image1, x2, y2, windowWidth, windowHeight);\n      const lumaValues2 = calculateLumaValuesForWindow(image2, x2, y2, windowWidth, windowHeight);\n      const averageLuma1 = calculateAverageLuma(lumaValues1);\n      const averageLuma2 = calculateAverageLuma(lumaValues2);\n      callback(lumaValues1, lumaValues2, averageLuma1, averageLuma2);\n    }\n  }\n}\nfunction calculateLumaValuesForWindow(image, x2, y2, width, height) {\n  const pointArray = image.getPointArray();\n  const lumaValues = [];\n  let counter = 0;\n  for (let j = y2; j < y2 + height; j++) {\n    const offset = j * image.getWidth();\n    for (let i = x2; i < x2 + width; i++) {\n      const point = pointArray[offset + i];\n      lumaValues[counter] = point.r * 0.2126 /* RED */ + point.g * 0.7152 /* GREEN */ + point.b * 0.0722 /* BLUE */;\n      counter++;\n    }\n  }\n  return lumaValues;\n}\nfunction calculateAverageLuma(lumaValues) {\n  let sumLuma = 0;\n  for (const luma of lumaValues) {\n    sumLuma += luma;\n  }\n  return sumLuma / lumaValues.length;\n}\n\n// src/basicAPI.ts\nvar setImmediateImpl = typeof setImmediate === \"function\" ? setImmediate : typeof process !== \"undefined\" && typeof (process == null ? void 0 : process.nextTick) === \"function\" ? (callback) => process.nextTick(callback) : (callback) => setTimeout(callback, 0);\nfunction buildPaletteSync(images, {\n  colorDistanceFormula,\n  paletteQuantization,\n  colors\n} = {}) {\n  const distanceCalculator = colorDistanceFormulaToColorDistance(colorDistanceFormula);\n  const paletteQuantizer = paletteQuantizationToPaletteQuantizer(distanceCalculator, paletteQuantization, colors);\n  images.forEach((image) => paletteQuantizer.sample(image));\n  return paletteQuantizer.quantizeSync();\n}\nasync function buildPalette(images, {\n  colorDistanceFormula,\n  paletteQuantization,\n  colors,\n  onProgress\n} = {}) {\n  return new Promise((resolve, reject) => {\n    const distanceCalculator = colorDistanceFormulaToColorDistance(colorDistanceFormula);\n    const paletteQuantizer = paletteQuantizationToPaletteQuantizer(distanceCalculator, paletteQuantization, colors);\n    images.forEach((image) => paletteQuantizer.sample(image));\n    let palette;\n    const iterator = paletteQuantizer.quantize();\n    const next = () => {\n      try {\n        const result = iterator.next();\n        if (result.done) {\n          resolve(palette);\n        } else {\n          if (result.value.palette)\n            palette = result.value.palette;\n          if (onProgress)\n            onProgress(result.value.progress);\n          setImmediateImpl(next);\n        }\n      } catch (error) {\n        reject(error);\n      }\n    };\n    setImmediateImpl(next);\n  });\n}\nfunction applyPaletteSync(image, palette, { colorDistanceFormula, imageQuantization } = {}) {\n  const distanceCalculator = colorDistanceFormulaToColorDistance(colorDistanceFormula);\n  const imageQuantizer = imageQuantizationToImageQuantizer(distanceCalculator, imageQuantization);\n  return imageQuantizer.quantizeSync(image, palette);\n}\nasync function applyPalette(image, palette, {\n  colorDistanceFormula,\n  imageQuantization,\n  onProgress\n} = {}) {\n  return new Promise((resolve, reject) => {\n    const distanceCalculator = colorDistanceFormulaToColorDistance(colorDistanceFormula);\n    const imageQuantizer = imageQuantizationToImageQuantizer(distanceCalculator, imageQuantization);\n    let outPointContainer;\n    const iterator = imageQuantizer.quantize(image, palette);\n    const next = () => {\n      try {\n        const result = iterator.next();\n        if (result.done) {\n          resolve(outPointContainer);\n        } else {\n          if (result.value.pointContainer) {\n            outPointContainer = result.value.pointContainer;\n          }\n          if (onProgress)\n            onProgress(result.value.progress);\n          setImmediateImpl(next);\n        }\n      } catch (error) {\n        reject(error);\n      }\n    };\n    setImmediateImpl(next);\n  });\n}\nfunction colorDistanceFormulaToColorDistance(colorDistanceFormula = \"euclidean-bt709\") {\n  switch (colorDistanceFormula) {\n    case \"cie94-graphic-arts\":\n      return new CIE94GraphicArts();\n    case \"cie94-textiles\":\n      return new CIE94Textiles();\n    case \"ciede2000\":\n      return new CIEDE2000();\n    case \"color-metric\":\n      return new CMetric();\n    case \"euclidean\":\n      return new Euclidean();\n    case \"euclidean-bt709\":\n      return new EuclideanBT709();\n    case \"euclidean-bt709-noalpha\":\n      return new EuclideanBT709NoAlpha();\n    case \"manhattan\":\n      return new Manhattan();\n    case \"manhattan-bt709\":\n      return new ManhattanBT709();\n    case \"manhattan-nommyde\":\n      return new ManhattanNommyde();\n    case \"pngquant\":\n      return new PNGQuant();\n    default:\n      throw new Error(`Unknown colorDistanceFormula ${colorDistanceFormula}`);\n  }\n}\nfunction imageQuantizationToImageQuantizer(distanceCalculator, imageQuantization = \"floyd-steinberg\") {\n  switch (imageQuantization) {\n    case \"nearest\":\n      return new NearestColor(distanceCalculator);\n    case \"riemersma\":\n      return new ErrorDiffusionRiemersma(distanceCalculator);\n    case \"floyd-steinberg\":\n      return new ErrorDiffusionArray(distanceCalculator, 0 /* FloydSteinberg */);\n    case \"false-floyd-steinberg\":\n      return new ErrorDiffusionArray(distanceCalculator, 1 /* FalseFloydSteinberg */);\n    case \"stucki\":\n      return new ErrorDiffusionArray(distanceCalculator, 2 /* Stucki */);\n    case \"atkinson\":\n      return new ErrorDiffusionArray(distanceCalculator, 3 /* Atkinson */);\n    case \"jarvis\":\n      return new ErrorDiffusionArray(distanceCalculator, 4 /* Jarvis */);\n    case \"burkes\":\n      return new ErrorDiffusionArray(distanceCalculator, 5 /* Burkes */);\n    case \"sierra\":\n      return new ErrorDiffusionArray(distanceCalculator, 6 /* Sierra */);\n    case \"two-sierra\":\n      return new ErrorDiffusionArray(distanceCalculator, 7 /* TwoSierra */);\n    case \"sierra-lite\":\n      return new ErrorDiffusionArray(distanceCalculator, 8 /* SierraLite */);\n    default:\n      throw new Error(`Unknown imageQuantization ${imageQuantization}`);\n  }\n}\nfunction paletteQuantizationToPaletteQuantizer(distanceCalculator, paletteQuantization = \"wuquant\", colors = 256) {\n  switch (paletteQuantization) {\n    case \"neuquant\":\n      return new NeuQuant(distanceCalculator, colors);\n    case \"rgbquant\":\n      return new RGBQuant(distanceCalculator, colors);\n    case \"wuquant\":\n      return new WuQuant(distanceCalculator, colors);\n    case \"neuquant-float\":\n      return new NeuQuantFloat(distanceCalculator, colors);\n    default:\n      throw new Error(`Unknown paletteQuantization ${paletteQuantization}`);\n  }\n}\nmodule.exports = __toCommonJS(src_exports);\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * cie94.ts - part of Image Quantization Library\n */\n/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * ciede2000.ts - part of Image Quantization Library\n */\n/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * cmetric.ts - part of Image Quantization Library\n */\n/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * common.ts - part of Image Quantization Library\n */\n/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * constants.ts - part of Image Quantization Library\n */\n/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * ditherErrorDiffusionArray.ts - part of Image Quantization Library\n */\n/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * euclidean.ts - part of Image Quantization Library\n */\n/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * helper.ts - part of Image Quantization Library\n */\n/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * hueStatistics.ts - part of Image Quantization Library\n */\n/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * iq.ts - Image Quantization Library\n */\n/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * lab2rgb.ts - part of Image Quantization Library\n */\n/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * lab2xyz.ts - part of Image Quantization Library\n */\n/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * manhattanNeuQuant.ts - part of Image Quantization Library\n */\n/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * nearestColor.ts - part of Image Quantization Library\n */\n/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * palette.ts - part of Image Quantization Library\n */\n/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * pngQuant.ts - part of Image Quantization Library\n */\n/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * point.ts - part of Image Quantization Library\n */\n/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * pointContainer.ts - part of Image Quantization Library\n */\n/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * rgb2hsl.ts - part of Image Quantization Library\n */\n/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * rgb2lab.ts - part of Image Quantization Library\n */\n/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * rgb2xyz.ts - part of Image Quantization Library\n */\n/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * ssim.ts - part of Image Quantization Library\n */\n/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * wuQuant.ts - part of Image Quantization Library\n */\n/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * xyz2lab.ts - part of Image Quantization Library\n */\n/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * xyz2rgb.ts - part of Image Quantization Library\n */\n/**\n * @preserve\n * MIT License\n *\n * Copyright 2015-2018 Igor Bezkrovnyi\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n * IN THE SOFTWARE.\n *\n * riemersma.ts - part of Image Quantization Library\n */\n/**\n * @preserve TypeScript port:\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * colorHistogram.ts - part of Image Quantization Library\n */\n/**\n * @preserve TypeScript port:\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * neuquant.ts - part of Image Quantization Library\n */\n/**\n * @preserve TypeScript port:\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * rgbquant.ts - part of Image Quantization Library\n */\n//# sourceMappingURL=image-q.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2ltYWdlLXFANC4wLjAvbm9kZV9tb2R1bGVzL2ltYWdlLXEvZGlzdC9janMvaW1hZ2UtcS5janMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsNkRBQTZEO0FBQzNJLG1FQUFtRSxhQUFhO0FBQ2hGO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsa0dBQWtHO0FBQ25JO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEU7QUFDOUU7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLFNBQVM7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLFNBQVM7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLFNBQVM7O0FBRVY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsT0FBTztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsT0FBTztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsT0FBTztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLG9CQUFvQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLFFBQVE7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxPQUFPO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsdUJBQXVCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLG9CQUFvQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFNBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix1QkFBdUI7QUFDM0M7QUFDQSwyREFBMkQsWUFBWTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHVCQUF1QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxvQkFBb0I7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixTQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsdUJBQXVCO0FBQzNDO0FBQ0EsMkRBQTJELGdCQUFnQjtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixhQUFhO0FBQ2xDLHVCQUF1QixZQUFZO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsU0FBUztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFNBQVM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGlCQUFpQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBLHNCQUFzQixnQkFBZ0I7QUFDdEM7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixnQkFBZ0I7QUFDbEM7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0Esc0JBQXNCLGdCQUFnQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixnQkFBZ0I7QUFDbEM7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0Esc0JBQXNCLGdCQUFnQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLE9BQU87QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsNkJBQTZCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsMEJBQTBCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLG9CQUFvQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxXQUFXO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHVCQUF1QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsdUNBQXVDO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixnQ0FBZ0M7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxrQ0FBa0M7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGlDQUFpQztBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsaUJBQWlCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLG9CQUFvQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGtCQUFrQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGFBQWE7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxZQUFZO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsaUNBQWlDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGFBQWE7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsYUFBYTtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLFlBQVk7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixXQUFXO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLE9BQU87QUFDeEU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMEJBQTBCO0FBQzlDLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSxZQUFZLGFBQWE7QUFDekIsc0JBQXNCLDBCQUEwQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLG9CQUFvQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isd0JBQXdCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixhQUFhO0FBQ2hDLHFCQUFxQixZQUFZO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0EscUJBQXFCLGdCQUFnQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsSUFBSTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxJQUFJO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSw0Q0FBNEMsMENBQTBDLElBQUk7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsSUFBSTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QscUJBQXFCO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxrQkFBa0I7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsb0JBQW9CO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxDQVlMO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9taWtld2VzdGhhZC9EZXNrdG9wL1JlcG9zL3Nwb3JhZGljLWxhYnMtdGlsZS1leHRydWRlci9ub2RlX21vZHVsZXMvLnBucG0vaW1hZ2UtcUA0LjAuMC9ub2RlX21vZHVsZXMvaW1hZ2UtcS9kaXN0L2Nqcy9pbWFnZS1xLmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcERlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIF9fZ2V0T3duUHJvcE5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX21hcmtBc01vZHVsZSA9ICh0YXJnZXQpID0+IF9fZGVmUHJvcCh0YXJnZXQsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xudmFyIF9fcmVFeHBvcnQgPSAodGFyZ2V0LCBtb2R1bGUyLCBjb3B5RGVmYXVsdCwgZGVzYykgPT4ge1xuICBpZiAobW9kdWxlMiAmJiB0eXBlb2YgbW9kdWxlMiA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgbW9kdWxlMiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZm9yIChsZXQga2V5IG9mIF9fZ2V0T3duUHJvcE5hbWVzKG1vZHVsZTIpKVxuICAgICAgaWYgKCFfX2hhc093blByb3AuY2FsbCh0YXJnZXQsIGtleSkgJiYgKGNvcHlEZWZhdWx0IHx8IGtleSAhPT0gXCJkZWZhdWx0XCIpKVxuICAgICAgICBfX2RlZlByb3AodGFyZ2V0LCBrZXksIHsgZ2V0OiAoKSA9PiBtb2R1bGUyW2tleV0sIGVudW1lcmFibGU6ICEoZGVzYyA9IF9fZ2V0T3duUHJvcERlc2MobW9kdWxlMiwga2V5KSkgfHwgZGVzYy5lbnVtZXJhYmxlIH0pO1xuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59O1xudmFyIF9fdG9Db21tb25KUyA9IC8qIEBfX1BVUkVfXyAqLyAoKGNhY2hlKSA9PiB7XG4gIHJldHVybiAobW9kdWxlMiwgdGVtcCkgPT4ge1xuICAgIHJldHVybiBjYWNoZSAmJiBjYWNoZS5nZXQobW9kdWxlMikgfHwgKHRlbXAgPSBfX3JlRXhwb3J0KF9fbWFya0FzTW9kdWxlKHt9KSwgbW9kdWxlMiwgMSksIGNhY2hlICYmIGNhY2hlLnNldChtb2R1bGUyLCB0ZW1wKSwgdGVtcCk7XG4gIH07XG59KSh0eXBlb2YgV2Vha01hcCAhPT0gXCJ1bmRlZmluZWRcIiA/IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpIDogMCk7XG52YXIgX19wdWJsaWNGaWVsZCA9IChvYmosIGtleSwgdmFsdWUpID0+IHtcbiAgX19kZWZOb3JtYWxQcm9wKG9iaiwgdHlwZW9mIGtleSAhPT0gXCJzeW1ib2xcIiA/IGtleSArIFwiXCIgOiBrZXksIHZhbHVlKTtcbiAgcmV0dXJuIHZhbHVlO1xufTtcblxuLy8gc3JjL2luZGV4LnRzXG52YXIgc3JjX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KHNyY19leHBvcnRzLCB7XG4gIGFwcGx5UGFsZXR0ZTogKCkgPT4gYXBwbHlQYWxldHRlLFxuICBhcHBseVBhbGV0dGVTeW5jOiAoKSA9PiBhcHBseVBhbGV0dGVTeW5jLFxuICBidWlsZFBhbGV0dGU6ICgpID0+IGJ1aWxkUGFsZXR0ZSxcbiAgYnVpbGRQYWxldHRlU3luYzogKCkgPT4gYnVpbGRQYWxldHRlU3luYyxcbiAgY29uc3RhbnRzOiAoKSA9PiBjb25zdGFudHNfZXhwb3J0cyxcbiAgY29udmVyc2lvbjogKCkgPT4gY29udmVyc2lvbl9leHBvcnRzLFxuICBkaXN0YW5jZTogKCkgPT4gZGlzdGFuY2VfZXhwb3J0cyxcbiAgaW1hZ2U6ICgpID0+IGltYWdlX2V4cG9ydHMsXG4gIHBhbGV0dGU6ICgpID0+IHBhbGV0dGVfZXhwb3J0cyxcbiAgcXVhbGl0eTogKCkgPT4gcXVhbGl0eV9leHBvcnRzLFxuICB1dGlsczogKCkgPT4gdXRpbHNfZXhwb3J0c1xufSk7XG5cbi8vIHNyYy9jb25zdGFudHMvaW5kZXgudHNcbnZhciBjb25zdGFudHNfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoY29uc3RhbnRzX2V4cG9ydHMsIHtcbiAgYnQ3MDk6ICgpID0+IGJ0NzA5X2V4cG9ydHNcbn0pO1xuXG4vLyBzcmMvY29uc3RhbnRzL2J0NzA5LnRzXG52YXIgYnQ3MDlfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoYnQ3MDlfZXhwb3J0cywge1xuICBZOiAoKSA9PiBZLFxuICB4OiAoKSA9PiB4LFxuICB5OiAoKSA9PiB5XG59KTtcbnZhciBZID0gLyogQF9fUFVSRV9fICovICgoWTIpID0+IHtcbiAgWTJbWTJbXCJSRURcIl0gPSAwLjIxMjZdID0gXCJSRURcIjtcbiAgWTJbWTJbXCJHUkVFTlwiXSA9IDAuNzE1Ml0gPSBcIkdSRUVOXCI7XG4gIFkyW1kyW1wiQkxVRVwiXSA9IDAuMDcyMl0gPSBcIkJMVUVcIjtcbiAgWTJbWTJbXCJXSElURVwiXSA9IDFdID0gXCJXSElURVwiO1xuICByZXR1cm4gWTI7XG59KShZIHx8IHt9KTtcbnZhciB4ID0gLyogQF9fUFVSRV9fICovICgoeDIpID0+IHtcbiAgeDJbeDJbXCJSRURcIl0gPSAwLjY0XSA9IFwiUkVEXCI7XG4gIHgyW3gyW1wiR1JFRU5cIl0gPSAwLjNdID0gXCJHUkVFTlwiO1xuICB4Mlt4MltcIkJMVUVcIl0gPSAwLjE1XSA9IFwiQkxVRVwiO1xuICB4Mlt4MltcIldISVRFXCJdID0gMC4zMTI3XSA9IFwiV0hJVEVcIjtcbiAgcmV0dXJuIHgyO1xufSkoeCB8fCB7fSk7XG52YXIgeSA9IC8qIEBfX1BVUkVfXyAqLyAoKHkyKSA9PiB7XG4gIHkyW3kyW1wiUkVEXCJdID0gMC4zM10gPSBcIlJFRFwiO1xuICB5Mlt5MltcIkdSRUVOXCJdID0gMC42XSA9IFwiR1JFRU5cIjtcbiAgeTJbeTJbXCJCTFVFXCJdID0gMC4wNl0gPSBcIkJMVUVcIjtcbiAgeTJbeTJbXCJXSElURVwiXSA9IDAuMzI5XSA9IFwiV0hJVEVcIjtcbiAgcmV0dXJuIHkyO1xufSkoeSB8fCB7fSk7XG5cbi8vIHNyYy9jb252ZXJzaW9uL2luZGV4LnRzXG52YXIgY29udmVyc2lvbl9leHBvcnRzID0ge307XG5fX2V4cG9ydChjb252ZXJzaW9uX2V4cG9ydHMsIHtcbiAgbGFiMnJnYjogKCkgPT4gbGFiMnJnYixcbiAgbGFiMnh5ejogKCkgPT4gbGFiMnh5eixcbiAgcmdiMmhzbDogKCkgPT4gcmdiMmhzbCxcbiAgcmdiMmxhYjogKCkgPT4gcmdiMmxhYixcbiAgcmdiMnh5ejogKCkgPT4gcmdiMnh5eixcbiAgeHl6MmxhYjogKCkgPT4geHl6MmxhYixcbiAgeHl6MnJnYjogKCkgPT4geHl6MnJnYlxufSk7XG5cbi8vIHNyYy9jb252ZXJzaW9uL3JnYjJ4eXoudHNcbmZ1bmN0aW9uIGNvcnJlY3RHYW1tYShuKSB7XG4gIHJldHVybiBuID4gMC4wNDA0NSA/ICgobiArIDAuMDU1KSAvIDEuMDU1KSAqKiAyLjQgOiBuIC8gMTIuOTI7XG59XG5mdW5jdGlvbiByZ2IyeHl6KHIsIGcsIGIpIHtcbiAgciA9IGNvcnJlY3RHYW1tYShyIC8gMjU1KTtcbiAgZyA9IGNvcnJlY3RHYW1tYShnIC8gMjU1KTtcbiAgYiA9IGNvcnJlY3RHYW1tYShiIC8gMjU1KTtcbiAgcmV0dXJuIHtcbiAgICB4OiByICogMC40MTI0ICsgZyAqIDAuMzU3NiArIGIgKiAwLjE4MDUsXG4gICAgeTogciAqIDAuMjEyNiArIGcgKiAwLjcxNTIgKyBiICogMC4wNzIyLFxuICAgIHo6IHIgKiAwLjAxOTMgKyBnICogMC4xMTkyICsgYiAqIDAuOTUwNVxuICB9O1xufVxuXG4vLyBzcmMvdXRpbHMvYXJpdGhtZXRpYy50c1xudmFyIGFyaXRobWV0aWNfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoYXJpdGhtZXRpY19leHBvcnRzLCB7XG4gIGRlZ3JlZXMycmFkaWFuczogKCkgPT4gZGVncmVlczJyYWRpYW5zLFxuICBpblJhbmdlMHRvMjU1OiAoKSA9PiBpblJhbmdlMHRvMjU1LFxuICBpblJhbmdlMHRvMjU1Um91bmRlZDogKCkgPT4gaW5SYW5nZTB0bzI1NVJvdW5kZWQsXG4gIGludEluUmFuZ2U6ICgpID0+IGludEluUmFuZ2UsXG4gIG1heDM6ICgpID0+IG1heDMsXG4gIG1pbjM6ICgpID0+IG1pbjMsXG4gIHN0YWJsZVNvcnQ6ICgpID0+IHN0YWJsZVNvcnRcbn0pO1xuZnVuY3Rpb24gZGVncmVlczJyYWRpYW5zKG4pIHtcbiAgcmV0dXJuIG4gKiAoTWF0aC5QSSAvIDE4MCk7XG59XG5mdW5jdGlvbiBtYXgzKGEsIGIsIGMpIHtcbiAgbGV0IG0gPSBhO1xuICBpZiAobSA8IGIpXG4gICAgbSA9IGI7XG4gIGlmIChtIDwgYylcbiAgICBtID0gYztcbiAgcmV0dXJuIG07XG59XG5mdW5jdGlvbiBtaW4zKGEsIGIsIGMpIHtcbiAgbGV0IG0gPSBhO1xuICBpZiAobSA+IGIpXG4gICAgbSA9IGI7XG4gIGlmIChtID4gYylcbiAgICBtID0gYztcbiAgcmV0dXJuIG07XG59XG5mdW5jdGlvbiBpbnRJblJhbmdlKHZhbHVlLCBsb3csIGhpZ2gpIHtcbiAgaWYgKHZhbHVlID4gaGlnaClcbiAgICB2YWx1ZSA9IGhpZ2g7XG4gIGlmICh2YWx1ZSA8IGxvdylcbiAgICB2YWx1ZSA9IGxvdztcbiAgcmV0dXJuIHZhbHVlIHwgMDtcbn1cbmZ1bmN0aW9uIGluUmFuZ2UwdG8yNTVSb3VuZGVkKG4pIHtcbiAgbiA9IE1hdGgucm91bmQobik7XG4gIGlmIChuID4gMjU1KVxuICAgIG4gPSAyNTU7XG4gIGVsc2UgaWYgKG4gPCAwKVxuICAgIG4gPSAwO1xuICByZXR1cm4gbjtcbn1cbmZ1bmN0aW9uIGluUmFuZ2UwdG8yNTUobikge1xuICBpZiAobiA+IDI1NSlcbiAgICBuID0gMjU1O1xuICBlbHNlIGlmIChuIDwgMClcbiAgICBuID0gMDtcbiAgcmV0dXJuIG47XG59XG5mdW5jdGlvbiBzdGFibGVTb3J0KGFycmF5VG9Tb3J0LCBjYWxsYmFjaykge1xuICBjb25zdCB0eXBlID0gdHlwZW9mIGFycmF5VG9Tb3J0WzBdO1xuICBsZXQgc29ydGVkO1xuICBpZiAodHlwZSA9PT0gXCJudW1iZXJcIiB8fCB0eXBlID09PSBcInN0cmluZ1wiKSB7XG4gICAgY29uc3Qgb3JkID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgZm9yIChsZXQgaSA9IDAsIGwgPSBhcnJheVRvU29ydC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGNvbnN0IHZhbCA9IGFycmF5VG9Tb3J0W2ldO1xuICAgICAgaWYgKG9yZFt2YWxdIHx8IG9yZFt2YWxdID09PSAwKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIG9yZFt2YWxdID0gaTtcbiAgICB9XG4gICAgc29ydGVkID0gYXJyYXlUb1NvcnQuc29ydCgoYSwgYikgPT4gY2FsbGJhY2soYSwgYikgfHwgb3JkW2FdIC0gb3JkW2JdKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBvcmQyID0gYXJyYXlUb1NvcnQuc2xpY2UoMCk7XG4gICAgc29ydGVkID0gYXJyYXlUb1NvcnQuc29ydCgoYSwgYikgPT4gY2FsbGJhY2soYSwgYikgfHwgb3JkMi5pbmRleE9mKGEpIC0gb3JkMi5pbmRleE9mKGIpKTtcbiAgfVxuICByZXR1cm4gc29ydGVkO1xufVxuXG4vLyBzcmMvY29udmVyc2lvbi9yZ2IyaHNsLnRzXG5mdW5jdGlvbiByZ2IyaHNsKHIsIGcsIGIpIHtcbiAgY29uc3QgbWluID0gbWluMyhyLCBnLCBiKTtcbiAgY29uc3QgbWF4ID0gbWF4MyhyLCBnLCBiKTtcbiAgY29uc3QgZGVsdGEgPSBtYXggLSBtaW47XG4gIGNvbnN0IGwgPSAobWluICsgbWF4KSAvIDUxMDtcbiAgbGV0IHMgPSAwO1xuICBpZiAobCA+IDAgJiYgbCA8IDEpXG4gICAgcyA9IGRlbHRhIC8gKGwgPCAwLjUgPyBtYXggKyBtaW4gOiA1MTAgLSBtYXggLSBtaW4pO1xuICBsZXQgaCA9IDA7XG4gIGlmIChkZWx0YSA+IDApIHtcbiAgICBpZiAobWF4ID09PSByKSB7XG4gICAgICBoID0gKGcgLSBiKSAvIGRlbHRhO1xuICAgIH0gZWxzZSBpZiAobWF4ID09PSBnKSB7XG4gICAgICBoID0gMiArIChiIC0gcikgLyBkZWx0YTtcbiAgICB9IGVsc2Uge1xuICAgICAgaCA9IDQgKyAociAtIGcpIC8gZGVsdGE7XG4gICAgfVxuICAgIGggKj0gNjA7XG4gICAgaWYgKGggPCAwKVxuICAgICAgaCArPSAzNjA7XG4gIH1cbiAgcmV0dXJuIHsgaCwgcywgbCB9O1xufVxuXG4vLyBzcmMvY29udmVyc2lvbi94eXoybGFiLnRzXG52YXIgcmVmWCA9IDAuOTUwNDc7XG52YXIgcmVmWSA9IDE7XG52YXIgcmVmWiA9IDEuMDg4ODM7XG5mdW5jdGlvbiBwaXZvdChuKSB7XG4gIHJldHVybiBuID4gODg1NmUtNiA/IG4gKiogKDEgLyAzKSA6IDcuNzg3ICogbiArIDE2IC8gMTE2O1xufVxuZnVuY3Rpb24geHl6MmxhYih4MiwgeTIsIHopIHtcbiAgeDIgPSBwaXZvdCh4MiAvIHJlZlgpO1xuICB5MiA9IHBpdm90KHkyIC8gcmVmWSk7XG4gIHogPSBwaXZvdCh6IC8gcmVmWik7XG4gIGlmICgxMTYgKiB5MiAtIDE2IDwgMClcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ4eHhcIik7XG4gIHJldHVybiB7XG4gICAgTDogTWF0aC5tYXgoMCwgMTE2ICogeTIgLSAxNiksXG4gICAgYTogNTAwICogKHgyIC0geTIpLFxuICAgIGI6IDIwMCAqICh5MiAtIHopXG4gIH07XG59XG5cbi8vIHNyYy9jb252ZXJzaW9uL3JnYjJsYWIudHNcbmZ1bmN0aW9uIHJnYjJsYWIociwgZywgYikge1xuICBjb25zdCB4eXogPSByZ2IyeHl6KHIsIGcsIGIpO1xuICByZXR1cm4geHl6MmxhYih4eXoueCwgeHl6LnksIHh5ei56KTtcbn1cblxuLy8gc3JjL2NvbnZlcnNpb24vbGFiMnh5ei50c1xudmFyIHJlZlgyID0gMC45NTA0NztcbnZhciByZWZZMiA9IDE7XG52YXIgcmVmWjIgPSAxLjA4ODgzO1xuZnVuY3Rpb24gcGl2b3QyKG4pIHtcbiAgcmV0dXJuIG4gPiAwLjIwNjg5MzAzNCA/IG4gKiogMyA6IChuIC0gMTYgLyAxMTYpIC8gNy43ODc7XG59XG5mdW5jdGlvbiBsYWIyeHl6KEwsIGEsIGIpIHtcbiAgY29uc3QgeTIgPSAoTCArIDE2KSAvIDExNjtcbiAgY29uc3QgeDIgPSBhIC8gNTAwICsgeTI7XG4gIGNvbnN0IHogPSB5MiAtIGIgLyAyMDA7XG4gIHJldHVybiB7XG4gICAgeDogcmVmWDIgKiBwaXZvdDIoeDIpLFxuICAgIHk6IHJlZlkyICogcGl2b3QyKHkyKSxcbiAgICB6OiByZWZaMiAqIHBpdm90Mih6KVxuICB9O1xufVxuXG4vLyBzcmMvY29udmVyc2lvbi94eXoycmdiLnRzXG5mdW5jdGlvbiBjb3JyZWN0R2FtbWEyKG4pIHtcbiAgcmV0dXJuIG4gPiAzMTMwOGUtNyA/IDEuMDU1ICogbiAqKiAoMSAvIDIuNCkgLSAwLjA1NSA6IDEyLjkyICogbjtcbn1cbmZ1bmN0aW9uIHh5ejJyZ2IoeDIsIHkyLCB6KSB7XG4gIGNvbnN0IHIgPSBjb3JyZWN0R2FtbWEyKHgyICogMy4yNDA2ICsgeTIgKiAtMS41MzcyICsgeiAqIC0wLjQ5ODYpO1xuICBjb25zdCBnID0gY29ycmVjdEdhbW1hMih4MiAqIC0wLjk2ODkgKyB5MiAqIDEuODc1OCArIHogKiAwLjA0MTUpO1xuICBjb25zdCBiID0gY29ycmVjdEdhbW1hMih4MiAqIDAuMDU1NyArIHkyICogLTAuMjA0ICsgeiAqIDEuMDU3KTtcbiAgcmV0dXJuIHtcbiAgICByOiBpblJhbmdlMHRvMjU1Um91bmRlZChyICogMjU1KSxcbiAgICBnOiBpblJhbmdlMHRvMjU1Um91bmRlZChnICogMjU1KSxcbiAgICBiOiBpblJhbmdlMHRvMjU1Um91bmRlZChiICogMjU1KVxuICB9O1xufVxuXG4vLyBzcmMvY29udmVyc2lvbi9sYWIycmdiLnRzXG5mdW5jdGlvbiBsYWIycmdiKEwsIGEsIGIpIHtcbiAgY29uc3QgeHl6ID0gbGFiMnh5eihMLCBhLCBiKTtcbiAgcmV0dXJuIHh5ejJyZ2IoeHl6LngsIHh5ei55LCB4eXoueik7XG59XG5cbi8vIHNyYy9kaXN0YW5jZS9pbmRleC50c1xudmFyIGRpc3RhbmNlX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KGRpc3RhbmNlX2V4cG9ydHMsIHtcbiAgQWJzdHJhY3REaXN0YW5jZUNhbGN1bGF0b3I6ICgpID0+IEFic3RyYWN0RGlzdGFuY2VDYWxjdWxhdG9yLFxuICBBYnN0cmFjdEV1Y2xpZGVhbjogKCkgPT4gQWJzdHJhY3RFdWNsaWRlYW4sXG4gIEFic3RyYWN0TWFuaGF0dGFuOiAoKSA9PiBBYnN0cmFjdE1hbmhhdHRhbixcbiAgQ0lFOTRHcmFwaGljQXJ0czogKCkgPT4gQ0lFOTRHcmFwaGljQXJ0cyxcbiAgQ0lFOTRUZXh0aWxlczogKCkgPT4gQ0lFOTRUZXh0aWxlcyxcbiAgQ0lFREUyMDAwOiAoKSA9PiBDSUVERTIwMDAsXG4gIENNZXRyaWM6ICgpID0+IENNZXRyaWMsXG4gIEV1Y2xpZGVhbjogKCkgPT4gRXVjbGlkZWFuLFxuICBFdWNsaWRlYW5CVDcwOTogKCkgPT4gRXVjbGlkZWFuQlQ3MDksXG4gIEV1Y2xpZGVhbkJUNzA5Tm9BbHBoYTogKCkgPT4gRXVjbGlkZWFuQlQ3MDlOb0FscGhhLFxuICBNYW5oYXR0YW46ICgpID0+IE1hbmhhdHRhbixcbiAgTWFuaGF0dGFuQlQ3MDk6ICgpID0+IE1hbmhhdHRhbkJUNzA5LFxuICBNYW5oYXR0YW5Ob21teWRlOiAoKSA9PiBNYW5oYXR0YW5Ob21teWRlLFxuICBQTkdRdWFudDogKCkgPT4gUE5HUXVhbnRcbn0pO1xuXG4vLyBzcmMvZGlzdGFuY2UvZGlzdGFuY2VDYWxjdWxhdG9yLnRzXG52YXIgQWJzdHJhY3REaXN0YW5jZUNhbGN1bGF0b3IgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJfbWF4RGlzdGFuY2VcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIl93aGl0ZVBvaW50XCIpO1xuICAgIHRoaXMuX3NldERlZmF1bHRzKCk7XG4gICAgdGhpcy5zZXRXaGl0ZVBvaW50KDI1NSwgMjU1LCAyNTUsIDI1NSk7XG4gIH1cbiAgc2V0V2hpdGVQb2ludChyLCBnLCBiLCBhKSB7XG4gICAgdGhpcy5fd2hpdGVQb2ludCA9IHtcbiAgICAgIHI6IHIgPiAwID8gMjU1IC8gciA6IDAsXG4gICAgICBnOiBnID4gMCA/IDI1NSAvIGcgOiAwLFxuICAgICAgYjogYiA+IDAgPyAyNTUgLyBiIDogMCxcbiAgICAgIGE6IGEgPiAwID8gMjU1IC8gYSA6IDBcbiAgICB9O1xuICAgIHRoaXMuX21heERpc3RhbmNlID0gdGhpcy5jYWxjdWxhdGVSYXcociwgZywgYiwgYSwgMCwgMCwgMCwgMCk7XG4gIH1cbiAgY2FsY3VsYXRlTm9ybWFsaXplZChjb2xvckEsIGNvbG9yQikge1xuICAgIHJldHVybiB0aGlzLmNhbGN1bGF0ZVJhdyhjb2xvckEuciwgY29sb3JBLmcsIGNvbG9yQS5iLCBjb2xvckEuYSwgY29sb3JCLnIsIGNvbG9yQi5nLCBjb2xvckIuYiwgY29sb3JCLmEpIC8gdGhpcy5fbWF4RGlzdGFuY2U7XG4gIH1cbn07XG5cbi8vIHNyYy9kaXN0YW5jZS9jaWU5NC50c1xudmFyIEFic3RyYWN0Q0lFOTQgPSBjbGFzcyBleHRlbmRzIEFic3RyYWN0RGlzdGFuY2VDYWxjdWxhdG9yIHtcbiAgY2FsY3VsYXRlUmF3KHIxLCBnMSwgYjEsIGExLCByMiwgZzIsIGIyLCBhMikge1xuICAgIGNvbnN0IGxhYjEgPSByZ2IybGFiKGluUmFuZ2UwdG8yNTUocjEgKiB0aGlzLl93aGl0ZVBvaW50LnIpLCBpblJhbmdlMHRvMjU1KGcxICogdGhpcy5fd2hpdGVQb2ludC5nKSwgaW5SYW5nZTB0bzI1NShiMSAqIHRoaXMuX3doaXRlUG9pbnQuYikpO1xuICAgIGNvbnN0IGxhYjIgPSByZ2IybGFiKGluUmFuZ2UwdG8yNTUocjIgKiB0aGlzLl93aGl0ZVBvaW50LnIpLCBpblJhbmdlMHRvMjU1KGcyICogdGhpcy5fd2hpdGVQb2ludC5nKSwgaW5SYW5nZTB0bzI1NShiMiAqIHRoaXMuX3doaXRlUG9pbnQuYikpO1xuICAgIGNvbnN0IGRMID0gbGFiMS5MIC0gbGFiMi5MO1xuICAgIGNvbnN0IGRBID0gbGFiMS5hIC0gbGFiMi5hO1xuICAgIGNvbnN0IGRCID0gbGFiMS5iIC0gbGFiMi5iO1xuICAgIGNvbnN0IGMxID0gTWF0aC5zcXJ0KGxhYjEuYSAqIGxhYjEuYSArIGxhYjEuYiAqIGxhYjEuYik7XG4gICAgY29uc3QgYzIgPSBNYXRoLnNxcnQobGFiMi5hICogbGFiMi5hICsgbGFiMi5iICogbGFiMi5iKTtcbiAgICBjb25zdCBkQyA9IGMxIC0gYzI7XG4gICAgbGV0IGRlbHRhSCA9IGRBICogZEEgKyBkQiAqIGRCIC0gZEMgKiBkQztcbiAgICBkZWx0YUggPSBkZWx0YUggPCAwID8gMCA6IE1hdGguc3FydChkZWx0YUgpO1xuICAgIGNvbnN0IGRBbHBoYSA9IChhMiAtIGExKSAqIHRoaXMuX3doaXRlUG9pbnQuYSAqIHRoaXMuX2tBO1xuICAgIHJldHVybiBNYXRoLnNxcnQoKGRMIC8gdGhpcy5fS2wpICoqIDIgKyAoZEMgLyAoMSArIHRoaXMuX0sxICogYzEpKSAqKiAyICsgKGRlbHRhSCAvICgxICsgdGhpcy5fSzIgKiBjMSkpICoqIDIgKyBkQWxwaGEgKiogMik7XG4gIH1cbn07XG52YXIgQ0lFOTRUZXh0aWxlcyA9IGNsYXNzIGV4dGVuZHMgQWJzdHJhY3RDSUU5NCB7XG4gIF9zZXREZWZhdWx0cygpIHtcbiAgICB0aGlzLl9LbCA9IDI7XG4gICAgdGhpcy5fSzEgPSAwLjA0ODtcbiAgICB0aGlzLl9LMiA9IDAuMDE0O1xuICAgIHRoaXMuX2tBID0gMC4yNSAqIDUwIC8gMjU1O1xuICB9XG59O1xudmFyIENJRTk0R3JhcGhpY0FydHMgPSBjbGFzcyBleHRlbmRzIEFic3RyYWN0Q0lFOTQge1xuICBfc2V0RGVmYXVsdHMoKSB7XG4gICAgdGhpcy5fS2wgPSAxO1xuICAgIHRoaXMuX0sxID0gMC4wNDU7XG4gICAgdGhpcy5fSzIgPSAwLjAxNTtcbiAgICB0aGlzLl9rQSA9IDAuMjUgKiAxMDAgLyAyNTU7XG4gIH1cbn07XG5cbi8vIHNyYy9kaXN0YW5jZS9jaWVkZTIwMDAudHNcbnZhciBfQ0lFREUyMDAwID0gY2xhc3MgZXh0ZW5kcyBBYnN0cmFjdERpc3RhbmNlQ2FsY3VsYXRvciB7XG4gIF9zZXREZWZhdWx0cygpIHtcbiAgfVxuICBzdGF0aWMgX2NhbGN1bGF0ZWhwKGIsIGFwKSB7XG4gICAgY29uc3QgaHAgPSBNYXRoLmF0YW4yKGIsIGFwKTtcbiAgICBpZiAoaHAgPj0gMClcbiAgICAgIHJldHVybiBocDtcbiAgICByZXR1cm4gaHAgKyBfQ0lFREUyMDAwLl9kZWczNjBJblJhZDtcbiAgfVxuICBzdGF0aWMgX2NhbGN1bGF0ZVJUKGFocCwgYUNwKSB7XG4gICAgY29uc3QgYUNwX3RvXzcgPSBhQ3AgKiogNztcbiAgICBjb25zdCBSX0MgPSAyICogTWF0aC5zcXJ0KGFDcF90b183IC8gKGFDcF90b183ICsgX0NJRURFMjAwMC5fcG93MjV0bzcpKTtcbiAgICBjb25zdCBkZWx0YV90aGV0YSA9IF9DSUVERTIwMDAuX2RlZzMwSW5SYWQgKiBNYXRoLmV4cCgtKCgoYWhwIC0gX0NJRURFMjAwMC5fZGVnMjc1SW5SYWQpIC8gX0NJRURFMjAwMC5fZGVnMjVJblJhZCkgKiogMikpO1xuICAgIHJldHVybiAtTWF0aC5zaW4oMiAqIGRlbHRhX3RoZXRhKSAqIFJfQztcbiAgfVxuICBzdGF0aWMgX2NhbGN1bGF0ZVQoYWhwKSB7XG4gICAgcmV0dXJuIDEgLSAwLjE3ICogTWF0aC5jb3MoYWhwIC0gX0NJRURFMjAwMC5fZGVnMzBJblJhZCkgKyAwLjI0ICogTWF0aC5jb3MoYWhwICogMikgKyAwLjMyICogTWF0aC5jb3MoYWhwICogMyArIF9DSUVERTIwMDAuX2RlZzZJblJhZCkgLSAwLjIgKiBNYXRoLmNvcyhhaHAgKiA0IC0gX0NJRURFMjAwMC5fZGVnNjNJblJhZCk7XG4gIH1cbiAgc3RhdGljIF9jYWxjdWxhdGVfYWhwKEMxcEMycCwgaF9iYXIsIGgxcCwgaDJwKSB7XG4gICAgY29uc3QgaHBTdW0gPSBoMXAgKyBoMnA7XG4gICAgaWYgKEMxcEMycCA9PT0gMClcbiAgICAgIHJldHVybiBocFN1bTtcbiAgICBpZiAoaF9iYXIgPD0gX0NJRURFMjAwMC5fZGVnMTgwSW5SYWQpXG4gICAgICByZXR1cm4gaHBTdW0gLyAyO1xuICAgIGlmIChocFN1bSA8IF9DSUVERTIwMDAuX2RlZzM2MEluUmFkKSB7XG4gICAgICByZXR1cm4gKGhwU3VtICsgX0NJRURFMjAwMC5fZGVnMzYwSW5SYWQpIC8gMjtcbiAgICB9XG4gICAgcmV0dXJuIChocFN1bSAtIF9DSUVERTIwMDAuX2RlZzM2MEluUmFkKSAvIDI7XG4gIH1cbiAgc3RhdGljIF9jYWxjdWxhdGVfZEhwKEMxcEMycCwgaF9iYXIsIGgycCwgaDFwKSB7XG4gICAgbGV0IGRocDtcbiAgICBpZiAoQzFwQzJwID09PSAwKSB7XG4gICAgICBkaHAgPSAwO1xuICAgIH0gZWxzZSBpZiAoaF9iYXIgPD0gX0NJRURFMjAwMC5fZGVnMTgwSW5SYWQpIHtcbiAgICAgIGRocCA9IGgycCAtIGgxcDtcbiAgICB9IGVsc2UgaWYgKGgycCA8PSBoMXApIHtcbiAgICAgIGRocCA9IGgycCAtIGgxcCArIF9DSUVERTIwMDAuX2RlZzM2MEluUmFkO1xuICAgIH0gZWxzZSB7XG4gICAgICBkaHAgPSBoMnAgLSBoMXAgLSBfQ0lFREUyMDAwLl9kZWczNjBJblJhZDtcbiAgICB9XG4gICAgcmV0dXJuIDIgKiBNYXRoLnNxcnQoQzFwQzJwKSAqIE1hdGguc2luKGRocCAvIDIpO1xuICB9XG4gIGNhbGN1bGF0ZVJhdyhyMSwgZzEsIGIxLCBhMSwgcjIsIGcyLCBiMiwgYTIpIHtcbiAgICBjb25zdCBsYWIxID0gcmdiMmxhYihpblJhbmdlMHRvMjU1KHIxICogdGhpcy5fd2hpdGVQb2ludC5yKSwgaW5SYW5nZTB0bzI1NShnMSAqIHRoaXMuX3doaXRlUG9pbnQuZyksIGluUmFuZ2UwdG8yNTUoYjEgKiB0aGlzLl93aGl0ZVBvaW50LmIpKTtcbiAgICBjb25zdCBsYWIyID0gcmdiMmxhYihpblJhbmdlMHRvMjU1KHIyICogdGhpcy5fd2hpdGVQb2ludC5yKSwgaW5SYW5nZTB0bzI1NShnMiAqIHRoaXMuX3doaXRlUG9pbnQuZyksIGluUmFuZ2UwdG8yNTUoYjIgKiB0aGlzLl93aGl0ZVBvaW50LmIpKTtcbiAgICBjb25zdCBkQSA9IChhMiAtIGExKSAqIHRoaXMuX3doaXRlUG9pbnQuYSAqIF9DSUVERTIwMDAuX2tBO1xuICAgIGNvbnN0IGRFMiA9IHRoaXMuY2FsY3VsYXRlUmF3SW5MYWIobGFiMSwgbGFiMik7XG4gICAgcmV0dXJuIE1hdGguc3FydChkRTIgKyBkQSAqIGRBKTtcbiAgfVxuICBjYWxjdWxhdGVSYXdJbkxhYihMYWIxLCBMYWIyKSB7XG4gICAgY29uc3QgTDEgPSBMYWIxLkw7XG4gICAgY29uc3QgYTEgPSBMYWIxLmE7XG4gICAgY29uc3QgYjEgPSBMYWIxLmI7XG4gICAgY29uc3QgTDIgPSBMYWIyLkw7XG4gICAgY29uc3QgYTIgPSBMYWIyLmE7XG4gICAgY29uc3QgYjIgPSBMYWIyLmI7XG4gICAgY29uc3QgQzEgPSBNYXRoLnNxcnQoYTEgKiBhMSArIGIxICogYjEpO1xuICAgIGNvbnN0IEMyID0gTWF0aC5zcXJ0KGEyICogYTIgKyBiMiAqIGIyKTtcbiAgICBjb25zdCBwb3dfYV9DMV9DMl90b183ID0gKChDMSArIEMyKSAvIDIpICoqIDc7XG4gICAgY29uc3QgRyA9IDAuNSAqICgxIC0gTWF0aC5zcXJ0KHBvd19hX0MxX0MyX3RvXzcgLyAocG93X2FfQzFfQzJfdG9fNyArIF9DSUVERTIwMDAuX3BvdzI1dG83KSkpO1xuICAgIGNvbnN0IGExcCA9ICgxICsgRykgKiBhMTtcbiAgICBjb25zdCBhMnAgPSAoMSArIEcpICogYTI7XG4gICAgY29uc3QgQzFwID0gTWF0aC5zcXJ0KGExcCAqIGExcCArIGIxICogYjEpO1xuICAgIGNvbnN0IEMycCA9IE1hdGguc3FydChhMnAgKiBhMnAgKyBiMiAqIGIyKTtcbiAgICBjb25zdCBDMXBDMnAgPSBDMXAgKiBDMnA7XG4gICAgY29uc3QgaDFwID0gX0NJRURFMjAwMC5fY2FsY3VsYXRlaHAoYjEsIGExcCk7XG4gICAgY29uc3QgaDJwID0gX0NJRURFMjAwMC5fY2FsY3VsYXRlaHAoYjIsIGEycCk7XG4gICAgY29uc3QgaF9iYXIgPSBNYXRoLmFicyhoMXAgLSBoMnApO1xuICAgIGNvbnN0IGRMcCA9IEwyIC0gTDE7XG4gICAgY29uc3QgZENwID0gQzJwIC0gQzFwO1xuICAgIGNvbnN0IGRIcCA9IF9DSUVERTIwMDAuX2NhbGN1bGF0ZV9kSHAoQzFwQzJwLCBoX2JhciwgaDJwLCBoMXApO1xuICAgIGNvbnN0IGFocCA9IF9DSUVERTIwMDAuX2NhbGN1bGF0ZV9haHAoQzFwQzJwLCBoX2JhciwgaDFwLCBoMnApO1xuICAgIGNvbnN0IFQgPSBfQ0lFREUyMDAwLl9jYWxjdWxhdGVUKGFocCk7XG4gICAgY29uc3QgYUNwID0gKEMxcCArIEMycCkgLyAyO1xuICAgIGNvbnN0IGFMcF9taW51c181MF9zcXVhcmUgPSAoKEwxICsgTDIpIC8gMiAtIDUwKSAqKiAyO1xuICAgIGNvbnN0IFNfTCA9IDEgKyAwLjAxNSAqIGFMcF9taW51c181MF9zcXVhcmUgLyBNYXRoLnNxcnQoMjAgKyBhTHBfbWludXNfNTBfc3F1YXJlKTtcbiAgICBjb25zdCBTX0MgPSAxICsgMC4wNDUgKiBhQ3A7XG4gICAgY29uc3QgU19IID0gMSArIDAuMDE1ICogVCAqIGFDcDtcbiAgICBjb25zdCBSX1QgPSBfQ0lFREUyMDAwLl9jYWxjdWxhdGVSVChhaHAsIGFDcCk7XG4gICAgY29uc3QgZExwU0wgPSBkTHAgLyBTX0w7XG4gICAgY29uc3QgZENwU0MgPSBkQ3AgLyBTX0M7XG4gICAgY29uc3QgZEhwU0ggPSBkSHAgLyBTX0g7XG4gICAgcmV0dXJuIGRMcFNMICoqIDIgKyBkQ3BTQyAqKiAyICsgZEhwU0ggKiogMiArIFJfVCAqIGRDcFNDICogZEhwU0g7XG4gIH1cbn07XG52YXIgQ0lFREUyMDAwID0gX0NJRURFMjAwMDtcbl9fcHVibGljRmllbGQoQ0lFREUyMDAwLCBcIl9rQVwiLCAwLjI1ICogMTAwIC8gMjU1KTtcbl9fcHVibGljRmllbGQoQ0lFREUyMDAwLCBcIl9wb3cyNXRvN1wiLCAyNSAqKiA3KTtcbl9fcHVibGljRmllbGQoQ0lFREUyMDAwLCBcIl9kZWczNjBJblJhZFwiLCBkZWdyZWVzMnJhZGlhbnMoMzYwKSk7XG5fX3B1YmxpY0ZpZWxkKENJRURFMjAwMCwgXCJfZGVnMTgwSW5SYWRcIiwgZGVncmVlczJyYWRpYW5zKDE4MCkpO1xuX19wdWJsaWNGaWVsZChDSUVERTIwMDAsIFwiX2RlZzMwSW5SYWRcIiwgZGVncmVlczJyYWRpYW5zKDMwKSk7XG5fX3B1YmxpY0ZpZWxkKENJRURFMjAwMCwgXCJfZGVnNkluUmFkXCIsIGRlZ3JlZXMycmFkaWFucyg2KSk7XG5fX3B1YmxpY0ZpZWxkKENJRURFMjAwMCwgXCJfZGVnNjNJblJhZFwiLCBkZWdyZWVzMnJhZGlhbnMoNjMpKTtcbl9fcHVibGljRmllbGQoQ0lFREUyMDAwLCBcIl9kZWcyNzVJblJhZFwiLCBkZWdyZWVzMnJhZGlhbnMoMjc1KSk7XG5fX3B1YmxpY0ZpZWxkKENJRURFMjAwMCwgXCJfZGVnMjVJblJhZFwiLCBkZWdyZWVzMnJhZGlhbnMoMjUpKTtcblxuLy8gc3JjL2Rpc3RhbmNlL2NtZXRyaWMudHNcbnZhciBDTWV0cmljID0gY2xhc3MgZXh0ZW5kcyBBYnN0cmFjdERpc3RhbmNlQ2FsY3VsYXRvciB7XG4gIGNhbGN1bGF0ZVJhdyhyMSwgZzEsIGIxLCBhMSwgcjIsIGcyLCBiMiwgYTIpIHtcbiAgICBjb25zdCBybWVhbiA9IChyMSArIHIyKSAvIDIgKiB0aGlzLl93aGl0ZVBvaW50LnI7XG4gICAgY29uc3QgciA9IChyMSAtIHIyKSAqIHRoaXMuX3doaXRlUG9pbnQucjtcbiAgICBjb25zdCBnID0gKGcxIC0gZzIpICogdGhpcy5fd2hpdGVQb2ludC5nO1xuICAgIGNvbnN0IGIgPSAoYjEgLSBiMikgKiB0aGlzLl93aGl0ZVBvaW50LmI7XG4gICAgY29uc3QgZEUgPSAoKDUxMiArIHJtZWFuKSAqIHIgKiByID4+IDgpICsgNCAqIGcgKiBnICsgKCg3NjcgLSBybWVhbikgKiBiICogYiA+PiA4KTtcbiAgICBjb25zdCBkQSA9IChhMiAtIGExKSAqIHRoaXMuX3doaXRlUG9pbnQuYTtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KGRFICsgZEEgKiBkQSk7XG4gIH1cbiAgX3NldERlZmF1bHRzKCkge1xuICB9XG59O1xuXG4vLyBzcmMvZGlzdGFuY2UvZXVjbGlkZWFuLnRzXG52YXIgQWJzdHJhY3RFdWNsaWRlYW4gPSBjbGFzcyBleHRlbmRzIEFic3RyYWN0RGlzdGFuY2VDYWxjdWxhdG9yIHtcbiAgY2FsY3VsYXRlUmF3KHIxLCBnMSwgYjEsIGExLCByMiwgZzIsIGIyLCBhMikge1xuICAgIGNvbnN0IGRSID0gcjIgLSByMTtcbiAgICBjb25zdCBkRyA9IGcyIC0gZzE7XG4gICAgY29uc3QgZEIgPSBiMiAtIGIxO1xuICAgIGNvbnN0IGRBID0gYTIgLSBhMTtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KHRoaXMuX2tSICogZFIgKiBkUiArIHRoaXMuX2tHICogZEcgKiBkRyArIHRoaXMuX2tCICogZEIgKiBkQiArIHRoaXMuX2tBICogZEEgKiBkQSk7XG4gIH1cbn07XG52YXIgRXVjbGlkZWFuID0gY2xhc3MgZXh0ZW5kcyBBYnN0cmFjdEV1Y2xpZGVhbiB7XG4gIF9zZXREZWZhdWx0cygpIHtcbiAgICB0aGlzLl9rUiA9IDE7XG4gICAgdGhpcy5fa0cgPSAxO1xuICAgIHRoaXMuX2tCID0gMTtcbiAgICB0aGlzLl9rQSA9IDE7XG4gIH1cbn07XG52YXIgRXVjbGlkZWFuQlQ3MDkgPSBjbGFzcyBleHRlbmRzIEFic3RyYWN0RXVjbGlkZWFuIHtcbiAgX3NldERlZmF1bHRzKCkge1xuICAgIHRoaXMuX2tSID0gMC4yMTI2IC8qIFJFRCAqLztcbiAgICB0aGlzLl9rRyA9IDAuNzE1MiAvKiBHUkVFTiAqLztcbiAgICB0aGlzLl9rQiA9IDAuMDcyMiAvKiBCTFVFICovO1xuICAgIHRoaXMuX2tBID0gMTtcbiAgfVxufTtcbnZhciBFdWNsaWRlYW5CVDcwOU5vQWxwaGEgPSBjbGFzcyBleHRlbmRzIEFic3RyYWN0RXVjbGlkZWFuIHtcbiAgX3NldERlZmF1bHRzKCkge1xuICAgIHRoaXMuX2tSID0gMC4yMTI2IC8qIFJFRCAqLztcbiAgICB0aGlzLl9rRyA9IDAuNzE1MiAvKiBHUkVFTiAqLztcbiAgICB0aGlzLl9rQiA9IDAuMDcyMiAvKiBCTFVFICovO1xuICAgIHRoaXMuX2tBID0gMDtcbiAgfVxufTtcblxuLy8gc3JjL2Rpc3RhbmNlL21hbmhhdHRhbi50c1xudmFyIEFic3RyYWN0TWFuaGF0dGFuID0gY2xhc3MgZXh0ZW5kcyBBYnN0cmFjdERpc3RhbmNlQ2FsY3VsYXRvciB7XG4gIGNhbGN1bGF0ZVJhdyhyMSwgZzEsIGIxLCBhMSwgcjIsIGcyLCBiMiwgYTIpIHtcbiAgICBsZXQgZFIgPSByMiAtIHIxO1xuICAgIGxldCBkRyA9IGcyIC0gZzE7XG4gICAgbGV0IGRCID0gYjIgLSBiMTtcbiAgICBsZXQgZEEgPSBhMiAtIGExO1xuICAgIGlmIChkUiA8IDApXG4gICAgICBkUiA9IDAgLSBkUjtcbiAgICBpZiAoZEcgPCAwKVxuICAgICAgZEcgPSAwIC0gZEc7XG4gICAgaWYgKGRCIDwgMClcbiAgICAgIGRCID0gMCAtIGRCO1xuICAgIGlmIChkQSA8IDApXG4gICAgICBkQSA9IDAgLSBkQTtcbiAgICByZXR1cm4gdGhpcy5fa1IgKiBkUiArIHRoaXMuX2tHICogZEcgKyB0aGlzLl9rQiAqIGRCICsgdGhpcy5fa0EgKiBkQTtcbiAgfVxufTtcbnZhciBNYW5oYXR0YW4gPSBjbGFzcyBleHRlbmRzIEFic3RyYWN0TWFuaGF0dGFuIHtcbiAgX3NldERlZmF1bHRzKCkge1xuICAgIHRoaXMuX2tSID0gMTtcbiAgICB0aGlzLl9rRyA9IDE7XG4gICAgdGhpcy5fa0IgPSAxO1xuICAgIHRoaXMuX2tBID0gMTtcbiAgfVxufTtcbnZhciBNYW5oYXR0YW5Ob21teWRlID0gY2xhc3MgZXh0ZW5kcyBBYnN0cmFjdE1hbmhhdHRhbiB7XG4gIF9zZXREZWZhdWx0cygpIHtcbiAgICB0aGlzLl9rUiA9IDAuNDk4NDtcbiAgICB0aGlzLl9rRyA9IDAuODYyNTtcbiAgICB0aGlzLl9rQiA9IDAuMjk3OTtcbiAgICB0aGlzLl9rQSA9IDE7XG4gIH1cbn07XG52YXIgTWFuaGF0dGFuQlQ3MDkgPSBjbGFzcyBleHRlbmRzIEFic3RyYWN0TWFuaGF0dGFuIHtcbiAgX3NldERlZmF1bHRzKCkge1xuICAgIHRoaXMuX2tSID0gMC4yMTI2IC8qIFJFRCAqLztcbiAgICB0aGlzLl9rRyA9IDAuNzE1MiAvKiBHUkVFTiAqLztcbiAgICB0aGlzLl9rQiA9IDAuMDcyMiAvKiBCTFVFICovO1xuICAgIHRoaXMuX2tBID0gMTtcbiAgfVxufTtcblxuLy8gc3JjL2Rpc3RhbmNlL3BuZ1F1YW50LnRzXG52YXIgUE5HUXVhbnQgPSBjbGFzcyBleHRlbmRzIEFic3RyYWN0RGlzdGFuY2VDYWxjdWxhdG9yIHtcbiAgY2FsY3VsYXRlUmF3KHIxLCBnMSwgYjEsIGExLCByMiwgZzIsIGIyLCBhMikge1xuICAgIGNvbnN0IGFscGhhcyA9IChhMiAtIGExKSAqIHRoaXMuX3doaXRlUG9pbnQuYTtcbiAgICByZXR1cm4gdGhpcy5fY29sb3JkaWZmZXJlbmNlQ2gocjEgKiB0aGlzLl93aGl0ZVBvaW50LnIsIHIyICogdGhpcy5fd2hpdGVQb2ludC5yLCBhbHBoYXMpICsgdGhpcy5fY29sb3JkaWZmZXJlbmNlQ2goZzEgKiB0aGlzLl93aGl0ZVBvaW50LmcsIGcyICogdGhpcy5fd2hpdGVQb2ludC5nLCBhbHBoYXMpICsgdGhpcy5fY29sb3JkaWZmZXJlbmNlQ2goYjEgKiB0aGlzLl93aGl0ZVBvaW50LmIsIGIyICogdGhpcy5fd2hpdGVQb2ludC5iLCBhbHBoYXMpO1xuICB9XG4gIF9jb2xvcmRpZmZlcmVuY2VDaCh4MiwgeTIsIGFscGhhcykge1xuICAgIGNvbnN0IGJsYWNrID0geDIgLSB5MjtcbiAgICBjb25zdCB3aGl0ZSA9IGJsYWNrICsgYWxwaGFzO1xuICAgIHJldHVybiBibGFjayAqIGJsYWNrICsgd2hpdGUgKiB3aGl0ZTtcbiAgfVxuICBfc2V0RGVmYXVsdHMoKSB7XG4gIH1cbn07XG5cbi8vIHNyYy9wYWxldHRlL2luZGV4LnRzXG52YXIgcGFsZXR0ZV9leHBvcnRzID0ge307XG5fX2V4cG9ydChwYWxldHRlX2V4cG9ydHMsIHtcbiAgQWJzdHJhY3RQYWxldHRlUXVhbnRpemVyOiAoKSA9PiBBYnN0cmFjdFBhbGV0dGVRdWFudGl6ZXIsXG4gIENvbG9ySGlzdG9ncmFtOiAoKSA9PiBDb2xvckhpc3RvZ3JhbSxcbiAgTmV1UXVhbnQ6ICgpID0+IE5ldVF1YW50LFxuICBOZXVRdWFudEZsb2F0OiAoKSA9PiBOZXVRdWFudEZsb2F0LFxuICBSR0JRdWFudDogKCkgPT4gUkdCUXVhbnQsXG4gIFd1Q29sb3JDdWJlOiAoKSA9PiBXdUNvbG9yQ3ViZSxcbiAgV3VRdWFudDogKCkgPT4gV3VRdWFudFxufSk7XG5cbi8vIHNyYy9wYWxldHRlL3BhbGV0dGVRdWFudGl6ZXIudHNcbnZhciBBYnN0cmFjdFBhbGV0dGVRdWFudGl6ZXIgPSBjbGFzcyB7XG4gIHF1YW50aXplU3luYygpIHtcbiAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIHRoaXMucXVhbnRpemUoKSkge1xuICAgICAgaWYgKHZhbHVlLnBhbGV0dGUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLnBhbGV0dGU7XG4gICAgICB9XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcInVucmVhY2hhYmxlXCIpO1xuICB9XG59O1xuXG4vLyBzcmMvdXRpbHMvcG9pbnQudHNcbnZhciBQb2ludCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInJcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImdcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImJcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImFcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInVpbnQzMlwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwicmdiYVwiKTtcbiAgICB0aGlzLnVpbnQzMiA9IC0xID4+PiAwO1xuICAgIHRoaXMuciA9IHRoaXMuZyA9IHRoaXMuYiA9IHRoaXMuYSA9IDA7XG4gICAgdGhpcy5yZ2JhID0gbmV3IEFycmF5KDQpO1xuICAgIHRoaXMucmdiYVswXSA9IDA7XG4gICAgdGhpcy5yZ2JhWzFdID0gMDtcbiAgICB0aGlzLnJnYmFbMl0gPSAwO1xuICAgIHRoaXMucmdiYVszXSA9IDA7XG4gIH1cbiAgc3RhdGljIGNyZWF0ZUJ5UXVhZHJ1cGxldChxdWFkcnVwbGV0KSB7XG4gICAgY29uc3QgcG9pbnQgPSBuZXcgUG9pbnQoKTtcbiAgICBwb2ludC5yID0gcXVhZHJ1cGxldFswXSB8IDA7XG4gICAgcG9pbnQuZyA9IHF1YWRydXBsZXRbMV0gfCAwO1xuICAgIHBvaW50LmIgPSBxdWFkcnVwbGV0WzJdIHwgMDtcbiAgICBwb2ludC5hID0gcXVhZHJ1cGxldFszXSB8IDA7XG4gICAgcG9pbnQuX2xvYWRVSU5UMzIoKTtcbiAgICBwb2ludC5fbG9hZFF1YWRydXBsZXQoKTtcbiAgICByZXR1cm4gcG9pbnQ7XG4gIH1cbiAgc3RhdGljIGNyZWF0ZUJ5UkdCQShyZWQsIGdyZWVuLCBibHVlLCBhbHBoYSkge1xuICAgIGNvbnN0IHBvaW50ID0gbmV3IFBvaW50KCk7XG4gICAgcG9pbnQuciA9IHJlZCB8IDA7XG4gICAgcG9pbnQuZyA9IGdyZWVuIHwgMDtcbiAgICBwb2ludC5iID0gYmx1ZSB8IDA7XG4gICAgcG9pbnQuYSA9IGFscGhhIHwgMDtcbiAgICBwb2ludC5fbG9hZFVJTlQzMigpO1xuICAgIHBvaW50Ll9sb2FkUXVhZHJ1cGxldCgpO1xuICAgIHJldHVybiBwb2ludDtcbiAgfVxuICBzdGF0aWMgY3JlYXRlQnlVaW50MzIodWludDMyKSB7XG4gICAgY29uc3QgcG9pbnQgPSBuZXcgUG9pbnQoKTtcbiAgICBwb2ludC51aW50MzIgPSB1aW50MzIgPj4+IDA7XG4gICAgcG9pbnQuX2xvYWRSR0JBKCk7XG4gICAgcG9pbnQuX2xvYWRRdWFkcnVwbGV0KCk7XG4gICAgcmV0dXJuIHBvaW50O1xuICB9XG4gIGZyb20ocG9pbnQpIHtcbiAgICB0aGlzLnIgPSBwb2ludC5yO1xuICAgIHRoaXMuZyA9IHBvaW50Lmc7XG4gICAgdGhpcy5iID0gcG9pbnQuYjtcbiAgICB0aGlzLmEgPSBwb2ludC5hO1xuICAgIHRoaXMudWludDMyID0gcG9pbnQudWludDMyO1xuICAgIHRoaXMucmdiYVswXSA9IHBvaW50LnI7XG4gICAgdGhpcy5yZ2JhWzFdID0gcG9pbnQuZztcbiAgICB0aGlzLnJnYmFbMl0gPSBwb2ludC5iO1xuICAgIHRoaXMucmdiYVszXSA9IHBvaW50LmE7XG4gIH1cbiAgZ2V0THVtaW5vc2l0eSh1c2VBbHBoYUNoYW5uZWwpIHtcbiAgICBsZXQgciA9IHRoaXMucjtcbiAgICBsZXQgZyA9IHRoaXMuZztcbiAgICBsZXQgYiA9IHRoaXMuYjtcbiAgICBpZiAodXNlQWxwaGFDaGFubmVsKSB7XG4gICAgICByID0gTWF0aC5taW4oMjU1LCAyNTUgLSB0aGlzLmEgKyB0aGlzLmEgKiByIC8gMjU1KTtcbiAgICAgIGcgPSBNYXRoLm1pbigyNTUsIDI1NSAtIHRoaXMuYSArIHRoaXMuYSAqIGcgLyAyNTUpO1xuICAgICAgYiA9IE1hdGgubWluKDI1NSwgMjU1IC0gdGhpcy5hICsgdGhpcy5hICogYiAvIDI1NSk7XG4gICAgfVxuICAgIHJldHVybiByICogMC4yMTI2IC8qIFJFRCAqLyArIGcgKiAwLjcxNTIgLyogR1JFRU4gKi8gKyBiICogMC4wNzIyIC8qIEJMVUUgKi87XG4gIH1cbiAgX2xvYWRVSU5UMzIoKSB7XG4gICAgdGhpcy51aW50MzIgPSAodGhpcy5hIDw8IDI0IHwgdGhpcy5iIDw8IDE2IHwgdGhpcy5nIDw8IDggfCB0aGlzLnIpID4+PiAwO1xuICB9XG4gIF9sb2FkUkdCQSgpIHtcbiAgICB0aGlzLnIgPSB0aGlzLnVpbnQzMiAmIDI1NTtcbiAgICB0aGlzLmcgPSB0aGlzLnVpbnQzMiA+Pj4gOCAmIDI1NTtcbiAgICB0aGlzLmIgPSB0aGlzLnVpbnQzMiA+Pj4gMTYgJiAyNTU7XG4gICAgdGhpcy5hID0gdGhpcy51aW50MzIgPj4+IDI0ICYgMjU1O1xuICB9XG4gIF9sb2FkUXVhZHJ1cGxldCgpIHtcbiAgICB0aGlzLnJnYmFbMF0gPSB0aGlzLnI7XG4gICAgdGhpcy5yZ2JhWzFdID0gdGhpcy5nO1xuICAgIHRoaXMucmdiYVsyXSA9IHRoaXMuYjtcbiAgICB0aGlzLnJnYmFbM10gPSB0aGlzLmE7XG4gIH1cbn07XG5cbi8vIHNyYy91dGlscy9wb2ludENvbnRhaW5lci50c1xudmFyIFBvaW50Q29udGFpbmVyID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiX3BvaW50QXJyYXlcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIl93aWR0aFwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiX2hlaWdodFwiKTtcbiAgICB0aGlzLl93aWR0aCA9IDA7XG4gICAgdGhpcy5faGVpZ2h0ID0gMDtcbiAgICB0aGlzLl9wb2ludEFycmF5ID0gW107XG4gIH1cbiAgZ2V0V2lkdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dpZHRoO1xuICB9XG4gIGdldEhlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5faGVpZ2h0O1xuICB9XG4gIHNldFdpZHRoKHdpZHRoKSB7XG4gICAgdGhpcy5fd2lkdGggPSB3aWR0aDtcbiAgfVxuICBzZXRIZWlnaHQoaGVpZ2h0KSB7XG4gICAgdGhpcy5faGVpZ2h0ID0gaGVpZ2h0O1xuICB9XG4gIGdldFBvaW50QXJyYXkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BvaW50QXJyYXk7XG4gIH1cbiAgY2xvbmUoKSB7XG4gICAgY29uc3QgY2xvbmUgPSBuZXcgUG9pbnRDb250YWluZXIoKTtcbiAgICBjbG9uZS5fd2lkdGggPSB0aGlzLl93aWR0aDtcbiAgICBjbG9uZS5faGVpZ2h0ID0gdGhpcy5faGVpZ2h0O1xuICAgIGZvciAobGV0IGkgPSAwLCBsID0gdGhpcy5fcG9pbnRBcnJheS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGNsb25lLl9wb2ludEFycmF5W2ldID0gUG9pbnQuY3JlYXRlQnlVaW50MzIodGhpcy5fcG9pbnRBcnJheVtpXS51aW50MzIgfCAwKTtcbiAgICB9XG4gICAgcmV0dXJuIGNsb25lO1xuICB9XG4gIHRvVWludDMyQXJyYXkoKSB7XG4gICAgY29uc3QgbCA9IHRoaXMuX3BvaW50QXJyYXkubGVuZ3RoO1xuICAgIGNvbnN0IHVpbnQzMkFycmF5ID0gbmV3IFVpbnQzMkFycmF5KGwpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICB1aW50MzJBcnJheVtpXSA9IHRoaXMuX3BvaW50QXJyYXlbaV0udWludDMyO1xuICAgIH1cbiAgICByZXR1cm4gdWludDMyQXJyYXk7XG4gIH1cbiAgdG9VaW50OEFycmF5KCkge1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheSh0aGlzLnRvVWludDMyQXJyYXkoKS5idWZmZXIpO1xuICB9XG4gIHN0YXRpYyBmcm9tSFRNTEltYWdlRWxlbWVudChpbWcpIHtcbiAgICBjb25zdCB3aWR0aCA9IGltZy5uYXR1cmFsV2lkdGg7XG4gICAgY29uc3QgaGVpZ2h0ID0gaW1nLm5hdHVyYWxIZWlnaHQ7XG4gICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgICBjYW52YXMud2lkdGggPSB3aWR0aDtcbiAgICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgY3R4LmRyYXdJbWFnZShpbWcsIDAsIDAsIHdpZHRoLCBoZWlnaHQsIDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgIHJldHVybiBQb2ludENvbnRhaW5lci5mcm9tSFRNTENhbnZhc0VsZW1lbnQoY2FudmFzKTtcbiAgfVxuICBzdGF0aWMgZnJvbUhUTUxDYW52YXNFbGVtZW50KGNhbnZhcykge1xuICAgIGNvbnN0IHdpZHRoID0gY2FudmFzLndpZHRoO1xuICAgIGNvbnN0IGhlaWdodCA9IGNhbnZhcy5oZWlnaHQ7XG4gICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICBjb25zdCBpbWdEYXRhID0gY3R4LmdldEltYWdlRGF0YSgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICByZXR1cm4gUG9pbnRDb250YWluZXIuZnJvbUltYWdlRGF0YShpbWdEYXRhKTtcbiAgfVxuICBzdGF0aWMgZnJvbUltYWdlRGF0YShpbWFnZURhdGEpIHtcbiAgICBjb25zdCB3aWR0aCA9IGltYWdlRGF0YS53aWR0aDtcbiAgICBjb25zdCBoZWlnaHQgPSBpbWFnZURhdGEuaGVpZ2h0O1xuICAgIHJldHVybiBQb2ludENvbnRhaW5lci5mcm9tVWludDhBcnJheShpbWFnZURhdGEuZGF0YSwgd2lkdGgsIGhlaWdodCk7XG4gIH1cbiAgc3RhdGljIGZyb21VaW50OEFycmF5KHVpbnQ4QXJyYXksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICBzd2l0Y2ggKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh1aW50OEFycmF5KSkge1xuICAgICAgY2FzZSBcIltvYmplY3QgVWludDhDbGFtcGVkQXJyYXldXCI6XG4gICAgICBjYXNlIFwiW29iamVjdCBVaW50OEFycmF5XVwiOlxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHVpbnQ4QXJyYXkgPSBuZXcgVWludDhBcnJheSh1aW50OEFycmF5KTtcbiAgICB9XG4gICAgY29uc3QgdWludDMyQXJyYXkgPSBuZXcgVWludDMyQXJyYXkodWludDhBcnJheS5idWZmZXIpO1xuICAgIHJldHVybiBQb2ludENvbnRhaW5lci5mcm9tVWludDMyQXJyYXkodWludDMyQXJyYXksIHdpZHRoLCBoZWlnaHQpO1xuICB9XG4gIHN0YXRpYyBmcm9tVWludDMyQXJyYXkodWludDMyQXJyYXksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICBjb25zdCBjb250YWluZXIgPSBuZXcgUG9pbnRDb250YWluZXIoKTtcbiAgICBjb250YWluZXIuX3dpZHRoID0gd2lkdGg7XG4gICAgY29udGFpbmVyLl9oZWlnaHQgPSBoZWlnaHQ7XG4gICAgZm9yIChsZXQgaSA9IDAsIGwgPSB1aW50MzJBcnJheS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGNvbnRhaW5lci5fcG9pbnRBcnJheVtpXSA9IFBvaW50LmNyZWF0ZUJ5VWludDMyKHVpbnQzMkFycmF5W2ldIHwgMCk7XG4gICAgfVxuICAgIHJldHVybiBjb250YWluZXI7XG4gIH1cbiAgc3RhdGljIGZyb21CdWZmZXIoYnVmZmVyLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgY29uc3QgdWludDMyQXJyYXkgPSBuZXcgVWludDMyQXJyYXkoYnVmZmVyLmJ1ZmZlciwgYnVmZmVyLmJ5dGVPZmZzZXQsIGJ1ZmZlci5ieXRlTGVuZ3RoIC8gVWludDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQpO1xuICAgIHJldHVybiBQb2ludENvbnRhaW5lci5mcm9tVWludDMyQXJyYXkodWludDMyQXJyYXksIHdpZHRoLCBoZWlnaHQpO1xuICB9XG59O1xuXG4vLyBzcmMvdXRpbHMvcGFsZXR0ZS50c1xudmFyIGh1ZUdyb3VwcyA9IDEwO1xuZnVuY3Rpb24gaHVlR3JvdXAoaHVlLCBzZWdtZW50c051bWJlcikge1xuICBjb25zdCBtYXhIdWUgPSAzNjA7XG4gIGNvbnN0IHNlZyA9IG1heEh1ZSAvIHNlZ21lbnRzTnVtYmVyO1xuICBjb25zdCBoYWxmID0gc2VnIC8gMjtcbiAgZm9yIChsZXQgaSA9IDEsIG1pZCA9IHNlZyAtIGhhbGY7IGkgPCBzZWdtZW50c051bWJlcjsgaSsrLCBtaWQgKz0gc2VnKSB7XG4gICAgaWYgKGh1ZSA+PSBtaWQgJiYgaHVlIDwgbWlkICsgc2VnKVxuICAgICAgcmV0dXJuIGk7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG52YXIgUGFsZXR0ZSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIl9wb2ludENvbnRhaW5lclwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiX3BvaW50QXJyYXlcIiwgW10pO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJfaTMyaWR4XCIsIHt9KTtcbiAgICB0aGlzLl9wb2ludENvbnRhaW5lciA9IG5ldyBQb2ludENvbnRhaW5lcigpO1xuICAgIHRoaXMuX3BvaW50Q29udGFpbmVyLnNldEhlaWdodCgxKTtcbiAgICB0aGlzLl9wb2ludEFycmF5ID0gdGhpcy5fcG9pbnRDb250YWluZXIuZ2V0UG9pbnRBcnJheSgpO1xuICB9XG4gIGFkZChjb2xvcikge1xuICAgIHRoaXMuX3BvaW50QXJyYXkucHVzaChjb2xvcik7XG4gICAgdGhpcy5fcG9pbnRDb250YWluZXIuc2V0V2lkdGgodGhpcy5fcG9pbnRBcnJheS5sZW5ndGgpO1xuICB9XG4gIGhhcyhjb2xvcikge1xuICAgIGZvciAobGV0IGkgPSB0aGlzLl9wb2ludEFycmF5Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBpZiAoY29sb3IudWludDMyID09PSB0aGlzLl9wb2ludEFycmF5W2ldLnVpbnQzMilcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBnZXROZWFyZXN0Q29sb3IoY29sb3JEaXN0YW5jZUNhbGN1bGF0b3IsIGNvbG9yKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BvaW50QXJyYXlbdGhpcy5fZ2V0TmVhcmVzdEluZGV4KGNvbG9yRGlzdGFuY2VDYWxjdWxhdG9yLCBjb2xvcikgfCAwXTtcbiAgfVxuICBnZXRQb2ludENvbnRhaW5lcigpIHtcbiAgICByZXR1cm4gdGhpcy5fcG9pbnRDb250YWluZXI7XG4gIH1cbiAgX25lYXJlc3RQb2ludEZyb21DYWNoZShrZXkpIHtcbiAgICByZXR1cm4gdHlwZW9mIHRoaXMuX2kzMmlkeFtrZXldID09PSBcIm51bWJlclwiID8gdGhpcy5faTMyaWR4W2tleV0gOiAtMTtcbiAgfVxuICBfZ2V0TmVhcmVzdEluZGV4KGNvbG9yRGlzdGFuY2VDYWxjdWxhdG9yLCBwb2ludCkge1xuICAgIGxldCBpZHggPSB0aGlzLl9uZWFyZXN0UG9pbnRGcm9tQ2FjaGUoXCJcIiArIHBvaW50LnVpbnQzMik7XG4gICAgaWYgKGlkeCA+PSAwKVxuICAgICAgcmV0dXJuIGlkeDtcbiAgICBsZXQgbWluaW1hbERpc3RhbmNlID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICBpZHggPSAwO1xuICAgIGZvciAobGV0IGkgPSAwLCBsID0gdGhpcy5fcG9pbnRBcnJheS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGNvbnN0IHAgPSB0aGlzLl9wb2ludEFycmF5W2ldO1xuICAgICAgY29uc3QgZGlzdGFuY2UgPSBjb2xvckRpc3RhbmNlQ2FsY3VsYXRvci5jYWxjdWxhdGVSYXcocG9pbnQuciwgcG9pbnQuZywgcG9pbnQuYiwgcG9pbnQuYSwgcC5yLCBwLmcsIHAuYiwgcC5hKTtcbiAgICAgIGlmIChkaXN0YW5jZSA8IG1pbmltYWxEaXN0YW5jZSkge1xuICAgICAgICBtaW5pbWFsRGlzdGFuY2UgPSBkaXN0YW5jZTtcbiAgICAgICAgaWR4ID0gaTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5faTMyaWR4W3BvaW50LnVpbnQzMl0gPSBpZHg7XG4gICAgcmV0dXJuIGlkeDtcbiAgfVxuICBzb3J0KCkge1xuICAgIHRoaXMuX2kzMmlkeCA9IHt9O1xuICAgIHRoaXMuX3BvaW50QXJyYXkuc29ydCgoYSwgYikgPT4ge1xuICAgICAgY29uc3QgaHNsQSA9IHJnYjJoc2woYS5yLCBhLmcsIGEuYik7XG4gICAgICBjb25zdCBoc2xCID0gcmdiMmhzbChiLnIsIGIuZywgYi5iKTtcbiAgICAgIGNvbnN0IGh1ZUEgPSBhLnIgPT09IGEuZyAmJiBhLmcgPT09IGEuYiA/IDAgOiAxICsgaHVlR3JvdXAoaHNsQS5oLCBodWVHcm91cHMpO1xuICAgICAgY29uc3QgaHVlQiA9IGIuciA9PT0gYi5nICYmIGIuZyA9PT0gYi5iID8gMCA6IDEgKyBodWVHcm91cChoc2xCLmgsIGh1ZUdyb3Vwcyk7XG4gICAgICBjb25zdCBodWVEaWZmID0gaHVlQiAtIGh1ZUE7XG4gICAgICBpZiAoaHVlRGlmZilcbiAgICAgICAgcmV0dXJuIC1odWVEaWZmO1xuICAgICAgY29uc3QgbEEgPSBhLmdldEx1bWlub3NpdHkodHJ1ZSk7XG4gICAgICBjb25zdCBsQiA9IGIuZ2V0THVtaW5vc2l0eSh0cnVlKTtcbiAgICAgIGlmIChsQiAtIGxBICE9PSAwKVxuICAgICAgICByZXR1cm4gbEIgLSBsQTtcbiAgICAgIGNvbnN0IHNhdERpZmYgPSAoaHNsQi5zICogMTAwIHwgMCkgLSAoaHNsQS5zICogMTAwIHwgMCk7XG4gICAgICBpZiAoc2F0RGlmZilcbiAgICAgICAgcmV0dXJuIC1zYXREaWZmO1xuICAgICAgcmV0dXJuIDA7XG4gICAgfSk7XG4gIH1cbn07XG5cbi8vIHNyYy91dGlscy9pbmRleC50c1xudmFyIHV0aWxzX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KHV0aWxzX2V4cG9ydHMsIHtcbiAgSHVlU3RhdGlzdGljczogKCkgPT4gSHVlU3RhdGlzdGljcyxcbiAgUGFsZXR0ZTogKCkgPT4gUGFsZXR0ZSxcbiAgUG9pbnQ6ICgpID0+IFBvaW50LFxuICBQb2ludENvbnRhaW5lcjogKCkgPT4gUG9pbnRDb250YWluZXIsXG4gIFByb2dyZXNzVHJhY2tlcjogKCkgPT4gUHJvZ3Jlc3NUcmFja2VyLFxuICBhcml0aG1ldGljOiAoKSA9PiBhcml0aG1ldGljX2V4cG9ydHNcbn0pO1xuXG4vLyBzcmMvdXRpbHMvaHVlU3RhdGlzdGljcy50c1xudmFyIEh1ZUdyb3VwID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwibnVtXCIsIDApO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJjb2xzXCIsIFtdKTtcbiAgfVxufTtcbnZhciBIdWVTdGF0aXN0aWNzID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihudW1Hcm91cHMsIG1pbkNvbHMpIHtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiX251bUdyb3Vwc1wiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiX21pbkNvbHNcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIl9zdGF0c1wiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiX2dyb3Vwc0Z1bGxcIik7XG4gICAgdGhpcy5fbnVtR3JvdXBzID0gbnVtR3JvdXBzO1xuICAgIHRoaXMuX21pbkNvbHMgPSBtaW5Db2xzO1xuICAgIHRoaXMuX3N0YXRzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gbnVtR3JvdXBzOyBpKyspIHtcbiAgICAgIHRoaXMuX3N0YXRzW2ldID0gbmV3IEh1ZUdyb3VwKCk7XG4gICAgfVxuICAgIHRoaXMuX2dyb3Vwc0Z1bGwgPSAwO1xuICB9XG4gIGNoZWNrKGkzMikge1xuICAgIGlmICh0aGlzLl9ncm91cHNGdWxsID09PSB0aGlzLl9udW1Hcm91cHMgKyAxKSB7XG4gICAgICB0aGlzLmNoZWNrID0gKCkgPT4ge1xuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgciA9IGkzMiAmIDI1NTtcbiAgICBjb25zdCBnID0gaTMyID4+PiA4ICYgMjU1O1xuICAgIGNvbnN0IGIgPSBpMzIgPj4+IDE2ICYgMjU1O1xuICAgIGNvbnN0IGhnID0gciA9PT0gZyAmJiBnID09PSBiID8gMCA6IDEgKyBodWVHcm91cChyZ2IyaHNsKHIsIGcsIGIpLmgsIHRoaXMuX251bUdyb3Vwcyk7XG4gICAgY29uc3QgZ3IgPSB0aGlzLl9zdGF0c1toZ107XG4gICAgY29uc3QgbWluID0gdGhpcy5fbWluQ29scztcbiAgICBnci5udW0rKztcbiAgICBpZiAoZ3IubnVtID4gbWluKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChnci5udW0gPT09IG1pbikge1xuICAgICAgdGhpcy5fZ3JvdXBzRnVsbCsrO1xuICAgIH1cbiAgICBpZiAoZ3IubnVtIDw9IG1pbikge1xuICAgICAgdGhpcy5fc3RhdHNbaGddLmNvbHMucHVzaChpMzIpO1xuICAgIH1cbiAgfVxuICBpbmplY3RJbnRvRGljdGlvbmFyeShoaXN0Rykge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IHRoaXMuX251bUdyb3VwczsgaSsrKSB7XG4gICAgICBpZiAodGhpcy5fc3RhdHNbaV0ubnVtIDw9IHRoaXMuX21pbkNvbHMpIHtcbiAgICAgICAgdGhpcy5fc3RhdHNbaV0uY29scy5mb3JFYWNoKChjb2wpID0+IHtcbiAgICAgICAgICBpZiAoIWhpc3RHW2NvbF0pIHtcbiAgICAgICAgICAgIGhpc3RHW2NvbF0gPSAxO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBoaXN0R1tjb2xdKys7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaW5qZWN0SW50b0FycmF5KGhpc3RHKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gdGhpcy5fbnVtR3JvdXBzOyBpKyspIHtcbiAgICAgIGlmICh0aGlzLl9zdGF0c1tpXS5udW0gPD0gdGhpcy5fbWluQ29scykge1xuICAgICAgICB0aGlzLl9zdGF0c1tpXS5jb2xzLmZvckVhY2goKGNvbCkgPT4ge1xuICAgICAgICAgIGlmIChoaXN0Ry5pbmRleE9mKGNvbCkgPT09IC0xKSB7XG4gICAgICAgICAgICBoaXN0Ry5wdXNoKGNvbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy91dGlscy9wcm9ncmVzc1RyYWNrZXIudHNcbnZhciBfUHJvZ3Jlc3NUcmFja2VyID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcih2YWx1ZVJhbmdlLCBwcm9ncmVzc1JhbmdlKSB7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInByb2dyZXNzXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJfc3RlcFwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiX3JhbmdlXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJfbGFzdFwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiX3Byb2dyZXNzUmFuZ2VcIik7XG4gICAgdGhpcy5fcmFuZ2UgPSB2YWx1ZVJhbmdlO1xuICAgIHRoaXMuX3Byb2dyZXNzUmFuZ2UgPSBwcm9ncmVzc1JhbmdlO1xuICAgIHRoaXMuX3N0ZXAgPSBNYXRoLm1heCgxLCB0aGlzLl9yYW5nZSAvIChfUHJvZ3Jlc3NUcmFja2VyLnN0ZXBzICsgMSkgfCAwKTtcbiAgICB0aGlzLl9sYXN0ID0gLXRoaXMuX3N0ZXA7XG4gICAgdGhpcy5wcm9ncmVzcyA9IDA7XG4gIH1cbiAgc2hvdWxkTm90aWZ5KGN1cnJlbnQpIHtcbiAgICBpZiAoY3VycmVudCAtIHRoaXMuX2xhc3QgPj0gdGhpcy5fc3RlcCkge1xuICAgICAgdGhpcy5fbGFzdCA9IGN1cnJlbnQ7XG4gICAgICB0aGlzLnByb2dyZXNzID0gTWF0aC5taW4odGhpcy5fcHJvZ3Jlc3NSYW5nZSAqIHRoaXMuX2xhc3QgLyB0aGlzLl9yYW5nZSwgdGhpcy5fcHJvZ3Jlc3NSYW5nZSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xudmFyIFByb2dyZXNzVHJhY2tlciA9IF9Qcm9ncmVzc1RyYWNrZXI7XG5fX3B1YmxpY0ZpZWxkKFByb2dyZXNzVHJhY2tlciwgXCJzdGVwc1wiLCAxMDApO1xuXG4vLyBzcmMvcGFsZXR0ZS9uZXVxdWFudC9uZXVxdWFudC50c1xudmFyIG5ldHdvcmtCaWFzU2hpZnQgPSAzO1xudmFyIE5ldXJvbiA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoZGVmYXVsdFZhbHVlKSB7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInJcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImdcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImJcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImFcIik7XG4gICAgdGhpcy5yID0gdGhpcy5nID0gdGhpcy5iID0gdGhpcy5hID0gZGVmYXVsdFZhbHVlO1xuICB9XG4gIHRvUG9pbnQoKSB7XG4gICAgcmV0dXJuIFBvaW50LmNyZWF0ZUJ5UkdCQSh0aGlzLnIgPj4gbmV0d29ya0JpYXNTaGlmdCwgdGhpcy5nID4+IG5ldHdvcmtCaWFzU2hpZnQsIHRoaXMuYiA+PiBuZXR3b3JrQmlhc1NoaWZ0LCB0aGlzLmEgPj4gbmV0d29ya0JpYXNTaGlmdCk7XG4gIH1cbiAgc3VidHJhY3QociwgZywgYiwgYSkge1xuICAgIHRoaXMuciAtPSByIHwgMDtcbiAgICB0aGlzLmcgLT0gZyB8IDA7XG4gICAgdGhpcy5iIC09IGIgfCAwO1xuICAgIHRoaXMuYSAtPSBhIHwgMDtcbiAgfVxufTtcbnZhciBfTmV1UXVhbnQgPSBjbGFzcyBleHRlbmRzIEFic3RyYWN0UGFsZXR0ZVF1YW50aXplciB7XG4gIGNvbnN0cnVjdG9yKGNvbG9yRGlzdGFuY2VDYWxjdWxhdG9yLCBjb2xvcnMgPSAyNTYpIHtcbiAgICBzdXBlcigpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJfcG9pbnRBcnJheVwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiX25ldHdvcmtTaXplXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJfbmV0d29ya1wiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiX3NhbXBsZUZhY3RvclwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiX3JhZFBvd2VyXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJfZnJlcVwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiX2JpYXNcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIl9kaXN0YW5jZVwiKTtcbiAgICB0aGlzLl9kaXN0YW5jZSA9IGNvbG9yRGlzdGFuY2VDYWxjdWxhdG9yO1xuICAgIHRoaXMuX3BvaW50QXJyYXkgPSBbXTtcbiAgICB0aGlzLl9zYW1wbGVGYWN0b3IgPSAxO1xuICAgIHRoaXMuX25ldHdvcmtTaXplID0gY29sb3JzO1xuICAgIHRoaXMuX2Rpc3RhbmNlLnNldFdoaXRlUG9pbnQoMjU1IDw8IG5ldHdvcmtCaWFzU2hpZnQsIDI1NSA8PCBuZXR3b3JrQmlhc1NoaWZ0LCAyNTUgPDwgbmV0d29ya0JpYXNTaGlmdCwgMjU1IDw8IG5ldHdvcmtCaWFzU2hpZnQpO1xuICB9XG4gIHNhbXBsZShwb2ludENvbnRhaW5lcikge1xuICAgIHRoaXMuX3BvaW50QXJyYXkgPSB0aGlzLl9wb2ludEFycmF5LmNvbmNhdChwb2ludENvbnRhaW5lci5nZXRQb2ludEFycmF5KCkpO1xuICB9XG4gICpxdWFudGl6ZSgpIHtcbiAgICB0aGlzLl9pbml0KCk7XG4gICAgeWllbGQqIHRoaXMuX2xlYXJuKCk7XG4gICAgeWllbGQge1xuICAgICAgcGFsZXR0ZTogdGhpcy5fYnVpbGRQYWxldHRlKCksXG4gICAgICBwcm9ncmVzczogMTAwXG4gICAgfTtcbiAgfVxuICBfaW5pdCgpIHtcbiAgICB0aGlzLl9mcmVxID0gW107XG4gICAgdGhpcy5fYmlhcyA9IFtdO1xuICAgIHRoaXMuX3JhZFBvd2VyID0gW107XG4gICAgdGhpcy5fbmV0d29yayA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fbmV0d29ya1NpemU7IGkrKykge1xuICAgICAgdGhpcy5fbmV0d29ya1tpXSA9IG5ldyBOZXVyb24oKGkgPDwgbmV0d29ya0JpYXNTaGlmdCArIDgpIC8gdGhpcy5fbmV0d29ya1NpemUgfCAwKTtcbiAgICAgIHRoaXMuX2ZyZXFbaV0gPSBfTmV1UXVhbnQuX2luaXRpYWxCaWFzIC8gdGhpcy5fbmV0d29ya1NpemUgfCAwO1xuICAgICAgdGhpcy5fYmlhc1tpXSA9IDA7XG4gICAgfVxuICB9XG4gICpfbGVhcm4oKSB7XG4gICAgbGV0IHNhbXBsZUZhY3RvciA9IHRoaXMuX3NhbXBsZUZhY3RvcjtcbiAgICBjb25zdCBwb2ludHNOdW1iZXIgPSB0aGlzLl9wb2ludEFycmF5Lmxlbmd0aDtcbiAgICBpZiAocG9pbnRzTnVtYmVyIDwgX05ldVF1YW50Ll9taW5waWN0dXJlYnl0ZXMpXG4gICAgICBzYW1wbGVGYWN0b3IgPSAxO1xuICAgIGNvbnN0IGFscGhhZGVjID0gMzAgKyAoc2FtcGxlRmFjdG9yIC0gMSkgLyAzIHwgMDtcbiAgICBjb25zdCBwb2ludHNUb1NhbXBsZSA9IHBvaW50c051bWJlciAvIHNhbXBsZUZhY3RvciB8IDA7XG4gICAgbGV0IGRlbHRhID0gcG9pbnRzVG9TYW1wbGUgLyBfTmV1UXVhbnQuX25DeWNsZXMgfCAwO1xuICAgIGxldCBhbHBoYSA9IF9OZXVRdWFudC5faW5pdEFscGhhO1xuICAgIGxldCByYWRpdXMgPSAodGhpcy5fbmV0d29ya1NpemUgPj4gMykgKiBfTmV1UXVhbnQuX3JhZGl1c0JpYXM7XG4gICAgbGV0IHJhZCA9IHJhZGl1cyA+PiBfTmV1UXVhbnQuX3JhZGl1c0JpYXNTaGlmdDtcbiAgICBpZiAocmFkIDw9IDEpXG4gICAgICByYWQgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmFkOyBpKyspIHtcbiAgICAgIHRoaXMuX3JhZFBvd2VyW2ldID0gYWxwaGEgKiAoKHJhZCAqIHJhZCAtIGkgKiBpKSAqIF9OZXVRdWFudC5fcmFkQmlhcyAvIChyYWQgKiByYWQpKSA+Pj4gMDtcbiAgICB9XG4gICAgbGV0IHN0ZXA7XG4gICAgaWYgKHBvaW50c051bWJlciA8IF9OZXVRdWFudC5fbWlucGljdHVyZWJ5dGVzKSB7XG4gICAgICBzdGVwID0gMTtcbiAgICB9IGVsc2UgaWYgKHBvaW50c051bWJlciAlIF9OZXVRdWFudC5fcHJpbWUxICE9PSAwKSB7XG4gICAgICBzdGVwID0gX05ldVF1YW50Ll9wcmltZTE7XG4gICAgfSBlbHNlIGlmIChwb2ludHNOdW1iZXIgJSBfTmV1UXVhbnQuX3ByaW1lMiAhPT0gMCkge1xuICAgICAgc3RlcCA9IF9OZXVRdWFudC5fcHJpbWUyO1xuICAgIH0gZWxzZSBpZiAocG9pbnRzTnVtYmVyICUgX05ldVF1YW50Ll9wcmltZTMgIT09IDApIHtcbiAgICAgIHN0ZXAgPSBfTmV1UXVhbnQuX3ByaW1lMztcbiAgICB9IGVsc2Uge1xuICAgICAgc3RlcCA9IF9OZXVRdWFudC5fcHJpbWU0O1xuICAgIH1cbiAgICBjb25zdCB0cmFja2VyID0gbmV3IFByb2dyZXNzVHJhY2tlcihwb2ludHNUb1NhbXBsZSwgOTkpO1xuICAgIGZvciAobGV0IGkgPSAwLCBwb2ludEluZGV4ID0gMDsgaSA8IHBvaW50c1RvU2FtcGxlOyApIHtcbiAgICAgIGlmICh0cmFja2VyLnNob3VsZE5vdGlmeShpKSkge1xuICAgICAgICB5aWVsZCB7XG4gICAgICAgICAgcHJvZ3Jlc3M6IHRyYWNrZXIucHJvZ3Jlc3NcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHBvaW50ID0gdGhpcy5fcG9pbnRBcnJheVtwb2ludEluZGV4XTtcbiAgICAgIGNvbnN0IGIgPSBwb2ludC5iIDw8IG5ldHdvcmtCaWFzU2hpZnQ7XG4gICAgICBjb25zdCBnID0gcG9pbnQuZyA8PCBuZXR3b3JrQmlhc1NoaWZ0O1xuICAgICAgY29uc3QgciA9IHBvaW50LnIgPDwgbmV0d29ya0JpYXNTaGlmdDtcbiAgICAgIGNvbnN0IGEgPSBwb2ludC5hIDw8IG5ldHdvcmtCaWFzU2hpZnQ7XG4gICAgICBjb25zdCBuZXVyb25JbmRleCA9IHRoaXMuX2NvbnRlc3QoYiwgZywgciwgYSk7XG4gICAgICB0aGlzLl9hbHRlclNpbmdsZShhbHBoYSwgbmV1cm9uSW5kZXgsIGIsIGcsIHIsIGEpO1xuICAgICAgaWYgKHJhZCAhPT0gMClcbiAgICAgICAgdGhpcy5fYWx0ZXJOZWlnaGJvdXIocmFkLCBuZXVyb25JbmRleCwgYiwgZywgciwgYSk7XG4gICAgICBwb2ludEluZGV4ICs9IHN0ZXA7XG4gICAgICBpZiAocG9pbnRJbmRleCA+PSBwb2ludHNOdW1iZXIpXG4gICAgICAgIHBvaW50SW5kZXggLT0gcG9pbnRzTnVtYmVyO1xuICAgICAgaSsrO1xuICAgICAgaWYgKGRlbHRhID09PSAwKVxuICAgICAgICBkZWx0YSA9IDE7XG4gICAgICBpZiAoaSAlIGRlbHRhID09PSAwKSB7XG4gICAgICAgIGFscGhhIC09IGFscGhhIC8gYWxwaGFkZWMgfCAwO1xuICAgICAgICByYWRpdXMgLT0gcmFkaXVzIC8gX05ldVF1YW50Ll9yYWRpdXNEZWNyZWFzZSB8IDA7XG4gICAgICAgIHJhZCA9IHJhZGl1cyA+PiBfTmV1UXVhbnQuX3JhZGl1c0JpYXNTaGlmdDtcbiAgICAgICAgaWYgKHJhZCA8PSAxKVxuICAgICAgICAgIHJhZCA9IDA7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgcmFkOyBqKyspIHtcbiAgICAgICAgICB0aGlzLl9yYWRQb3dlcltqXSA9IGFscGhhICogKChyYWQgKiByYWQgLSBqICogaikgKiBfTmV1UXVhbnQuX3JhZEJpYXMgLyAocmFkICogcmFkKSkgPj4+IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgX2J1aWxkUGFsZXR0ZSgpIHtcbiAgICBjb25zdCBwYWxldHRlID0gbmV3IFBhbGV0dGUoKTtcbiAgICB0aGlzLl9uZXR3b3JrLmZvckVhY2goKG5ldXJvbikgPT4ge1xuICAgICAgcGFsZXR0ZS5hZGQobmV1cm9uLnRvUG9pbnQoKSk7XG4gICAgfSk7XG4gICAgcGFsZXR0ZS5zb3J0KCk7XG4gICAgcmV0dXJuIHBhbGV0dGU7XG4gIH1cbiAgX2FsdGVyTmVpZ2hib3VyKHJhZCwgaSwgYiwgZywgciwgYWwpIHtcbiAgICBsZXQgbG8gPSBpIC0gcmFkO1xuICAgIGlmIChsbyA8IC0xKVxuICAgICAgbG8gPSAtMTtcbiAgICBsZXQgaGkgPSBpICsgcmFkO1xuICAgIGlmIChoaSA+IHRoaXMuX25ldHdvcmtTaXplKVxuICAgICAgaGkgPSB0aGlzLl9uZXR3b3JrU2l6ZTtcbiAgICBsZXQgaiA9IGkgKyAxO1xuICAgIGxldCBrID0gaSAtIDE7XG4gICAgbGV0IG0gPSAxO1xuICAgIHdoaWxlIChqIDwgaGkgfHwgayA+IGxvKSB7XG4gICAgICBjb25zdCBhID0gdGhpcy5fcmFkUG93ZXJbbSsrXSAvIF9OZXVRdWFudC5fYWxwaGFSYWRCaWFzO1xuICAgICAgaWYgKGogPCBoaSkge1xuICAgICAgICBjb25zdCBwID0gdGhpcy5fbmV0d29ya1tqKytdO1xuICAgICAgICBwLnN1YnRyYWN0KGEgKiAocC5yIC0gciksIGEgKiAocC5nIC0gZyksIGEgKiAocC5iIC0gYiksIGEgKiAocC5hIC0gYWwpKTtcbiAgICAgIH1cbiAgICAgIGlmIChrID4gbG8pIHtcbiAgICAgICAgY29uc3QgcCA9IHRoaXMuX25ldHdvcmtbay0tXTtcbiAgICAgICAgcC5zdWJ0cmFjdChhICogKHAuciAtIHIpLCBhICogKHAuZyAtIGcpLCBhICogKHAuYiAtIGIpLCBhICogKHAuYSAtIGFsKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIF9hbHRlclNpbmdsZShhbHBoYSwgaSwgYiwgZywgciwgYSkge1xuICAgIGFscGhhIC89IF9OZXVRdWFudC5faW5pdEFscGhhO1xuICAgIGNvbnN0IG4gPSB0aGlzLl9uZXR3b3JrW2ldO1xuICAgIG4uc3VidHJhY3QoYWxwaGEgKiAobi5yIC0gciksIGFscGhhICogKG4uZyAtIGcpLCBhbHBoYSAqIChuLmIgLSBiKSwgYWxwaGEgKiAobi5hIC0gYSkpO1xuICB9XG4gIF9jb250ZXN0KGIsIGcsIHIsIGEpIHtcbiAgICBjb25zdCBtdWx0aXBsaWVyID0gMjU1ICogNCA8PCBuZXR3b3JrQmlhc1NoaWZ0O1xuICAgIGxldCBiZXN0ZCA9IH4oMSA8PCAzMSk7XG4gICAgbGV0IGJlc3RiaWFzZCA9IGJlc3RkO1xuICAgIGxldCBiZXN0cG9zID0gLTE7XG4gICAgbGV0IGJlc3RiaWFzcG9zID0gYmVzdHBvcztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX25ldHdvcmtTaXplOyBpKyspIHtcbiAgICAgIGNvbnN0IG4gPSB0aGlzLl9uZXR3b3JrW2ldO1xuICAgICAgY29uc3QgZGlzdCA9IHRoaXMuX2Rpc3RhbmNlLmNhbGN1bGF0ZU5vcm1hbGl6ZWQobiwgeyByLCBnLCBiLCBhIH0pICogbXVsdGlwbGllciB8IDA7XG4gICAgICBpZiAoZGlzdCA8IGJlc3RkKSB7XG4gICAgICAgIGJlc3RkID0gZGlzdDtcbiAgICAgICAgYmVzdHBvcyA9IGk7XG4gICAgICB9XG4gICAgICBjb25zdCBiaWFzZGlzdCA9IGRpc3QgLSAodGhpcy5fYmlhc1tpXSA+PiBfTmV1UXVhbnQuX2luaXRpYWxCaWFzU2hpZnQgLSBuZXR3b3JrQmlhc1NoaWZ0KTtcbiAgICAgIGlmIChiaWFzZGlzdCA8IGJlc3RiaWFzZCkge1xuICAgICAgICBiZXN0Ymlhc2QgPSBiaWFzZGlzdDtcbiAgICAgICAgYmVzdGJpYXNwb3MgPSBpO1xuICAgICAgfVxuICAgICAgY29uc3QgYmV0YWZyZXEgPSB0aGlzLl9mcmVxW2ldID4+IF9OZXVRdWFudC5fYmV0YVNoaWZ0O1xuICAgICAgdGhpcy5fZnJlcVtpXSAtPSBiZXRhZnJlcTtcbiAgICAgIHRoaXMuX2JpYXNbaV0gKz0gYmV0YWZyZXEgPDwgX05ldVF1YW50Ll9nYW1tYVNoaWZ0O1xuICAgIH1cbiAgICB0aGlzLl9mcmVxW2Jlc3Rwb3NdICs9IF9OZXVRdWFudC5fYmV0YTtcbiAgICB0aGlzLl9iaWFzW2Jlc3Rwb3NdIC09IF9OZXVRdWFudC5fYmV0YUdhbW1hO1xuICAgIHJldHVybiBiZXN0Ymlhc3BvcztcbiAgfVxufTtcbnZhciBOZXVRdWFudCA9IF9OZXVRdWFudDtcbl9fcHVibGljRmllbGQoTmV1UXVhbnQsIFwiX3ByaW1lMVwiLCA0OTkpO1xuX19wdWJsaWNGaWVsZChOZXVRdWFudCwgXCJfcHJpbWUyXCIsIDQ5MSk7XG5fX3B1YmxpY0ZpZWxkKE5ldVF1YW50LCBcIl9wcmltZTNcIiwgNDg3KTtcbl9fcHVibGljRmllbGQoTmV1UXVhbnQsIFwiX3ByaW1lNFwiLCA1MDMpO1xuX19wdWJsaWNGaWVsZChOZXVRdWFudCwgXCJfbWlucGljdHVyZWJ5dGVzXCIsIF9OZXVRdWFudC5fcHJpbWU0KTtcbl9fcHVibGljRmllbGQoTmV1UXVhbnQsIFwiX25DeWNsZXNcIiwgMTAwKTtcbl9fcHVibGljRmllbGQoTmV1UXVhbnQsIFwiX2luaXRpYWxCaWFzU2hpZnRcIiwgMTYpO1xuX19wdWJsaWNGaWVsZChOZXVRdWFudCwgXCJfaW5pdGlhbEJpYXNcIiwgMSA8PCBfTmV1UXVhbnQuX2luaXRpYWxCaWFzU2hpZnQpO1xuX19wdWJsaWNGaWVsZChOZXVRdWFudCwgXCJfZ2FtbWFTaGlmdFwiLCAxMCk7XG5fX3B1YmxpY0ZpZWxkKE5ldVF1YW50LCBcIl9iZXRhU2hpZnRcIiwgMTApO1xuX19wdWJsaWNGaWVsZChOZXVRdWFudCwgXCJfYmV0YVwiLCBfTmV1UXVhbnQuX2luaXRpYWxCaWFzID4+IF9OZXVRdWFudC5fYmV0YVNoaWZ0KTtcbl9fcHVibGljRmllbGQoTmV1UXVhbnQsIFwiX2JldGFHYW1tYVwiLCBfTmV1UXVhbnQuX2luaXRpYWxCaWFzIDw8IF9OZXVRdWFudC5fZ2FtbWFTaGlmdCAtIF9OZXVRdWFudC5fYmV0YVNoaWZ0KTtcbl9fcHVibGljRmllbGQoTmV1UXVhbnQsIFwiX3JhZGl1c0JpYXNTaGlmdFwiLCA2KTtcbl9fcHVibGljRmllbGQoTmV1UXVhbnQsIFwiX3JhZGl1c0JpYXNcIiwgMSA8PCBfTmV1UXVhbnQuX3JhZGl1c0JpYXNTaGlmdCk7XG5fX3B1YmxpY0ZpZWxkKE5ldVF1YW50LCBcIl9yYWRpdXNEZWNyZWFzZVwiLCAzMCk7XG5fX3B1YmxpY0ZpZWxkKE5ldVF1YW50LCBcIl9hbHBoYUJpYXNTaGlmdFwiLCAxMCk7XG5fX3B1YmxpY0ZpZWxkKE5ldVF1YW50LCBcIl9pbml0QWxwaGFcIiwgMSA8PCBfTmV1UXVhbnQuX2FscGhhQmlhc1NoaWZ0KTtcbl9fcHVibGljRmllbGQoTmV1UXVhbnQsIFwiX3JhZEJpYXNTaGlmdFwiLCA4KTtcbl9fcHVibGljRmllbGQoTmV1UXVhbnQsIFwiX3JhZEJpYXNcIiwgMSA8PCBfTmV1UXVhbnQuX3JhZEJpYXNTaGlmdCk7XG5fX3B1YmxpY0ZpZWxkKE5ldVF1YW50LCBcIl9hbHBoYVJhZEJpYXNTaGlmdFwiLCBfTmV1UXVhbnQuX2FscGhhQmlhc1NoaWZ0ICsgX05ldVF1YW50Ll9yYWRCaWFzU2hpZnQpO1xuX19wdWJsaWNGaWVsZChOZXVRdWFudCwgXCJfYWxwaGFSYWRCaWFzXCIsIDEgPDwgX05ldVF1YW50Ll9hbHBoYVJhZEJpYXNTaGlmdCk7XG5cbi8vIHNyYy9wYWxldHRlL25ldXF1YW50L25ldXF1YW50RmxvYXQudHNcbnZhciBuZXR3b3JrQmlhc1NoaWZ0MiA9IDM7XG52YXIgTmV1cm9uRmxvYXQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGRlZmF1bHRWYWx1ZSkge1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJyXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJnXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJiXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJhXCIpO1xuICAgIHRoaXMuciA9IHRoaXMuZyA9IHRoaXMuYiA9IHRoaXMuYSA9IGRlZmF1bHRWYWx1ZTtcbiAgfVxuICB0b1BvaW50KCkge1xuICAgIHJldHVybiBQb2ludC5jcmVhdGVCeVJHQkEodGhpcy5yID4+IG5ldHdvcmtCaWFzU2hpZnQyLCB0aGlzLmcgPj4gbmV0d29ya0JpYXNTaGlmdDIsIHRoaXMuYiA+PiBuZXR3b3JrQmlhc1NoaWZ0MiwgdGhpcy5hID4+IG5ldHdvcmtCaWFzU2hpZnQyKTtcbiAgfVxuICBzdWJ0cmFjdChyLCBnLCBiLCBhKSB7XG4gICAgdGhpcy5yIC09IHI7XG4gICAgdGhpcy5nIC09IGc7XG4gICAgdGhpcy5iIC09IGI7XG4gICAgdGhpcy5hIC09IGE7XG4gIH1cbn07XG52YXIgX05ldVF1YW50RmxvYXQgPSBjbGFzcyBleHRlbmRzIEFic3RyYWN0UGFsZXR0ZVF1YW50aXplciB7XG4gIGNvbnN0cnVjdG9yKGNvbG9yRGlzdGFuY2VDYWxjdWxhdG9yLCBjb2xvcnMgPSAyNTYpIHtcbiAgICBzdXBlcigpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJfcG9pbnRBcnJheVwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiX25ldHdvcmtTaXplXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJfbmV0d29ya1wiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiX3NhbXBsZUZhY3RvclwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiX3JhZFBvd2VyXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJfZnJlcVwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiX2JpYXNcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIl9kaXN0YW5jZVwiKTtcbiAgICB0aGlzLl9kaXN0YW5jZSA9IGNvbG9yRGlzdGFuY2VDYWxjdWxhdG9yO1xuICAgIHRoaXMuX3BvaW50QXJyYXkgPSBbXTtcbiAgICB0aGlzLl9zYW1wbGVGYWN0b3IgPSAxO1xuICAgIHRoaXMuX25ldHdvcmtTaXplID0gY29sb3JzO1xuICAgIHRoaXMuX2Rpc3RhbmNlLnNldFdoaXRlUG9pbnQoMjU1IDw8IG5ldHdvcmtCaWFzU2hpZnQyLCAyNTUgPDwgbmV0d29ya0JpYXNTaGlmdDIsIDI1NSA8PCBuZXR3b3JrQmlhc1NoaWZ0MiwgMjU1IDw8IG5ldHdvcmtCaWFzU2hpZnQyKTtcbiAgfVxuICBzYW1wbGUocG9pbnRDb250YWluZXIpIHtcbiAgICB0aGlzLl9wb2ludEFycmF5ID0gdGhpcy5fcG9pbnRBcnJheS5jb25jYXQocG9pbnRDb250YWluZXIuZ2V0UG9pbnRBcnJheSgpKTtcbiAgfVxuICAqcXVhbnRpemUoKSB7XG4gICAgdGhpcy5faW5pdCgpO1xuICAgIHlpZWxkKiB0aGlzLl9sZWFybigpO1xuICAgIHlpZWxkIHtcbiAgICAgIHBhbGV0dGU6IHRoaXMuX2J1aWxkUGFsZXR0ZSgpLFxuICAgICAgcHJvZ3Jlc3M6IDEwMFxuICAgIH07XG4gIH1cbiAgX2luaXQoKSB7XG4gICAgdGhpcy5fZnJlcSA9IFtdO1xuICAgIHRoaXMuX2JpYXMgPSBbXTtcbiAgICB0aGlzLl9yYWRQb3dlciA9IFtdO1xuICAgIHRoaXMuX25ldHdvcmsgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX25ldHdvcmtTaXplOyBpKyspIHtcbiAgICAgIHRoaXMuX25ldHdvcmtbaV0gPSBuZXcgTmV1cm9uRmxvYXQoKGkgPDwgbmV0d29ya0JpYXNTaGlmdDIgKyA4KSAvIHRoaXMuX25ldHdvcmtTaXplKTtcbiAgICAgIHRoaXMuX2ZyZXFbaV0gPSBfTmV1UXVhbnRGbG9hdC5faW5pdGlhbEJpYXMgLyB0aGlzLl9uZXR3b3JrU2l6ZTtcbiAgICAgIHRoaXMuX2JpYXNbaV0gPSAwO1xuICAgIH1cbiAgfVxuICAqX2xlYXJuKCkge1xuICAgIGxldCBzYW1wbGVGYWN0b3IgPSB0aGlzLl9zYW1wbGVGYWN0b3I7XG4gICAgY29uc3QgcG9pbnRzTnVtYmVyID0gdGhpcy5fcG9pbnRBcnJheS5sZW5ndGg7XG4gICAgaWYgKHBvaW50c051bWJlciA8IF9OZXVRdWFudEZsb2F0Ll9taW5waWN0dXJlYnl0ZXMpXG4gICAgICBzYW1wbGVGYWN0b3IgPSAxO1xuICAgIGNvbnN0IGFscGhhZGVjID0gMzAgKyAoc2FtcGxlRmFjdG9yIC0gMSkgLyAzO1xuICAgIGNvbnN0IHBvaW50c1RvU2FtcGxlID0gcG9pbnRzTnVtYmVyIC8gc2FtcGxlRmFjdG9yO1xuICAgIGxldCBkZWx0YSA9IHBvaW50c1RvU2FtcGxlIC8gX05ldVF1YW50RmxvYXQuX25DeWNsZXMgfCAwO1xuICAgIGxldCBhbHBoYSA9IF9OZXVRdWFudEZsb2F0Ll9pbml0QWxwaGE7XG4gICAgbGV0IHJhZGl1cyA9ICh0aGlzLl9uZXR3b3JrU2l6ZSA+PiAzKSAqIF9OZXVRdWFudEZsb2F0Ll9yYWRpdXNCaWFzO1xuICAgIGxldCByYWQgPSByYWRpdXMgPj4gX05ldVF1YW50RmxvYXQuX3JhZGl1c0JpYXNTaGlmdDtcbiAgICBpZiAocmFkIDw9IDEpXG4gICAgICByYWQgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmFkOyBpKyspIHtcbiAgICAgIHRoaXMuX3JhZFBvd2VyW2ldID0gYWxwaGEgKiAoKHJhZCAqIHJhZCAtIGkgKiBpKSAqIF9OZXVRdWFudEZsb2F0Ll9yYWRCaWFzIC8gKHJhZCAqIHJhZCkpO1xuICAgIH1cbiAgICBsZXQgc3RlcDtcbiAgICBpZiAocG9pbnRzTnVtYmVyIDwgX05ldVF1YW50RmxvYXQuX21pbnBpY3R1cmVieXRlcykge1xuICAgICAgc3RlcCA9IDE7XG4gICAgfSBlbHNlIGlmIChwb2ludHNOdW1iZXIgJSBfTmV1UXVhbnRGbG9hdC5fcHJpbWUxICE9PSAwKSB7XG4gICAgICBzdGVwID0gX05ldVF1YW50RmxvYXQuX3ByaW1lMTtcbiAgICB9IGVsc2UgaWYgKHBvaW50c051bWJlciAlIF9OZXVRdWFudEZsb2F0Ll9wcmltZTIgIT09IDApIHtcbiAgICAgIHN0ZXAgPSBfTmV1UXVhbnRGbG9hdC5fcHJpbWUyO1xuICAgIH0gZWxzZSBpZiAocG9pbnRzTnVtYmVyICUgX05ldVF1YW50RmxvYXQuX3ByaW1lMyAhPT0gMCkge1xuICAgICAgc3RlcCA9IF9OZXVRdWFudEZsb2F0Ll9wcmltZTM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ZXAgPSBfTmV1UXVhbnRGbG9hdC5fcHJpbWU0O1xuICAgIH1cbiAgICBjb25zdCB0cmFja2VyID0gbmV3IFByb2dyZXNzVHJhY2tlcihwb2ludHNUb1NhbXBsZSwgOTkpO1xuICAgIGZvciAobGV0IGkgPSAwLCBwb2ludEluZGV4ID0gMDsgaSA8IHBvaW50c1RvU2FtcGxlOyApIHtcbiAgICAgIGlmICh0cmFja2VyLnNob3VsZE5vdGlmeShpKSkge1xuICAgICAgICB5aWVsZCB7XG4gICAgICAgICAgcHJvZ3Jlc3M6IHRyYWNrZXIucHJvZ3Jlc3NcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHBvaW50ID0gdGhpcy5fcG9pbnRBcnJheVtwb2ludEluZGV4XTtcbiAgICAgIGNvbnN0IGIgPSBwb2ludC5iIDw8IG5ldHdvcmtCaWFzU2hpZnQyO1xuICAgICAgY29uc3QgZyA9IHBvaW50LmcgPDwgbmV0d29ya0JpYXNTaGlmdDI7XG4gICAgICBjb25zdCByID0gcG9pbnQuciA8PCBuZXR3b3JrQmlhc1NoaWZ0MjtcbiAgICAgIGNvbnN0IGEgPSBwb2ludC5hIDw8IG5ldHdvcmtCaWFzU2hpZnQyO1xuICAgICAgY29uc3QgbmV1cm9uSW5kZXggPSB0aGlzLl9jb250ZXN0KGIsIGcsIHIsIGEpO1xuICAgICAgdGhpcy5fYWx0ZXJTaW5nbGUoYWxwaGEsIG5ldXJvbkluZGV4LCBiLCBnLCByLCBhKTtcbiAgICAgIGlmIChyYWQgIT09IDApXG4gICAgICAgIHRoaXMuX2FsdGVyTmVpZ2hib3VyKHJhZCwgbmV1cm9uSW5kZXgsIGIsIGcsIHIsIGEpO1xuICAgICAgcG9pbnRJbmRleCArPSBzdGVwO1xuICAgICAgaWYgKHBvaW50SW5kZXggPj0gcG9pbnRzTnVtYmVyKVxuICAgICAgICBwb2ludEluZGV4IC09IHBvaW50c051bWJlcjtcbiAgICAgIGkrKztcbiAgICAgIGlmIChkZWx0YSA9PT0gMClcbiAgICAgICAgZGVsdGEgPSAxO1xuICAgICAgaWYgKGkgJSBkZWx0YSA9PT0gMCkge1xuICAgICAgICBhbHBoYSAtPSBhbHBoYSAvIGFscGhhZGVjO1xuICAgICAgICByYWRpdXMgLT0gcmFkaXVzIC8gX05ldVF1YW50RmxvYXQuX3JhZGl1c0RlY3JlYXNlO1xuICAgICAgICByYWQgPSByYWRpdXMgPj4gX05ldVF1YW50RmxvYXQuX3JhZGl1c0JpYXNTaGlmdDtcbiAgICAgICAgaWYgKHJhZCA8PSAxKVxuICAgICAgICAgIHJhZCA9IDA7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgcmFkOyBqKyspIHtcbiAgICAgICAgICB0aGlzLl9yYWRQb3dlcltqXSA9IGFscGhhICogKChyYWQgKiByYWQgLSBqICogaikgKiBfTmV1UXVhbnRGbG9hdC5fcmFkQmlhcyAvIChyYWQgKiByYWQpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBfYnVpbGRQYWxldHRlKCkge1xuICAgIGNvbnN0IHBhbGV0dGUgPSBuZXcgUGFsZXR0ZSgpO1xuICAgIHRoaXMuX25ldHdvcmsuZm9yRWFjaCgobmV1cm9uKSA9PiB7XG4gICAgICBwYWxldHRlLmFkZChuZXVyb24udG9Qb2ludCgpKTtcbiAgICB9KTtcbiAgICBwYWxldHRlLnNvcnQoKTtcbiAgICByZXR1cm4gcGFsZXR0ZTtcbiAgfVxuICBfYWx0ZXJOZWlnaGJvdXIocmFkLCBpLCBiLCBnLCByLCBhbCkge1xuICAgIGxldCBsbyA9IGkgLSByYWQ7XG4gICAgaWYgKGxvIDwgLTEpXG4gICAgICBsbyA9IC0xO1xuICAgIGxldCBoaSA9IGkgKyByYWQ7XG4gICAgaWYgKGhpID4gdGhpcy5fbmV0d29ya1NpemUpXG4gICAgICBoaSA9IHRoaXMuX25ldHdvcmtTaXplO1xuICAgIGxldCBqID0gaSArIDE7XG4gICAgbGV0IGsgPSBpIC0gMTtcbiAgICBsZXQgbSA9IDE7XG4gICAgd2hpbGUgKGogPCBoaSB8fCBrID4gbG8pIHtcbiAgICAgIGNvbnN0IGEgPSB0aGlzLl9yYWRQb3dlclttKytdIC8gX05ldVF1YW50RmxvYXQuX2FscGhhUmFkQmlhcztcbiAgICAgIGlmIChqIDwgaGkpIHtcbiAgICAgICAgY29uc3QgcCA9IHRoaXMuX25ldHdvcmtbaisrXTtcbiAgICAgICAgcC5zdWJ0cmFjdChhICogKHAuciAtIHIpLCBhICogKHAuZyAtIGcpLCBhICogKHAuYiAtIGIpLCBhICogKHAuYSAtIGFsKSk7XG4gICAgICB9XG4gICAgICBpZiAoayA+IGxvKSB7XG4gICAgICAgIGNvbnN0IHAgPSB0aGlzLl9uZXR3b3JrW2stLV07XG4gICAgICAgIHAuc3VidHJhY3QoYSAqIChwLnIgLSByKSwgYSAqIChwLmcgLSBnKSwgYSAqIChwLmIgLSBiKSwgYSAqIChwLmEgLSBhbCkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBfYWx0ZXJTaW5nbGUoYWxwaGEsIGksIGIsIGcsIHIsIGEpIHtcbiAgICBhbHBoYSAvPSBfTmV1UXVhbnRGbG9hdC5faW5pdEFscGhhO1xuICAgIGNvbnN0IG4gPSB0aGlzLl9uZXR3b3JrW2ldO1xuICAgIG4uc3VidHJhY3QoYWxwaGEgKiAobi5yIC0gciksIGFscGhhICogKG4uZyAtIGcpLCBhbHBoYSAqIChuLmIgLSBiKSwgYWxwaGEgKiAobi5hIC0gYSkpO1xuICB9XG4gIF9jb250ZXN0KGIsIGcsIHIsIGFsKSB7XG4gICAgY29uc3QgbXVsdGlwbGllciA9IDI1NSAqIDQgPDwgbmV0d29ya0JpYXNTaGlmdDI7XG4gICAgbGV0IGJlc3RkID0gfigxIDw8IDMxKTtcbiAgICBsZXQgYmVzdGJpYXNkID0gYmVzdGQ7XG4gICAgbGV0IGJlc3Rwb3MgPSAtMTtcbiAgICBsZXQgYmVzdGJpYXNwb3MgPSBiZXN0cG9zO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fbmV0d29ya1NpemU7IGkrKykge1xuICAgICAgY29uc3QgbiA9IHRoaXMuX25ldHdvcmtbaV07XG4gICAgICBjb25zdCBkaXN0ID0gdGhpcy5fZGlzdGFuY2UuY2FsY3VsYXRlTm9ybWFsaXplZChuLCB7IHIsIGcsIGIsIGE6IGFsIH0pICogbXVsdGlwbGllcjtcbiAgICAgIGlmIChkaXN0IDwgYmVzdGQpIHtcbiAgICAgICAgYmVzdGQgPSBkaXN0O1xuICAgICAgICBiZXN0cG9zID0gaTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGJpYXNkaXN0ID0gZGlzdCAtICh0aGlzLl9iaWFzW2ldID4+IF9OZXVRdWFudEZsb2F0Ll9pbml0aWFsQmlhc1NoaWZ0IC0gbmV0d29ya0JpYXNTaGlmdDIpO1xuICAgICAgaWYgKGJpYXNkaXN0IDwgYmVzdGJpYXNkKSB7XG4gICAgICAgIGJlc3RiaWFzZCA9IGJpYXNkaXN0O1xuICAgICAgICBiZXN0Ymlhc3BvcyA9IGk7XG4gICAgICB9XG4gICAgICBjb25zdCBiZXRhZnJlcSA9IHRoaXMuX2ZyZXFbaV0gPj4gX05ldVF1YW50RmxvYXQuX2JldGFTaGlmdDtcbiAgICAgIHRoaXMuX2ZyZXFbaV0gLT0gYmV0YWZyZXE7XG4gICAgICB0aGlzLl9iaWFzW2ldICs9IGJldGFmcmVxIDw8IF9OZXVRdWFudEZsb2F0Ll9nYW1tYVNoaWZ0O1xuICAgIH1cbiAgICB0aGlzLl9mcmVxW2Jlc3Rwb3NdICs9IF9OZXVRdWFudEZsb2F0Ll9iZXRhO1xuICAgIHRoaXMuX2JpYXNbYmVzdHBvc10gLT0gX05ldVF1YW50RmxvYXQuX2JldGFHYW1tYTtcbiAgICByZXR1cm4gYmVzdGJpYXNwb3M7XG4gIH1cbn07XG52YXIgTmV1UXVhbnRGbG9hdCA9IF9OZXVRdWFudEZsb2F0O1xuX19wdWJsaWNGaWVsZChOZXVRdWFudEZsb2F0LCBcIl9wcmltZTFcIiwgNDk5KTtcbl9fcHVibGljRmllbGQoTmV1UXVhbnRGbG9hdCwgXCJfcHJpbWUyXCIsIDQ5MSk7XG5fX3B1YmxpY0ZpZWxkKE5ldVF1YW50RmxvYXQsIFwiX3ByaW1lM1wiLCA0ODcpO1xuX19wdWJsaWNGaWVsZChOZXVRdWFudEZsb2F0LCBcIl9wcmltZTRcIiwgNTAzKTtcbl9fcHVibGljRmllbGQoTmV1UXVhbnRGbG9hdCwgXCJfbWlucGljdHVyZWJ5dGVzXCIsIF9OZXVRdWFudEZsb2F0Ll9wcmltZTQpO1xuX19wdWJsaWNGaWVsZChOZXVRdWFudEZsb2F0LCBcIl9uQ3ljbGVzXCIsIDEwMCk7XG5fX3B1YmxpY0ZpZWxkKE5ldVF1YW50RmxvYXQsIFwiX2luaXRpYWxCaWFzU2hpZnRcIiwgMTYpO1xuX19wdWJsaWNGaWVsZChOZXVRdWFudEZsb2F0LCBcIl9pbml0aWFsQmlhc1wiLCAxIDw8IF9OZXVRdWFudEZsb2F0Ll9pbml0aWFsQmlhc1NoaWZ0KTtcbl9fcHVibGljRmllbGQoTmV1UXVhbnRGbG9hdCwgXCJfZ2FtbWFTaGlmdFwiLCAxMCk7XG5fX3B1YmxpY0ZpZWxkKE5ldVF1YW50RmxvYXQsIFwiX2JldGFTaGlmdFwiLCAxMCk7XG5fX3B1YmxpY0ZpZWxkKE5ldVF1YW50RmxvYXQsIFwiX2JldGFcIiwgX05ldVF1YW50RmxvYXQuX2luaXRpYWxCaWFzID4+IF9OZXVRdWFudEZsb2F0Ll9iZXRhU2hpZnQpO1xuX19wdWJsaWNGaWVsZChOZXVRdWFudEZsb2F0LCBcIl9iZXRhR2FtbWFcIiwgX05ldVF1YW50RmxvYXQuX2luaXRpYWxCaWFzIDw8IF9OZXVRdWFudEZsb2F0Ll9nYW1tYVNoaWZ0IC0gX05ldVF1YW50RmxvYXQuX2JldGFTaGlmdCk7XG5fX3B1YmxpY0ZpZWxkKE5ldVF1YW50RmxvYXQsIFwiX3JhZGl1c0JpYXNTaGlmdFwiLCA2KTtcbl9fcHVibGljRmllbGQoTmV1UXVhbnRGbG9hdCwgXCJfcmFkaXVzQmlhc1wiLCAxIDw8IF9OZXVRdWFudEZsb2F0Ll9yYWRpdXNCaWFzU2hpZnQpO1xuX19wdWJsaWNGaWVsZChOZXVRdWFudEZsb2F0LCBcIl9yYWRpdXNEZWNyZWFzZVwiLCAzMCk7XG5fX3B1YmxpY0ZpZWxkKE5ldVF1YW50RmxvYXQsIFwiX2FscGhhQmlhc1NoaWZ0XCIsIDEwKTtcbl9fcHVibGljRmllbGQoTmV1UXVhbnRGbG9hdCwgXCJfaW5pdEFscGhhXCIsIDEgPDwgX05ldVF1YW50RmxvYXQuX2FscGhhQmlhc1NoaWZ0KTtcbl9fcHVibGljRmllbGQoTmV1UXVhbnRGbG9hdCwgXCJfcmFkQmlhc1NoaWZ0XCIsIDgpO1xuX19wdWJsaWNGaWVsZChOZXVRdWFudEZsb2F0LCBcIl9yYWRCaWFzXCIsIDEgPDwgX05ldVF1YW50RmxvYXQuX3JhZEJpYXNTaGlmdCk7XG5fX3B1YmxpY0ZpZWxkKE5ldVF1YW50RmxvYXQsIFwiX2FscGhhUmFkQmlhc1NoaWZ0XCIsIF9OZXVRdWFudEZsb2F0Ll9hbHBoYUJpYXNTaGlmdCArIF9OZXVRdWFudEZsb2F0Ll9yYWRCaWFzU2hpZnQpO1xuX19wdWJsaWNGaWVsZChOZXVRdWFudEZsb2F0LCBcIl9hbHBoYVJhZEJpYXNcIiwgMSA8PCBfTmV1UXVhbnRGbG9hdC5fYWxwaGFSYWRCaWFzU2hpZnQpO1xuXG4vLyBzcmMvcGFsZXR0ZS9yZ2JxdWFudC9jb2xvckhpc3RvZ3JhbS50c1xudmFyIF9Db2xvckhpc3RvZ3JhbSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IobWV0aG9kLCBjb2xvcnMpIHtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiX21ldGhvZFwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiX2h1ZVN0YXRzXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJfaGlzdG9ncmFtXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJfaW5pdENvbG9yc1wiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiX21pbkh1ZUNvbHNcIik7XG4gICAgdGhpcy5fbWV0aG9kID0gbWV0aG9kO1xuICAgIHRoaXMuX21pbkh1ZUNvbHMgPSBjb2xvcnMgPDwgMjtcbiAgICB0aGlzLl9pbml0Q29sb3JzID0gY29sb3JzIDw8IDI7XG4gICAgdGhpcy5faHVlU3RhdHMgPSBuZXcgSHVlU3RhdGlzdGljcyhfQ29sb3JIaXN0b2dyYW0uX2h1ZUdyb3VwcywgdGhpcy5fbWluSHVlQ29scyk7XG4gICAgdGhpcy5faGlzdG9ncmFtID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIH1cbiAgc2FtcGxlKHBvaW50Q29udGFpbmVyKSB7XG4gICAgc3dpdGNoICh0aGlzLl9tZXRob2QpIHtcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgdGhpcy5fY29sb3JTdGF0czFEKHBvaW50Q29udGFpbmVyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIHRoaXMuX2NvbG9yU3RhdHMyRChwb2ludENvbnRhaW5lcik7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBnZXRJbXBvcnRhbmNlU29ydGVkQ29sb3JzSURYSTMyKCkge1xuICAgIGNvbnN0IHNvcnRlZCA9IHN0YWJsZVNvcnQoT2JqZWN0LmtleXModGhpcy5faGlzdG9ncmFtKSwgKGEsIGIpID0+IHRoaXMuX2hpc3RvZ3JhbVtiXSAtIHRoaXMuX2hpc3RvZ3JhbVthXSk7XG4gICAgaWYgKHNvcnRlZC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgbGV0IGlkeGkzMjtcbiAgICBzd2l0Y2ggKHRoaXMuX21ldGhvZCkge1xuICAgICAgY2FzZSAxOlxuICAgICAgICBjb25zdCBpbml0aWFsQ29sb3JzTGltaXQgPSBNYXRoLm1pbihzb3J0ZWQubGVuZ3RoLCB0aGlzLl9pbml0Q29sb3JzKTtcbiAgICAgICAgY29uc3QgbGFzdCA9IHNvcnRlZFtpbml0aWFsQ29sb3JzTGltaXQgLSAxXTtcbiAgICAgICAgY29uc3QgZnJlcSA9IHRoaXMuX2hpc3RvZ3JhbVtsYXN0XTtcbiAgICAgICAgaWR4aTMyID0gc29ydGVkLnNsaWNlKDAsIGluaXRpYWxDb2xvcnNMaW1pdCk7XG4gICAgICAgIGxldCBwb3MgPSBpbml0aWFsQ29sb3JzTGltaXQ7XG4gICAgICAgIGNvbnN0IGxlbiA9IHNvcnRlZC5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChwb3MgPCBsZW4gJiYgdGhpcy5faGlzdG9ncmFtW3NvcnRlZFtwb3NdXSA9PT0gZnJlcSkge1xuICAgICAgICAgIGlkeGkzMi5wdXNoKHNvcnRlZFtwb3MrK10pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2h1ZVN0YXRzLmluamVjdEludG9BcnJheShpZHhpMzIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgaWR4aTMyID0gc29ydGVkO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkluY29ycmVjdCBtZXRob2RcIik7XG4gICAgfVxuICAgIHJldHVybiBpZHhpMzIubWFwKCh2KSA9PiArdik7XG4gIH1cbiAgX2NvbG9yU3RhdHMxRChwb2ludENvbnRhaW5lcikge1xuICAgIGNvbnN0IGhpc3RHID0gdGhpcy5faGlzdG9ncmFtO1xuICAgIGNvbnN0IHBvaW50QXJyYXkgPSBwb2ludENvbnRhaW5lci5nZXRQb2ludEFycmF5KCk7XG4gICAgY29uc3QgbGVuID0gcG9pbnRBcnJheS5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgY29uc3QgY29sID0gcG9pbnRBcnJheVtpXS51aW50MzI7XG4gICAgICB0aGlzLl9odWVTdGF0cy5jaGVjayhjb2wpO1xuICAgICAgaWYgKGNvbCBpbiBoaXN0Rykge1xuICAgICAgICBoaXN0R1tjb2xdKys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBoaXN0R1tjb2xdID0gMTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgX2NvbG9yU3RhdHMyRChwb2ludENvbnRhaW5lcikge1xuICAgIGNvbnN0IHdpZHRoID0gcG9pbnRDb250YWluZXIuZ2V0V2lkdGgoKTtcbiAgICBjb25zdCBoZWlnaHQgPSBwb2ludENvbnRhaW5lci5nZXRIZWlnaHQoKTtcbiAgICBjb25zdCBwb2ludEFycmF5ID0gcG9pbnRDb250YWluZXIuZ2V0UG9pbnRBcnJheSgpO1xuICAgIGNvbnN0IGJveFcgPSBfQ29sb3JIaXN0b2dyYW0uX2JveFNpemVbMF07XG4gICAgY29uc3QgYm94SCA9IF9Db2xvckhpc3RvZ3JhbS5fYm94U2l6ZVsxXTtcbiAgICBjb25zdCBhcmVhID0gYm94VyAqIGJveEg7XG4gICAgY29uc3QgYm94ZXMgPSB0aGlzLl9tYWtlQm94ZXMod2lkdGgsIGhlaWdodCwgYm94VywgYm94SCk7XG4gICAgY29uc3QgaGlzdEcgPSB0aGlzLl9oaXN0b2dyYW07XG4gICAgYm94ZXMuZm9yRWFjaCgoYm94KSA9PiB7XG4gICAgICBsZXQgZWZmYyA9IE1hdGgucm91bmQoYm94LncgKiBib3guaCAvIGFyZWEpICogX0NvbG9ySGlzdG9ncmFtLl9ib3hQaXhlbHM7XG4gICAgICBpZiAoZWZmYyA8IDIpXG4gICAgICAgIGVmZmMgPSAyO1xuICAgICAgY29uc3QgaGlzdEwgPSB7fTtcbiAgICAgIHRoaXMuX2l0ZXJhdGVCb3goYm94LCB3aWR0aCwgKGkpID0+IHtcbiAgICAgICAgY29uc3QgY29sID0gcG9pbnRBcnJheVtpXS51aW50MzI7XG4gICAgICAgIHRoaXMuX2h1ZVN0YXRzLmNoZWNrKGNvbCk7XG4gICAgICAgIGlmIChjb2wgaW4gaGlzdEcpIHtcbiAgICAgICAgICBoaXN0R1tjb2xdKys7XG4gICAgICAgIH0gZWxzZSBpZiAoY29sIGluIGhpc3RMKSB7XG4gICAgICAgICAgaWYgKCsraGlzdExbY29sXSA+PSBlZmZjKSB7XG4gICAgICAgICAgICBoaXN0R1tjb2xdID0gaGlzdExbY29sXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaGlzdExbY29sXSA9IDE7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHRoaXMuX2h1ZVN0YXRzLmluamVjdEludG9EaWN0aW9uYXJ5KGhpc3RHKTtcbiAgfVxuICBfaXRlcmF0ZUJveChiYm94LCB3aWQsIGZuKSB7XG4gICAgY29uc3QgYiA9IGJib3g7XG4gICAgY29uc3QgaTAgPSBiLnkgKiB3aWQgKyBiLng7XG4gICAgY29uc3QgaTEgPSAoYi55ICsgYi5oIC0gMSkgKiB3aWQgKyAoYi54ICsgYi53IC0gMSk7XG4gICAgY29uc3QgaW5jciA9IHdpZCAtIGIudyArIDE7XG4gICAgbGV0IGNudCA9IDA7XG4gICAgbGV0IGkgPSBpMDtcbiAgICBkbyB7XG4gICAgICBmbi5jYWxsKHRoaXMsIGkpO1xuICAgICAgaSArPSArK2NudCAlIGIudyA9PT0gMCA/IGluY3IgOiAxO1xuICAgIH0gd2hpbGUgKGkgPD0gaTEpO1xuICB9XG4gIF9tYWtlQm94ZXMod2lkdGgsIGhlaWdodCwgc3RlcFgsIHN0ZXBZKSB7XG4gICAgY29uc3Qgd3JlbSA9IHdpZHRoICUgc3RlcFg7XG4gICAgY29uc3QgaHJlbSA9IGhlaWdodCAlIHN0ZXBZO1xuICAgIGNvbnN0IHhlbmQgPSB3aWR0aCAtIHdyZW07XG4gICAgY29uc3QgeWVuZCA9IGhlaWdodCAtIGhyZW07XG4gICAgY29uc3QgYm94ZXNBcnJheSA9IFtdO1xuICAgIGZvciAobGV0IHkyID0gMDsgeTIgPCBoZWlnaHQ7IHkyICs9IHN0ZXBZKSB7XG4gICAgICBmb3IgKGxldCB4MiA9IDA7IHgyIDwgd2lkdGg7IHgyICs9IHN0ZXBYKSB7XG4gICAgICAgIGJveGVzQXJyYXkucHVzaCh7XG4gICAgICAgICAgeDogeDIsXG4gICAgICAgICAgeTogeTIsXG4gICAgICAgICAgdzogeDIgPT09IHhlbmQgPyB3cmVtIDogc3RlcFgsXG4gICAgICAgICAgaDogeTIgPT09IHllbmQgPyBocmVtIDogc3RlcFlcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBib3hlc0FycmF5O1xuICB9XG59O1xudmFyIENvbG9ySGlzdG9ncmFtID0gX0NvbG9ySGlzdG9ncmFtO1xuX19wdWJsaWNGaWVsZChDb2xvckhpc3RvZ3JhbSwgXCJfYm94U2l6ZVwiLCBbNjQsIDY0XSk7XG5fX3B1YmxpY0ZpZWxkKENvbG9ySGlzdG9ncmFtLCBcIl9ib3hQaXhlbHNcIiwgMik7XG5fX3B1YmxpY0ZpZWxkKENvbG9ySGlzdG9ncmFtLCBcIl9odWVHcm91cHNcIiwgMTApO1xuXG4vLyBzcmMvcGFsZXR0ZS9yZ2JxdWFudC9yZ2JxdWFudC50c1xudmFyIFJlbW92ZWRDb2xvciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoaW5kZXgsIGNvbG9yLCBkaXN0YW5jZSkge1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJpbmRleFwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiY29sb3JcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImRpc3RhbmNlXCIpO1xuICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICB0aGlzLmNvbG9yID0gY29sb3I7XG4gICAgdGhpcy5kaXN0YW5jZSA9IGRpc3RhbmNlO1xuICB9XG59O1xudmFyIFJHQlF1YW50ID0gY2xhc3MgZXh0ZW5kcyBBYnN0cmFjdFBhbGV0dGVRdWFudGl6ZXIge1xuICBjb25zdHJ1Y3Rvcihjb2xvckRpc3RhbmNlQ2FsY3VsYXRvciwgY29sb3JzID0gMjU2LCBtZXRob2QgPSAyKSB7XG4gICAgc3VwZXIoKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiX2NvbG9yc1wiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiX2luaXRpYWxEaXN0YW5jZVwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiX2Rpc3RhbmNlSW5jcmVtZW50XCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJfaGlzdG9ncmFtXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJfZGlzdGFuY2VcIik7XG4gICAgdGhpcy5fZGlzdGFuY2UgPSBjb2xvckRpc3RhbmNlQ2FsY3VsYXRvcjtcbiAgICB0aGlzLl9jb2xvcnMgPSBjb2xvcnM7XG4gICAgdGhpcy5faGlzdG9ncmFtID0gbmV3IENvbG9ySGlzdG9ncmFtKG1ldGhvZCwgY29sb3JzKTtcbiAgICB0aGlzLl9pbml0aWFsRGlzdGFuY2UgPSAwLjAxO1xuICAgIHRoaXMuX2Rpc3RhbmNlSW5jcmVtZW50ID0gNWUtMztcbiAgfVxuICBzYW1wbGUoaW1hZ2UpIHtcbiAgICB0aGlzLl9oaXN0b2dyYW0uc2FtcGxlKGltYWdlKTtcbiAgfVxuICAqcXVhbnRpemUoKSB7XG4gICAgY29uc3QgaWR4aTMyID0gdGhpcy5faGlzdG9ncmFtLmdldEltcG9ydGFuY2VTb3J0ZWRDb2xvcnNJRFhJMzIoKTtcbiAgICBpZiAoaWR4aTMyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gY29sb3JzIGluIGltYWdlXCIpO1xuICAgIH1cbiAgICB5aWVsZCogdGhpcy5fYnVpbGRQYWxldHRlKGlkeGkzMik7XG4gIH1cbiAgKl9idWlsZFBhbGV0dGUoaWR4aTMyKSB7XG4gICAgY29uc3QgcGFsZXR0ZSA9IG5ldyBQYWxldHRlKCk7XG4gICAgY29uc3QgY29sb3JBcnJheSA9IHBhbGV0dGUuZ2V0UG9pbnRDb250YWluZXIoKS5nZXRQb2ludEFycmF5KCk7XG4gICAgY29uc3QgdXNhZ2VBcnJheSA9IG5ldyBBcnJheShpZHhpMzIubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlkeGkzMi5sZW5ndGg7IGkrKykge1xuICAgICAgY29sb3JBcnJheS5wdXNoKFBvaW50LmNyZWF0ZUJ5VWludDMyKGlkeGkzMltpXSkpO1xuICAgICAgdXNhZ2VBcnJheVtpXSA9IDE7XG4gICAgfVxuICAgIGNvbnN0IGxlbiA9IGNvbG9yQXJyYXkubGVuZ3RoO1xuICAgIGNvbnN0IG1lbURpc3QgPSBbXTtcbiAgICBsZXQgcGFsTGVuID0gbGVuO1xuICAgIGxldCB0aG9sZCA9IHRoaXMuX2luaXRpYWxEaXN0YW5jZTtcbiAgICBjb25zdCB0cmFja2VyID0gbmV3IFByb2dyZXNzVHJhY2tlcihwYWxMZW4gLSB0aGlzLl9jb2xvcnMsIDk5KTtcbiAgICB3aGlsZSAocGFsTGVuID4gdGhpcy5fY29sb3JzKSB7XG4gICAgICBtZW1EaXN0Lmxlbmd0aCA9IDA7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmICh0cmFja2VyLnNob3VsZE5vdGlmeShsZW4gLSBwYWxMZW4pKSB7XG4gICAgICAgICAgeWllbGQge1xuICAgICAgICAgICAgcHJvZ3Jlc3M6IHRyYWNrZXIucHJvZ3Jlc3NcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICh1c2FnZUFycmF5W2ldID09PSAwKVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBjb25zdCBweGkgPSBjb2xvckFycmF5W2ldO1xuICAgICAgICBmb3IgKGxldCBqID0gaSArIDE7IGogPCBsZW47IGorKykge1xuICAgICAgICAgIGlmICh1c2FnZUFycmF5W2pdID09PSAwKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgY29uc3QgcHhqID0gY29sb3JBcnJheVtqXTtcbiAgICAgICAgICBjb25zdCBkaXN0ID0gdGhpcy5fZGlzdGFuY2UuY2FsY3VsYXRlTm9ybWFsaXplZChweGksIHB4aik7XG4gICAgICAgICAgaWYgKGRpc3QgPCB0aG9sZCkge1xuICAgICAgICAgICAgbWVtRGlzdC5wdXNoKG5ldyBSZW1vdmVkQ29sb3IoaiwgcHhqLCBkaXN0KSk7XG4gICAgICAgICAgICB1c2FnZUFycmF5W2pdID0gMDtcbiAgICAgICAgICAgIHBhbExlbi0tO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhvbGQgKz0gcGFsTGVuID4gdGhpcy5fY29sb3JzICogMyA/IHRoaXMuX2luaXRpYWxEaXN0YW5jZSA6IHRoaXMuX2Rpc3RhbmNlSW5jcmVtZW50O1xuICAgIH1cbiAgICBpZiAocGFsTGVuIDwgdGhpcy5fY29sb3JzKSB7XG4gICAgICBzdGFibGVTb3J0KG1lbURpc3QsIChhLCBiKSA9PiBiLmRpc3RhbmNlIC0gYS5kaXN0YW5jZSk7XG4gICAgICBsZXQgayA9IDA7XG4gICAgICB3aGlsZSAocGFsTGVuIDwgdGhpcy5fY29sb3JzICYmIGsgPCBtZW1EaXN0Lmxlbmd0aCkge1xuICAgICAgICBjb25zdCByZW1vdmVkQ29sb3IgPSBtZW1EaXN0W2tdO1xuICAgICAgICB1c2FnZUFycmF5W3JlbW92ZWRDb2xvci5pbmRleF0gPSAxO1xuICAgICAgICBwYWxMZW4rKztcbiAgICAgICAgaysrO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgY29sb3JzID0gY29sb3JBcnJheS5sZW5ndGg7XG4gICAgZm9yIChsZXQgY29sb3JJbmRleCA9IGNvbG9ycyAtIDE7IGNvbG9ySW5kZXggPj0gMDsgY29sb3JJbmRleC0tKSB7XG4gICAgICBpZiAodXNhZ2VBcnJheVtjb2xvckluZGV4XSA9PT0gMCkge1xuICAgICAgICBpZiAoY29sb3JJbmRleCAhPT0gY29sb3JzIC0gMSkge1xuICAgICAgICAgIGNvbG9yQXJyYXlbY29sb3JJbmRleF0gPSBjb2xvckFycmF5W2NvbG9ycyAtIDFdO1xuICAgICAgICB9XG4gICAgICAgIC0tY29sb3JzO1xuICAgICAgfVxuICAgIH1cbiAgICBjb2xvckFycmF5Lmxlbmd0aCA9IGNvbG9ycztcbiAgICBwYWxldHRlLnNvcnQoKTtcbiAgICB5aWVsZCB7XG4gICAgICBwYWxldHRlLFxuICAgICAgcHJvZ3Jlc3M6IDEwMFxuICAgIH07XG4gIH1cbn07XG5cbi8vIHNyYy9wYWxldHRlL3d1L3d1UXVhbnQudHNcbmZ1bmN0aW9uIGNyZWF0ZUFycmF5MUQoZGltZW5zaW9uMSkge1xuICBjb25zdCBhID0gW107XG4gIGZvciAobGV0IGsgPSAwOyBrIDwgZGltZW5zaW9uMTsgaysrKSB7XG4gICAgYVtrXSA9IDA7XG4gIH1cbiAgcmV0dXJuIGE7XG59XG5mdW5jdGlvbiBjcmVhdGVBcnJheTREKGRpbWVuc2lvbjEsIGRpbWVuc2lvbjIsIGRpbWVuc2lvbjMsIGRpbWVuc2lvbjQpIHtcbiAgY29uc3QgYSA9IG5ldyBBcnJheShkaW1lbnNpb24xKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBkaW1lbnNpb24xOyBpKyspIHtcbiAgICBhW2ldID0gbmV3IEFycmF5KGRpbWVuc2lvbjIpO1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgZGltZW5zaW9uMjsgaisrKSB7XG4gICAgICBhW2ldW2pdID0gbmV3IEFycmF5KGRpbWVuc2lvbjMpO1xuICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBkaW1lbnNpb24zOyBrKyspIHtcbiAgICAgICAgYVtpXVtqXVtrXSA9IG5ldyBBcnJheShkaW1lbnNpb240KTtcbiAgICAgICAgZm9yIChsZXQgbCA9IDA7IGwgPCBkaW1lbnNpb240OyBsKyspIHtcbiAgICAgICAgICBhW2ldW2pdW2tdW2xdID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gYTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUFycmF5M0QoZGltZW5zaW9uMSwgZGltZW5zaW9uMiwgZGltZW5zaW9uMykge1xuICBjb25zdCBhID0gbmV3IEFycmF5KGRpbWVuc2lvbjEpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGRpbWVuc2lvbjE7IGkrKykge1xuICAgIGFbaV0gPSBuZXcgQXJyYXkoZGltZW5zaW9uMik7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBkaW1lbnNpb24yOyBqKyspIHtcbiAgICAgIGFbaV1bal0gPSBuZXcgQXJyYXkoZGltZW5zaW9uMyk7XG4gICAgICBmb3IgKGxldCBrID0gMDsgayA8IGRpbWVuc2lvbjM7IGsrKykge1xuICAgICAgICBhW2ldW2pdW2tdID0gMDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGE7XG59XG5mdW5jdGlvbiBmaWxsQXJyYXkzRChhLCBkaW1lbnNpb24xLCBkaW1lbnNpb24yLCBkaW1lbnNpb24zLCB2YWx1ZSkge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGRpbWVuc2lvbjE7IGkrKykge1xuICAgIGFbaV0gPSBbXTtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IGRpbWVuc2lvbjI7IGorKykge1xuICAgICAgYVtpXVtqXSA9IFtdO1xuICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBkaW1lbnNpb24zOyBrKyspIHtcbiAgICAgICAgYVtpXVtqXVtrXSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZmlsbEFycmF5MUQoYSwgZGltZW5zaW9uMSwgdmFsdWUpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBkaW1lbnNpb24xOyBpKyspIHtcbiAgICBhW2ldID0gdmFsdWU7XG4gIH1cbn1cbnZhciBXdUNvbG9yQ3ViZSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInJlZE1pbmltdW1cIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInJlZE1heGltdW1cIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImdyZWVuTWluaW11bVwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiZ3JlZW5NYXhpbXVtXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJibHVlTWluaW11bVwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiYmx1ZU1heGltdW1cIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInZvbHVtZVwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiYWxwaGFNaW5pbXVtXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJhbHBoYU1heGltdW1cIik7XG4gIH1cbn07XG52YXIgX1d1UXVhbnQgPSBjbGFzcyBleHRlbmRzIEFic3RyYWN0UGFsZXR0ZVF1YW50aXplciB7XG4gIGNvbnN0cnVjdG9yKGNvbG9yRGlzdGFuY2VDYWxjdWxhdG9yLCBjb2xvcnMgPSAyNTYsIHNpZ25pZmljYW50Qml0c1BlckNoYW5uZWwgPSA1KSB7XG4gICAgc3VwZXIoKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiX3JlZHNcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIl9ncmVlbnNcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIl9ibHVlc1wiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiX2FscGhhc1wiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiX3N1bXNcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIl93ZWlnaHRzXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJfbW9tZW50c1JlZFwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiX21vbWVudHNHcmVlblwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiX21vbWVudHNCbHVlXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJfbW9tZW50c0FscGhhXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJfbW9tZW50c1wiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiX3RhYmxlXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJfcGl4ZWxzXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJfY3ViZXNcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIl9jb2xvcnNcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIl9zaWduaWZpY2FudEJpdHNQZXJDaGFubmVsXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJfbWF4U2lkZUluZGV4XCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJfYWxwaGFNYXhTaWRlSW5kZXhcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIl9zaWRlU2l6ZVwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiX2FscGhhU2lkZVNpemVcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIl9kaXN0YW5jZVwiKTtcbiAgICB0aGlzLl9kaXN0YW5jZSA9IGNvbG9yRGlzdGFuY2VDYWxjdWxhdG9yO1xuICAgIHRoaXMuX3NldFF1YWxpdHkoc2lnbmlmaWNhbnRCaXRzUGVyQ2hhbm5lbCk7XG4gICAgdGhpcy5faW5pdGlhbGl6ZShjb2xvcnMpO1xuICB9XG4gIHNhbXBsZShpbWFnZSkge1xuICAgIGNvbnN0IHBvaW50QXJyYXkgPSBpbWFnZS5nZXRQb2ludEFycmF5KCk7XG4gICAgZm9yIChsZXQgaSA9IDAsIGwgPSBwb2ludEFycmF5Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdGhpcy5fYWRkQ29sb3IocG9pbnRBcnJheVtpXSk7XG4gICAgfVxuICAgIHRoaXMuX3BpeGVscyA9IHRoaXMuX3BpeGVscy5jb25jYXQocG9pbnRBcnJheSk7XG4gIH1cbiAgKnF1YW50aXplKCkge1xuICAgIHlpZWxkKiB0aGlzLl9wcmVwYXJlUGFsZXR0ZSgpO1xuICAgIGNvbnN0IHBhbGV0dGUgPSBuZXcgUGFsZXR0ZSgpO1xuICAgIGZvciAobGV0IHBhbGV0dGVJbmRleCA9IDA7IHBhbGV0dGVJbmRleCA8IHRoaXMuX2NvbG9yczsgcGFsZXR0ZUluZGV4KyspIHtcbiAgICAgIGlmICh0aGlzLl9zdW1zW3BhbGV0dGVJbmRleF0gPiAwKSB7XG4gICAgICAgIGNvbnN0IHN1bSA9IHRoaXMuX3N1bXNbcGFsZXR0ZUluZGV4XTtcbiAgICAgICAgY29uc3QgciA9IHRoaXMuX3JlZHNbcGFsZXR0ZUluZGV4XSAvIHN1bTtcbiAgICAgICAgY29uc3QgZyA9IHRoaXMuX2dyZWVuc1twYWxldHRlSW5kZXhdIC8gc3VtO1xuICAgICAgICBjb25zdCBiID0gdGhpcy5fYmx1ZXNbcGFsZXR0ZUluZGV4XSAvIHN1bTtcbiAgICAgICAgY29uc3QgYSA9IHRoaXMuX2FscGhhc1twYWxldHRlSW5kZXhdIC8gc3VtO1xuICAgICAgICBjb25zdCBjb2xvciA9IFBvaW50LmNyZWF0ZUJ5UkdCQShyIHwgMCwgZyB8IDAsIGIgfCAwLCBhIHwgMCk7XG4gICAgICAgIHBhbGV0dGUuYWRkKGNvbG9yKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcGFsZXR0ZS5zb3J0KCk7XG4gICAgeWllbGQge1xuICAgICAgcGFsZXR0ZSxcbiAgICAgIHByb2dyZXNzOiAxMDBcbiAgICB9O1xuICB9XG4gICpfcHJlcGFyZVBhbGV0dGUoKSB7XG4gICAgeWllbGQqIHRoaXMuX2NhbGN1bGF0ZU1vbWVudHMoKTtcbiAgICBsZXQgbmV4dCA9IDA7XG4gICAgY29uc3Qgdm9sdW1lVmFyaWFuY2UgPSBjcmVhdGVBcnJheTFEKHRoaXMuX2NvbG9ycyk7XG4gICAgZm9yIChsZXQgY3ViZUluZGV4ID0gMTsgY3ViZUluZGV4IDwgdGhpcy5fY29sb3JzOyArK2N1YmVJbmRleCkge1xuICAgICAgaWYgKHRoaXMuX2N1dCh0aGlzLl9jdWJlc1tuZXh0XSwgdGhpcy5fY3ViZXNbY3ViZUluZGV4XSkpIHtcbiAgICAgICAgdm9sdW1lVmFyaWFuY2VbbmV4dF0gPSB0aGlzLl9jdWJlc1tuZXh0XS52b2x1bWUgPiAxID8gdGhpcy5fY2FsY3VsYXRlVmFyaWFuY2UodGhpcy5fY3ViZXNbbmV4dF0pIDogMDtcbiAgICAgICAgdm9sdW1lVmFyaWFuY2VbY3ViZUluZGV4XSA9IHRoaXMuX2N1YmVzW2N1YmVJbmRleF0udm9sdW1lID4gMSA/IHRoaXMuX2NhbGN1bGF0ZVZhcmlhbmNlKHRoaXMuX2N1YmVzW2N1YmVJbmRleF0pIDogMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZvbHVtZVZhcmlhbmNlW25leHRdID0gMDtcbiAgICAgICAgY3ViZUluZGV4LS07XG4gICAgICB9XG4gICAgICBuZXh0ID0gMDtcbiAgICAgIGxldCB0ZW1wID0gdm9sdW1lVmFyaWFuY2VbMF07XG4gICAgICBmb3IgKGxldCBpbmRleCA9IDE7IGluZGV4IDw9IGN1YmVJbmRleDsgKytpbmRleCkge1xuICAgICAgICBpZiAodm9sdW1lVmFyaWFuY2VbaW5kZXhdID4gdGVtcCkge1xuICAgICAgICAgIHRlbXAgPSB2b2x1bWVWYXJpYW5jZVtpbmRleF07XG4gICAgICAgICAgbmV4dCA9IGluZGV4O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodGVtcCA8PSAwKSB7XG4gICAgICAgIHRoaXMuX2NvbG9ycyA9IGN1YmVJbmRleCArIDE7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBsb29rdXBSZWQgPSBbXTtcbiAgICBjb25zdCBsb29rdXBHcmVlbiA9IFtdO1xuICAgIGNvbnN0IGxvb2t1cEJsdWUgPSBbXTtcbiAgICBjb25zdCBsb29rdXBBbHBoYSA9IFtdO1xuICAgIGZvciAobGV0IGsgPSAwOyBrIDwgdGhpcy5fY29sb3JzOyArK2spIHtcbiAgICAgIGNvbnN0IHdlaWdodCA9IF9XdVF1YW50Ll92b2x1bWUodGhpcy5fY3ViZXNba10sIHRoaXMuX3dlaWdodHMpO1xuICAgICAgaWYgKHdlaWdodCA+IDApIHtcbiAgICAgICAgbG9va3VwUmVkW2tdID0gX1d1UXVhbnQuX3ZvbHVtZSh0aGlzLl9jdWJlc1trXSwgdGhpcy5fbW9tZW50c1JlZCkgLyB3ZWlnaHQgfCAwO1xuICAgICAgICBsb29rdXBHcmVlbltrXSA9IF9XdVF1YW50Ll92b2x1bWUodGhpcy5fY3ViZXNba10sIHRoaXMuX21vbWVudHNHcmVlbikgLyB3ZWlnaHQgfCAwO1xuICAgICAgICBsb29rdXBCbHVlW2tdID0gX1d1UXVhbnQuX3ZvbHVtZSh0aGlzLl9jdWJlc1trXSwgdGhpcy5fbW9tZW50c0JsdWUpIC8gd2VpZ2h0IHwgMDtcbiAgICAgICAgbG9va3VwQWxwaGFba10gPSBfV3VRdWFudC5fdm9sdW1lKHRoaXMuX2N1YmVzW2tdLCB0aGlzLl9tb21lbnRzQWxwaGEpIC8gd2VpZ2h0IHwgMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxvb2t1cFJlZFtrXSA9IDA7XG4gICAgICAgIGxvb2t1cEdyZWVuW2tdID0gMDtcbiAgICAgICAgbG9va3VwQmx1ZVtrXSA9IDA7XG4gICAgICAgIGxvb2t1cEFscGhhW2tdID0gMDtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fcmVkcyA9IGNyZWF0ZUFycmF5MUQodGhpcy5fY29sb3JzICsgMSk7XG4gICAgdGhpcy5fZ3JlZW5zID0gY3JlYXRlQXJyYXkxRCh0aGlzLl9jb2xvcnMgKyAxKTtcbiAgICB0aGlzLl9ibHVlcyA9IGNyZWF0ZUFycmF5MUQodGhpcy5fY29sb3JzICsgMSk7XG4gICAgdGhpcy5fYWxwaGFzID0gY3JlYXRlQXJyYXkxRCh0aGlzLl9jb2xvcnMgKyAxKTtcbiAgICB0aGlzLl9zdW1zID0gY3JlYXRlQXJyYXkxRCh0aGlzLl9jb2xvcnMgKyAxKTtcbiAgICBmb3IgKGxldCBpbmRleCA9IDAsIGwgPSB0aGlzLl9waXhlbHMubGVuZ3RoOyBpbmRleCA8IGw7IGluZGV4KyspIHtcbiAgICAgIGNvbnN0IGNvbG9yID0gdGhpcy5fcGl4ZWxzW2luZGV4XTtcbiAgICAgIGNvbnN0IG1hdGNoID0gLTE7XG4gICAgICBsZXQgYmVzdE1hdGNoID0gbWF0Y2g7XG4gICAgICBsZXQgYmVzdERpc3RhbmNlID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICAgIGZvciAobGV0IGxvb2t1cCA9IDA7IGxvb2t1cCA8IHRoaXMuX2NvbG9yczsgbG9va3VwKyspIHtcbiAgICAgICAgY29uc3QgZm91bmRSZWQgPSBsb29rdXBSZWRbbG9va3VwXTtcbiAgICAgICAgY29uc3QgZm91bmRHcmVlbiA9IGxvb2t1cEdyZWVuW2xvb2t1cF07XG4gICAgICAgIGNvbnN0IGZvdW5kQmx1ZSA9IGxvb2t1cEJsdWVbbG9va3VwXTtcbiAgICAgICAgY29uc3QgZm91bmRBbHBoYSA9IGxvb2t1cEFscGhhW2xvb2t1cF07XG4gICAgICAgIGNvbnN0IGRpc3RhbmNlID0gdGhpcy5fZGlzdGFuY2UuY2FsY3VsYXRlUmF3KGZvdW5kUmVkLCBmb3VuZEdyZWVuLCBmb3VuZEJsdWUsIGZvdW5kQWxwaGEsIGNvbG9yLnIsIGNvbG9yLmcsIGNvbG9yLmIsIGNvbG9yLmEpO1xuICAgICAgICBpZiAoZGlzdGFuY2UgPCBiZXN0RGlzdGFuY2UpIHtcbiAgICAgICAgICBiZXN0RGlzdGFuY2UgPSBkaXN0YW5jZTtcbiAgICAgICAgICBiZXN0TWF0Y2ggPSBsb29rdXA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuX3JlZHNbYmVzdE1hdGNoXSArPSBjb2xvci5yO1xuICAgICAgdGhpcy5fZ3JlZW5zW2Jlc3RNYXRjaF0gKz0gY29sb3IuZztcbiAgICAgIHRoaXMuX2JsdWVzW2Jlc3RNYXRjaF0gKz0gY29sb3IuYjtcbiAgICAgIHRoaXMuX2FscGhhc1tiZXN0TWF0Y2hdICs9IGNvbG9yLmE7XG4gICAgICB0aGlzLl9zdW1zW2Jlc3RNYXRjaF0rKztcbiAgICB9XG4gIH1cbiAgX2FkZENvbG9yKGNvbG9yKSB7XG4gICAgY29uc3QgYml0c1RvUmVtb3ZlID0gOCAtIHRoaXMuX3NpZ25pZmljYW50Qml0c1BlckNoYW5uZWw7XG4gICAgY29uc3QgaW5kZXhSZWQgPSAoY29sb3IuciA+PiBiaXRzVG9SZW1vdmUpICsgMTtcbiAgICBjb25zdCBpbmRleEdyZWVuID0gKGNvbG9yLmcgPj4gYml0c1RvUmVtb3ZlKSArIDE7XG4gICAgY29uc3QgaW5kZXhCbHVlID0gKGNvbG9yLmIgPj4gYml0c1RvUmVtb3ZlKSArIDE7XG4gICAgY29uc3QgaW5kZXhBbHBoYSA9IChjb2xvci5hID4+IGJpdHNUb1JlbW92ZSkgKyAxO1xuICAgIHRoaXMuX3dlaWdodHNbaW5kZXhBbHBoYV1baW5kZXhSZWRdW2luZGV4R3JlZW5dW2luZGV4Qmx1ZV0rKztcbiAgICB0aGlzLl9tb21lbnRzUmVkW2luZGV4QWxwaGFdW2luZGV4UmVkXVtpbmRleEdyZWVuXVtpbmRleEJsdWVdICs9IGNvbG9yLnI7XG4gICAgdGhpcy5fbW9tZW50c0dyZWVuW2luZGV4QWxwaGFdW2luZGV4UmVkXVtpbmRleEdyZWVuXVtpbmRleEJsdWVdICs9IGNvbG9yLmc7XG4gICAgdGhpcy5fbW9tZW50c0JsdWVbaW5kZXhBbHBoYV1baW5kZXhSZWRdW2luZGV4R3JlZW5dW2luZGV4Qmx1ZV0gKz0gY29sb3IuYjtcbiAgICB0aGlzLl9tb21lbnRzQWxwaGFbaW5kZXhBbHBoYV1baW5kZXhSZWRdW2luZGV4R3JlZW5dW2luZGV4Qmx1ZV0gKz0gY29sb3IuYTtcbiAgICB0aGlzLl9tb21lbnRzW2luZGV4QWxwaGFdW2luZGV4UmVkXVtpbmRleEdyZWVuXVtpbmRleEJsdWVdICs9IHRoaXMuX3RhYmxlW2NvbG9yLnJdICsgdGhpcy5fdGFibGVbY29sb3IuZ10gKyB0aGlzLl90YWJsZVtjb2xvci5iXSArIHRoaXMuX3RhYmxlW2NvbG9yLmFdO1xuICB9XG4gICpfY2FsY3VsYXRlTW9tZW50cygpIHtcbiAgICBjb25zdCBhcmVhID0gW107XG4gICAgY29uc3QgYXJlYVJlZCA9IFtdO1xuICAgIGNvbnN0IGFyZWFHcmVlbiA9IFtdO1xuICAgIGNvbnN0IGFyZWFCbHVlID0gW107XG4gICAgY29uc3QgYXJlYUFscGhhID0gW107XG4gICAgY29uc3QgYXJlYTIgPSBbXTtcbiAgICBjb25zdCB4YXJlYSA9IGNyZWF0ZUFycmF5M0QodGhpcy5fc2lkZVNpemUsIHRoaXMuX3NpZGVTaXplLCB0aGlzLl9zaWRlU2l6ZSk7XG4gICAgY29uc3QgeGFyZWFSZWQgPSBjcmVhdGVBcnJheTNEKHRoaXMuX3NpZGVTaXplLCB0aGlzLl9zaWRlU2l6ZSwgdGhpcy5fc2lkZVNpemUpO1xuICAgIGNvbnN0IHhhcmVhR3JlZW4gPSBjcmVhdGVBcnJheTNEKHRoaXMuX3NpZGVTaXplLCB0aGlzLl9zaWRlU2l6ZSwgdGhpcy5fc2lkZVNpemUpO1xuICAgIGNvbnN0IHhhcmVhQmx1ZSA9IGNyZWF0ZUFycmF5M0QodGhpcy5fc2lkZVNpemUsIHRoaXMuX3NpZGVTaXplLCB0aGlzLl9zaWRlU2l6ZSk7XG4gICAgY29uc3QgeGFyZWFBbHBoYSA9IGNyZWF0ZUFycmF5M0QodGhpcy5fc2lkZVNpemUsIHRoaXMuX3NpZGVTaXplLCB0aGlzLl9zaWRlU2l6ZSk7XG4gICAgY29uc3QgeGFyZWEyID0gY3JlYXRlQXJyYXkzRCh0aGlzLl9zaWRlU2l6ZSwgdGhpcy5fc2lkZVNpemUsIHRoaXMuX3NpZGVTaXplKTtcbiAgICBsZXQgdHJhY2tlclByb2dyZXNzID0gMDtcbiAgICBjb25zdCB0cmFja2VyID0gbmV3IFByb2dyZXNzVHJhY2tlcih0aGlzLl9hbHBoYU1heFNpZGVJbmRleCAqIHRoaXMuX21heFNpZGVJbmRleCwgOTkpO1xuICAgIGZvciAobGV0IGFscGhhSW5kZXggPSAxOyBhbHBoYUluZGV4IDw9IHRoaXMuX2FscGhhTWF4U2lkZUluZGV4OyArK2FscGhhSW5kZXgpIHtcbiAgICAgIGZpbGxBcnJheTNEKHhhcmVhLCB0aGlzLl9zaWRlU2l6ZSwgdGhpcy5fc2lkZVNpemUsIHRoaXMuX3NpZGVTaXplLCAwKTtcbiAgICAgIGZpbGxBcnJheTNEKHhhcmVhUmVkLCB0aGlzLl9zaWRlU2l6ZSwgdGhpcy5fc2lkZVNpemUsIHRoaXMuX3NpZGVTaXplLCAwKTtcbiAgICAgIGZpbGxBcnJheTNEKHhhcmVhR3JlZW4sIHRoaXMuX3NpZGVTaXplLCB0aGlzLl9zaWRlU2l6ZSwgdGhpcy5fc2lkZVNpemUsIDApO1xuICAgICAgZmlsbEFycmF5M0QoeGFyZWFCbHVlLCB0aGlzLl9zaWRlU2l6ZSwgdGhpcy5fc2lkZVNpemUsIHRoaXMuX3NpZGVTaXplLCAwKTtcbiAgICAgIGZpbGxBcnJheTNEKHhhcmVhQWxwaGEsIHRoaXMuX3NpZGVTaXplLCB0aGlzLl9zaWRlU2l6ZSwgdGhpcy5fc2lkZVNpemUsIDApO1xuICAgICAgZmlsbEFycmF5M0QoeGFyZWEyLCB0aGlzLl9zaWRlU2l6ZSwgdGhpcy5fc2lkZVNpemUsIHRoaXMuX3NpZGVTaXplLCAwKTtcbiAgICAgIGZvciAobGV0IHJlZEluZGV4ID0gMTsgcmVkSW5kZXggPD0gdGhpcy5fbWF4U2lkZUluZGV4OyArK3JlZEluZGV4LCArK3RyYWNrZXJQcm9ncmVzcykge1xuICAgICAgICBpZiAodHJhY2tlci5zaG91bGROb3RpZnkodHJhY2tlclByb2dyZXNzKSkge1xuICAgICAgICAgIHlpZWxkIHtcbiAgICAgICAgICAgIHByb2dyZXNzOiB0cmFja2VyLnByb2dyZXNzXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBmaWxsQXJyYXkxRChhcmVhLCB0aGlzLl9zaWRlU2l6ZSwgMCk7XG4gICAgICAgIGZpbGxBcnJheTFEKGFyZWFSZWQsIHRoaXMuX3NpZGVTaXplLCAwKTtcbiAgICAgICAgZmlsbEFycmF5MUQoYXJlYUdyZWVuLCB0aGlzLl9zaWRlU2l6ZSwgMCk7XG4gICAgICAgIGZpbGxBcnJheTFEKGFyZWFCbHVlLCB0aGlzLl9zaWRlU2l6ZSwgMCk7XG4gICAgICAgIGZpbGxBcnJheTFEKGFyZWFBbHBoYSwgdGhpcy5fc2lkZVNpemUsIDApO1xuICAgICAgICBmaWxsQXJyYXkxRChhcmVhMiwgdGhpcy5fc2lkZVNpemUsIDApO1xuICAgICAgICBmb3IgKGxldCBncmVlbkluZGV4ID0gMTsgZ3JlZW5JbmRleCA8PSB0aGlzLl9tYXhTaWRlSW5kZXg7ICsrZ3JlZW5JbmRleCkge1xuICAgICAgICAgIGxldCBsaW5lID0gMDtcbiAgICAgICAgICBsZXQgbGluZVJlZCA9IDA7XG4gICAgICAgICAgbGV0IGxpbmVHcmVlbiA9IDA7XG4gICAgICAgICAgbGV0IGxpbmVCbHVlID0gMDtcbiAgICAgICAgICBsZXQgbGluZUFscGhhID0gMDtcbiAgICAgICAgICBsZXQgbGluZTIgPSAwO1xuICAgICAgICAgIGZvciAobGV0IGJsdWVJbmRleCA9IDE7IGJsdWVJbmRleCA8PSB0aGlzLl9tYXhTaWRlSW5kZXg7ICsrYmx1ZUluZGV4KSB7XG4gICAgICAgICAgICBsaW5lICs9IHRoaXMuX3dlaWdodHNbYWxwaGFJbmRleF1bcmVkSW5kZXhdW2dyZWVuSW5kZXhdW2JsdWVJbmRleF07XG4gICAgICAgICAgICBsaW5lUmVkICs9IHRoaXMuX21vbWVudHNSZWRbYWxwaGFJbmRleF1bcmVkSW5kZXhdW2dyZWVuSW5kZXhdW2JsdWVJbmRleF07XG4gICAgICAgICAgICBsaW5lR3JlZW4gKz0gdGhpcy5fbW9tZW50c0dyZWVuW2FscGhhSW5kZXhdW3JlZEluZGV4XVtncmVlbkluZGV4XVtibHVlSW5kZXhdO1xuICAgICAgICAgICAgbGluZUJsdWUgKz0gdGhpcy5fbW9tZW50c0JsdWVbYWxwaGFJbmRleF1bcmVkSW5kZXhdW2dyZWVuSW5kZXhdW2JsdWVJbmRleF07XG4gICAgICAgICAgICBsaW5lQWxwaGEgKz0gdGhpcy5fbW9tZW50c0FscGhhW2FscGhhSW5kZXhdW3JlZEluZGV4XVtncmVlbkluZGV4XVtibHVlSW5kZXhdO1xuICAgICAgICAgICAgbGluZTIgKz0gdGhpcy5fbW9tZW50c1thbHBoYUluZGV4XVtyZWRJbmRleF1bZ3JlZW5JbmRleF1bYmx1ZUluZGV4XTtcbiAgICAgICAgICAgIGFyZWFbYmx1ZUluZGV4XSArPSBsaW5lO1xuICAgICAgICAgICAgYXJlYVJlZFtibHVlSW5kZXhdICs9IGxpbmVSZWQ7XG4gICAgICAgICAgICBhcmVhR3JlZW5bYmx1ZUluZGV4XSArPSBsaW5lR3JlZW47XG4gICAgICAgICAgICBhcmVhQmx1ZVtibHVlSW5kZXhdICs9IGxpbmVCbHVlO1xuICAgICAgICAgICAgYXJlYUFscGhhW2JsdWVJbmRleF0gKz0gbGluZUFscGhhO1xuICAgICAgICAgICAgYXJlYTJbYmx1ZUluZGV4XSArPSBsaW5lMjtcbiAgICAgICAgICAgIHhhcmVhW3JlZEluZGV4XVtncmVlbkluZGV4XVtibHVlSW5kZXhdID0geGFyZWFbcmVkSW5kZXggLSAxXVtncmVlbkluZGV4XVtibHVlSW5kZXhdICsgYXJlYVtibHVlSW5kZXhdO1xuICAgICAgICAgICAgeGFyZWFSZWRbcmVkSW5kZXhdW2dyZWVuSW5kZXhdW2JsdWVJbmRleF0gPSB4YXJlYVJlZFtyZWRJbmRleCAtIDFdW2dyZWVuSW5kZXhdW2JsdWVJbmRleF0gKyBhcmVhUmVkW2JsdWVJbmRleF07XG4gICAgICAgICAgICB4YXJlYUdyZWVuW3JlZEluZGV4XVtncmVlbkluZGV4XVtibHVlSW5kZXhdID0geGFyZWFHcmVlbltyZWRJbmRleCAtIDFdW2dyZWVuSW5kZXhdW2JsdWVJbmRleF0gKyBhcmVhR3JlZW5bYmx1ZUluZGV4XTtcbiAgICAgICAgICAgIHhhcmVhQmx1ZVtyZWRJbmRleF1bZ3JlZW5JbmRleF1bYmx1ZUluZGV4XSA9IHhhcmVhQmx1ZVtyZWRJbmRleCAtIDFdW2dyZWVuSW5kZXhdW2JsdWVJbmRleF0gKyBhcmVhQmx1ZVtibHVlSW5kZXhdO1xuICAgICAgICAgICAgeGFyZWFBbHBoYVtyZWRJbmRleF1bZ3JlZW5JbmRleF1bYmx1ZUluZGV4XSA9IHhhcmVhQWxwaGFbcmVkSW5kZXggLSAxXVtncmVlbkluZGV4XVtibHVlSW5kZXhdICsgYXJlYUFscGhhW2JsdWVJbmRleF07XG4gICAgICAgICAgICB4YXJlYTJbcmVkSW5kZXhdW2dyZWVuSW5kZXhdW2JsdWVJbmRleF0gPSB4YXJlYTJbcmVkSW5kZXggLSAxXVtncmVlbkluZGV4XVtibHVlSW5kZXhdICsgYXJlYTJbYmx1ZUluZGV4XTtcbiAgICAgICAgICAgIHRoaXMuX3dlaWdodHNbYWxwaGFJbmRleF1bcmVkSW5kZXhdW2dyZWVuSW5kZXhdW2JsdWVJbmRleF0gPSB0aGlzLl93ZWlnaHRzW2FscGhhSW5kZXggLSAxXVtyZWRJbmRleF1bZ3JlZW5JbmRleF1bYmx1ZUluZGV4XSArIHhhcmVhW3JlZEluZGV4XVtncmVlbkluZGV4XVtibHVlSW5kZXhdO1xuICAgICAgICAgICAgdGhpcy5fbW9tZW50c1JlZFthbHBoYUluZGV4XVtyZWRJbmRleF1bZ3JlZW5JbmRleF1bYmx1ZUluZGV4XSA9IHRoaXMuX21vbWVudHNSZWRbYWxwaGFJbmRleCAtIDFdW3JlZEluZGV4XVtncmVlbkluZGV4XVtibHVlSW5kZXhdICsgeGFyZWFSZWRbcmVkSW5kZXhdW2dyZWVuSW5kZXhdW2JsdWVJbmRleF07XG4gICAgICAgICAgICB0aGlzLl9tb21lbnRzR3JlZW5bYWxwaGFJbmRleF1bcmVkSW5kZXhdW2dyZWVuSW5kZXhdW2JsdWVJbmRleF0gPSB0aGlzLl9tb21lbnRzR3JlZW5bYWxwaGFJbmRleCAtIDFdW3JlZEluZGV4XVtncmVlbkluZGV4XVtibHVlSW5kZXhdICsgeGFyZWFHcmVlbltyZWRJbmRleF1bZ3JlZW5JbmRleF1bYmx1ZUluZGV4XTtcbiAgICAgICAgICAgIHRoaXMuX21vbWVudHNCbHVlW2FscGhhSW5kZXhdW3JlZEluZGV4XVtncmVlbkluZGV4XVtibHVlSW5kZXhdID0gdGhpcy5fbW9tZW50c0JsdWVbYWxwaGFJbmRleCAtIDFdW3JlZEluZGV4XVtncmVlbkluZGV4XVtibHVlSW5kZXhdICsgeGFyZWFCbHVlW3JlZEluZGV4XVtncmVlbkluZGV4XVtibHVlSW5kZXhdO1xuICAgICAgICAgICAgdGhpcy5fbW9tZW50c0FscGhhW2FscGhhSW5kZXhdW3JlZEluZGV4XVtncmVlbkluZGV4XVtibHVlSW5kZXhdID0gdGhpcy5fbW9tZW50c0FscGhhW2FscGhhSW5kZXggLSAxXVtyZWRJbmRleF1bZ3JlZW5JbmRleF1bYmx1ZUluZGV4XSArIHhhcmVhQWxwaGFbcmVkSW5kZXhdW2dyZWVuSW5kZXhdW2JsdWVJbmRleF07XG4gICAgICAgICAgICB0aGlzLl9tb21lbnRzW2FscGhhSW5kZXhdW3JlZEluZGV4XVtncmVlbkluZGV4XVtibHVlSW5kZXhdID0gdGhpcy5fbW9tZW50c1thbHBoYUluZGV4IC0gMV1bcmVkSW5kZXhdW2dyZWVuSW5kZXhdW2JsdWVJbmRleF0gKyB4YXJlYTJbcmVkSW5kZXhdW2dyZWVuSW5kZXhdW2JsdWVJbmRleF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHN0YXRpYyBfdm9sdW1lRmxvYXQoY3ViZSwgbW9tZW50KSB7XG4gICAgcmV0dXJuIG1vbWVudFtjdWJlLmFscGhhTWF4aW11bV1bY3ViZS5yZWRNYXhpbXVtXVtjdWJlLmdyZWVuTWF4aW11bV1bY3ViZS5ibHVlTWF4aW11bV0gLSBtb21lbnRbY3ViZS5hbHBoYU1heGltdW1dW2N1YmUucmVkTWF4aW11bV1bY3ViZS5ncmVlbk1pbmltdW1dW2N1YmUuYmx1ZU1heGltdW1dIC0gbW9tZW50W2N1YmUuYWxwaGFNYXhpbXVtXVtjdWJlLnJlZE1pbmltdW1dW2N1YmUuZ3JlZW5NYXhpbXVtXVtjdWJlLmJsdWVNYXhpbXVtXSArIG1vbWVudFtjdWJlLmFscGhhTWF4aW11bV1bY3ViZS5yZWRNaW5pbXVtXVtjdWJlLmdyZWVuTWluaW11bV1bY3ViZS5ibHVlTWF4aW11bV0gLSBtb21lbnRbY3ViZS5hbHBoYU1pbmltdW1dW2N1YmUucmVkTWF4aW11bV1bY3ViZS5ncmVlbk1heGltdW1dW2N1YmUuYmx1ZU1heGltdW1dICsgbW9tZW50W2N1YmUuYWxwaGFNaW5pbXVtXVtjdWJlLnJlZE1heGltdW1dW2N1YmUuZ3JlZW5NaW5pbXVtXVtjdWJlLmJsdWVNYXhpbXVtXSArIG1vbWVudFtjdWJlLmFscGhhTWluaW11bV1bY3ViZS5yZWRNaW5pbXVtXVtjdWJlLmdyZWVuTWF4aW11bV1bY3ViZS5ibHVlTWF4aW11bV0gLSBtb21lbnRbY3ViZS5hbHBoYU1pbmltdW1dW2N1YmUucmVkTWluaW11bV1bY3ViZS5ncmVlbk1pbmltdW1dW2N1YmUuYmx1ZU1heGltdW1dIC0gKG1vbWVudFtjdWJlLmFscGhhTWF4aW11bV1bY3ViZS5yZWRNYXhpbXVtXVtjdWJlLmdyZWVuTWF4aW11bV1bY3ViZS5ibHVlTWluaW11bV0gLSBtb21lbnRbY3ViZS5hbHBoYU1pbmltdW1dW2N1YmUucmVkTWF4aW11bV1bY3ViZS5ncmVlbk1heGltdW1dW2N1YmUuYmx1ZU1pbmltdW1dIC0gbW9tZW50W2N1YmUuYWxwaGFNYXhpbXVtXVtjdWJlLnJlZE1heGltdW1dW2N1YmUuZ3JlZW5NaW5pbXVtXVtjdWJlLmJsdWVNaW5pbXVtXSArIG1vbWVudFtjdWJlLmFscGhhTWluaW11bV1bY3ViZS5yZWRNYXhpbXVtXVtjdWJlLmdyZWVuTWluaW11bV1bY3ViZS5ibHVlTWluaW11bV0gLSBtb21lbnRbY3ViZS5hbHBoYU1heGltdW1dW2N1YmUucmVkTWluaW11bV1bY3ViZS5ncmVlbk1heGltdW1dW2N1YmUuYmx1ZU1pbmltdW1dICsgbW9tZW50W2N1YmUuYWxwaGFNaW5pbXVtXVtjdWJlLnJlZE1pbmltdW1dW2N1YmUuZ3JlZW5NYXhpbXVtXVtjdWJlLmJsdWVNaW5pbXVtXSArIG1vbWVudFtjdWJlLmFscGhhTWF4aW11bV1bY3ViZS5yZWRNaW5pbXVtXVtjdWJlLmdyZWVuTWluaW11bV1bY3ViZS5ibHVlTWluaW11bV0gLSBtb21lbnRbY3ViZS5hbHBoYU1pbmltdW1dW2N1YmUucmVkTWluaW11bV1bY3ViZS5ncmVlbk1pbmltdW1dW2N1YmUuYmx1ZU1pbmltdW1dKTtcbiAgfVxuICBzdGF0aWMgX3ZvbHVtZShjdWJlLCBtb21lbnQpIHtcbiAgICByZXR1cm4gX1d1UXVhbnQuX3ZvbHVtZUZsb2F0KGN1YmUsIG1vbWVudCkgfCAwO1xuICB9XG4gIHN0YXRpYyBfdG9wKGN1YmUsIGRpcmVjdGlvbiwgcG9zaXRpb24sIG1vbWVudCkge1xuICAgIGxldCByZXN1bHQ7XG4gICAgc3dpdGNoIChkaXJlY3Rpb24pIHtcbiAgICAgIGNhc2UgX1d1UXVhbnQuX2FscGhhOlxuICAgICAgICByZXN1bHQgPSBtb21lbnRbcG9zaXRpb25dW2N1YmUucmVkTWF4aW11bV1bY3ViZS5ncmVlbk1heGltdW1dW2N1YmUuYmx1ZU1heGltdW1dIC0gbW9tZW50W3Bvc2l0aW9uXVtjdWJlLnJlZE1heGltdW1dW2N1YmUuZ3JlZW5NaW5pbXVtXVtjdWJlLmJsdWVNYXhpbXVtXSAtIG1vbWVudFtwb3NpdGlvbl1bY3ViZS5yZWRNaW5pbXVtXVtjdWJlLmdyZWVuTWF4aW11bV1bY3ViZS5ibHVlTWF4aW11bV0gKyBtb21lbnRbcG9zaXRpb25dW2N1YmUucmVkTWluaW11bV1bY3ViZS5ncmVlbk1pbmltdW1dW2N1YmUuYmx1ZU1heGltdW1dIC0gKG1vbWVudFtwb3NpdGlvbl1bY3ViZS5yZWRNYXhpbXVtXVtjdWJlLmdyZWVuTWF4aW11bV1bY3ViZS5ibHVlTWluaW11bV0gLSBtb21lbnRbcG9zaXRpb25dW2N1YmUucmVkTWF4aW11bV1bY3ViZS5ncmVlbk1pbmltdW1dW2N1YmUuYmx1ZU1pbmltdW1dIC0gbW9tZW50W3Bvc2l0aW9uXVtjdWJlLnJlZE1pbmltdW1dW2N1YmUuZ3JlZW5NYXhpbXVtXVtjdWJlLmJsdWVNaW5pbXVtXSArIG1vbWVudFtwb3NpdGlvbl1bY3ViZS5yZWRNaW5pbXVtXVtjdWJlLmdyZWVuTWluaW11bV1bY3ViZS5ibHVlTWluaW11bV0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgX1d1UXVhbnQuX3JlZDpcbiAgICAgICAgcmVzdWx0ID0gbW9tZW50W2N1YmUuYWxwaGFNYXhpbXVtXVtwb3NpdGlvbl1bY3ViZS5ncmVlbk1heGltdW1dW2N1YmUuYmx1ZU1heGltdW1dIC0gbW9tZW50W2N1YmUuYWxwaGFNYXhpbXVtXVtwb3NpdGlvbl1bY3ViZS5ncmVlbk1pbmltdW1dW2N1YmUuYmx1ZU1heGltdW1dIC0gbW9tZW50W2N1YmUuYWxwaGFNaW5pbXVtXVtwb3NpdGlvbl1bY3ViZS5ncmVlbk1heGltdW1dW2N1YmUuYmx1ZU1heGltdW1dICsgbW9tZW50W2N1YmUuYWxwaGFNaW5pbXVtXVtwb3NpdGlvbl1bY3ViZS5ncmVlbk1pbmltdW1dW2N1YmUuYmx1ZU1heGltdW1dIC0gKG1vbWVudFtjdWJlLmFscGhhTWF4aW11bV1bcG9zaXRpb25dW2N1YmUuZ3JlZW5NYXhpbXVtXVtjdWJlLmJsdWVNaW5pbXVtXSAtIG1vbWVudFtjdWJlLmFscGhhTWF4aW11bV1bcG9zaXRpb25dW2N1YmUuZ3JlZW5NaW5pbXVtXVtjdWJlLmJsdWVNaW5pbXVtXSAtIG1vbWVudFtjdWJlLmFscGhhTWluaW11bV1bcG9zaXRpb25dW2N1YmUuZ3JlZW5NYXhpbXVtXVtjdWJlLmJsdWVNaW5pbXVtXSArIG1vbWVudFtjdWJlLmFscGhhTWluaW11bV1bcG9zaXRpb25dW2N1YmUuZ3JlZW5NaW5pbXVtXVtjdWJlLmJsdWVNaW5pbXVtXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBfV3VRdWFudC5fZ3JlZW46XG4gICAgICAgIHJlc3VsdCA9IG1vbWVudFtjdWJlLmFscGhhTWF4aW11bV1bY3ViZS5yZWRNYXhpbXVtXVtwb3NpdGlvbl1bY3ViZS5ibHVlTWF4aW11bV0gLSBtb21lbnRbY3ViZS5hbHBoYU1heGltdW1dW2N1YmUucmVkTWluaW11bV1bcG9zaXRpb25dW2N1YmUuYmx1ZU1heGltdW1dIC0gbW9tZW50W2N1YmUuYWxwaGFNaW5pbXVtXVtjdWJlLnJlZE1heGltdW1dW3Bvc2l0aW9uXVtjdWJlLmJsdWVNYXhpbXVtXSArIG1vbWVudFtjdWJlLmFscGhhTWluaW11bV1bY3ViZS5yZWRNaW5pbXVtXVtwb3NpdGlvbl1bY3ViZS5ibHVlTWF4aW11bV0gLSAobW9tZW50W2N1YmUuYWxwaGFNYXhpbXVtXVtjdWJlLnJlZE1heGltdW1dW3Bvc2l0aW9uXVtjdWJlLmJsdWVNaW5pbXVtXSAtIG1vbWVudFtjdWJlLmFscGhhTWF4aW11bV1bY3ViZS5yZWRNaW5pbXVtXVtwb3NpdGlvbl1bY3ViZS5ibHVlTWluaW11bV0gLSBtb21lbnRbY3ViZS5hbHBoYU1pbmltdW1dW2N1YmUucmVkTWF4aW11bV1bcG9zaXRpb25dW2N1YmUuYmx1ZU1pbmltdW1dICsgbW9tZW50W2N1YmUuYWxwaGFNaW5pbXVtXVtjdWJlLnJlZE1pbmltdW1dW3Bvc2l0aW9uXVtjdWJlLmJsdWVNaW5pbXVtXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBfV3VRdWFudC5fYmx1ZTpcbiAgICAgICAgcmVzdWx0ID0gbW9tZW50W2N1YmUuYWxwaGFNYXhpbXVtXVtjdWJlLnJlZE1heGltdW1dW2N1YmUuZ3JlZW5NYXhpbXVtXVtwb3NpdGlvbl0gLSBtb21lbnRbY3ViZS5hbHBoYU1heGltdW1dW2N1YmUucmVkTWF4aW11bV1bY3ViZS5ncmVlbk1pbmltdW1dW3Bvc2l0aW9uXSAtIG1vbWVudFtjdWJlLmFscGhhTWF4aW11bV1bY3ViZS5yZWRNaW5pbXVtXVtjdWJlLmdyZWVuTWF4aW11bV1bcG9zaXRpb25dICsgbW9tZW50W2N1YmUuYWxwaGFNYXhpbXVtXVtjdWJlLnJlZE1pbmltdW1dW2N1YmUuZ3JlZW5NaW5pbXVtXVtwb3NpdGlvbl0gLSAobW9tZW50W2N1YmUuYWxwaGFNaW5pbXVtXVtjdWJlLnJlZE1heGltdW1dW2N1YmUuZ3JlZW5NYXhpbXVtXVtwb3NpdGlvbl0gLSBtb21lbnRbY3ViZS5hbHBoYU1pbmltdW1dW2N1YmUucmVkTWF4aW11bV1bY3ViZS5ncmVlbk1pbmltdW1dW3Bvc2l0aW9uXSAtIG1vbWVudFtjdWJlLmFscGhhTWluaW11bV1bY3ViZS5yZWRNaW5pbXVtXVtjdWJlLmdyZWVuTWF4aW11bV1bcG9zaXRpb25dICsgbW9tZW50W2N1YmUuYWxwaGFNaW5pbXVtXVtjdWJlLnJlZE1pbmltdW1dW2N1YmUuZ3JlZW5NaW5pbXVtXVtwb3NpdGlvbl0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImltcG9zc2libGVcIik7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQgfCAwO1xuICB9XG4gIHN0YXRpYyBfYm90dG9tKGN1YmUsIGRpcmVjdGlvbiwgbW9tZW50KSB7XG4gICAgc3dpdGNoIChkaXJlY3Rpb24pIHtcbiAgICAgIGNhc2UgX1d1UXVhbnQuX2FscGhhOlxuICAgICAgICByZXR1cm4gLW1vbWVudFtjdWJlLmFscGhhTWluaW11bV1bY3ViZS5yZWRNYXhpbXVtXVtjdWJlLmdyZWVuTWF4aW11bV1bY3ViZS5ibHVlTWF4aW11bV0gKyBtb21lbnRbY3ViZS5hbHBoYU1pbmltdW1dW2N1YmUucmVkTWF4aW11bV1bY3ViZS5ncmVlbk1pbmltdW1dW2N1YmUuYmx1ZU1heGltdW1dICsgbW9tZW50W2N1YmUuYWxwaGFNaW5pbXVtXVtjdWJlLnJlZE1pbmltdW1dW2N1YmUuZ3JlZW5NYXhpbXVtXVtjdWJlLmJsdWVNYXhpbXVtXSAtIG1vbWVudFtjdWJlLmFscGhhTWluaW11bV1bY3ViZS5yZWRNaW5pbXVtXVtjdWJlLmdyZWVuTWluaW11bV1bY3ViZS5ibHVlTWF4aW11bV0gLSAoLW1vbWVudFtjdWJlLmFscGhhTWluaW11bV1bY3ViZS5yZWRNYXhpbXVtXVtjdWJlLmdyZWVuTWF4aW11bV1bY3ViZS5ibHVlTWluaW11bV0gKyBtb21lbnRbY3ViZS5hbHBoYU1pbmltdW1dW2N1YmUucmVkTWF4aW11bV1bY3ViZS5ncmVlbk1pbmltdW1dW2N1YmUuYmx1ZU1pbmltdW1dICsgbW9tZW50W2N1YmUuYWxwaGFNaW5pbXVtXVtjdWJlLnJlZE1pbmltdW1dW2N1YmUuZ3JlZW5NYXhpbXVtXVtjdWJlLmJsdWVNaW5pbXVtXSAtIG1vbWVudFtjdWJlLmFscGhhTWluaW11bV1bY3ViZS5yZWRNaW5pbXVtXVtjdWJlLmdyZWVuTWluaW11bV1bY3ViZS5ibHVlTWluaW11bV0pO1xuICAgICAgY2FzZSBfV3VRdWFudC5fcmVkOlxuICAgICAgICByZXR1cm4gLW1vbWVudFtjdWJlLmFscGhhTWF4aW11bV1bY3ViZS5yZWRNaW5pbXVtXVtjdWJlLmdyZWVuTWF4aW11bV1bY3ViZS5ibHVlTWF4aW11bV0gKyBtb21lbnRbY3ViZS5hbHBoYU1heGltdW1dW2N1YmUucmVkTWluaW11bV1bY3ViZS5ncmVlbk1pbmltdW1dW2N1YmUuYmx1ZU1heGltdW1dICsgbW9tZW50W2N1YmUuYWxwaGFNaW5pbXVtXVtjdWJlLnJlZE1pbmltdW1dW2N1YmUuZ3JlZW5NYXhpbXVtXVtjdWJlLmJsdWVNYXhpbXVtXSAtIG1vbWVudFtjdWJlLmFscGhhTWluaW11bV1bY3ViZS5yZWRNaW5pbXVtXVtjdWJlLmdyZWVuTWluaW11bV1bY3ViZS5ibHVlTWF4aW11bV0gLSAoLW1vbWVudFtjdWJlLmFscGhhTWF4aW11bV1bY3ViZS5yZWRNaW5pbXVtXVtjdWJlLmdyZWVuTWF4aW11bV1bY3ViZS5ibHVlTWluaW11bV0gKyBtb21lbnRbY3ViZS5hbHBoYU1heGltdW1dW2N1YmUucmVkTWluaW11bV1bY3ViZS5ncmVlbk1pbmltdW1dW2N1YmUuYmx1ZU1pbmltdW1dICsgbW9tZW50W2N1YmUuYWxwaGFNaW5pbXVtXVtjdWJlLnJlZE1pbmltdW1dW2N1YmUuZ3JlZW5NYXhpbXVtXVtjdWJlLmJsdWVNaW5pbXVtXSAtIG1vbWVudFtjdWJlLmFscGhhTWluaW11bV1bY3ViZS5yZWRNaW5pbXVtXVtjdWJlLmdyZWVuTWluaW11bV1bY3ViZS5ibHVlTWluaW11bV0pO1xuICAgICAgY2FzZSBfV3VRdWFudC5fZ3JlZW46XG4gICAgICAgIHJldHVybiAtbW9tZW50W2N1YmUuYWxwaGFNYXhpbXVtXVtjdWJlLnJlZE1heGltdW1dW2N1YmUuZ3JlZW5NaW5pbXVtXVtjdWJlLmJsdWVNYXhpbXVtXSArIG1vbWVudFtjdWJlLmFscGhhTWF4aW11bV1bY3ViZS5yZWRNaW5pbXVtXVtjdWJlLmdyZWVuTWluaW11bV1bY3ViZS5ibHVlTWF4aW11bV0gKyBtb21lbnRbY3ViZS5hbHBoYU1pbmltdW1dW2N1YmUucmVkTWF4aW11bV1bY3ViZS5ncmVlbk1pbmltdW1dW2N1YmUuYmx1ZU1heGltdW1dIC0gbW9tZW50W2N1YmUuYWxwaGFNaW5pbXVtXVtjdWJlLnJlZE1pbmltdW1dW2N1YmUuZ3JlZW5NaW5pbXVtXVtjdWJlLmJsdWVNYXhpbXVtXSAtICgtbW9tZW50W2N1YmUuYWxwaGFNYXhpbXVtXVtjdWJlLnJlZE1heGltdW1dW2N1YmUuZ3JlZW5NaW5pbXVtXVtjdWJlLmJsdWVNaW5pbXVtXSArIG1vbWVudFtjdWJlLmFscGhhTWF4aW11bV1bY3ViZS5yZWRNaW5pbXVtXVtjdWJlLmdyZWVuTWluaW11bV1bY3ViZS5ibHVlTWluaW11bV0gKyBtb21lbnRbY3ViZS5hbHBoYU1pbmltdW1dW2N1YmUucmVkTWF4aW11bV1bY3ViZS5ncmVlbk1pbmltdW1dW2N1YmUuYmx1ZU1pbmltdW1dIC0gbW9tZW50W2N1YmUuYWxwaGFNaW5pbXVtXVtjdWJlLnJlZE1pbmltdW1dW2N1YmUuZ3JlZW5NaW5pbXVtXVtjdWJlLmJsdWVNaW5pbXVtXSk7XG4gICAgICBjYXNlIF9XdVF1YW50Ll9ibHVlOlxuICAgICAgICByZXR1cm4gLW1vbWVudFtjdWJlLmFscGhhTWF4aW11bV1bY3ViZS5yZWRNYXhpbXVtXVtjdWJlLmdyZWVuTWF4aW11bV1bY3ViZS5ibHVlTWluaW11bV0gKyBtb21lbnRbY3ViZS5hbHBoYU1heGltdW1dW2N1YmUucmVkTWF4aW11bV1bY3ViZS5ncmVlbk1pbmltdW1dW2N1YmUuYmx1ZU1pbmltdW1dICsgbW9tZW50W2N1YmUuYWxwaGFNYXhpbXVtXVtjdWJlLnJlZE1pbmltdW1dW2N1YmUuZ3JlZW5NYXhpbXVtXVtjdWJlLmJsdWVNaW5pbXVtXSAtIG1vbWVudFtjdWJlLmFscGhhTWF4aW11bV1bY3ViZS5yZWRNaW5pbXVtXVtjdWJlLmdyZWVuTWluaW11bV1bY3ViZS5ibHVlTWluaW11bV0gLSAoLW1vbWVudFtjdWJlLmFscGhhTWluaW11bV1bY3ViZS5yZWRNYXhpbXVtXVtjdWJlLmdyZWVuTWF4aW11bV1bY3ViZS5ibHVlTWluaW11bV0gKyBtb21lbnRbY3ViZS5hbHBoYU1pbmltdW1dW2N1YmUucmVkTWF4aW11bV1bY3ViZS5ncmVlbk1pbmltdW1dW2N1YmUuYmx1ZU1pbmltdW1dICsgbW9tZW50W2N1YmUuYWxwaGFNaW5pbXVtXVtjdWJlLnJlZE1pbmltdW1dW2N1YmUuZ3JlZW5NYXhpbXVtXVtjdWJlLmJsdWVNaW5pbXVtXSAtIG1vbWVudFtjdWJlLmFscGhhTWluaW11bV1bY3ViZS5yZWRNaW5pbXVtXVtjdWJlLmdyZWVuTWluaW11bV1bY3ViZS5ibHVlTWluaW11bV0pO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICB9XG4gIF9jYWxjdWxhdGVWYXJpYW5jZShjdWJlKSB7XG4gICAgY29uc3Qgdm9sdW1lUmVkID0gX1d1UXVhbnQuX3ZvbHVtZShjdWJlLCB0aGlzLl9tb21lbnRzUmVkKTtcbiAgICBjb25zdCB2b2x1bWVHcmVlbiA9IF9XdVF1YW50Ll92b2x1bWUoY3ViZSwgdGhpcy5fbW9tZW50c0dyZWVuKTtcbiAgICBjb25zdCB2b2x1bWVCbHVlID0gX1d1UXVhbnQuX3ZvbHVtZShjdWJlLCB0aGlzLl9tb21lbnRzQmx1ZSk7XG4gICAgY29uc3Qgdm9sdW1lQWxwaGEgPSBfV3VRdWFudC5fdm9sdW1lKGN1YmUsIHRoaXMuX21vbWVudHNBbHBoYSk7XG4gICAgY29uc3Qgdm9sdW1lTW9tZW50ID0gX1d1UXVhbnQuX3ZvbHVtZUZsb2F0KGN1YmUsIHRoaXMuX21vbWVudHMpO1xuICAgIGNvbnN0IHZvbHVtZVdlaWdodCA9IF9XdVF1YW50Ll92b2x1bWUoY3ViZSwgdGhpcy5fd2VpZ2h0cyk7XG4gICAgY29uc3QgZGlzdGFuY2UgPSB2b2x1bWVSZWQgKiB2b2x1bWVSZWQgKyB2b2x1bWVHcmVlbiAqIHZvbHVtZUdyZWVuICsgdm9sdW1lQmx1ZSAqIHZvbHVtZUJsdWUgKyB2b2x1bWVBbHBoYSAqIHZvbHVtZUFscGhhO1xuICAgIHJldHVybiB2b2x1bWVNb21lbnQgLSBkaXN0YW5jZSAvIHZvbHVtZVdlaWdodDtcbiAgfVxuICBfbWF4aW1pemUoY3ViZSwgZGlyZWN0aW9uLCBmaXJzdCwgbGFzdCwgd2hvbGVSZWQsIHdob2xlR3JlZW4sIHdob2xlQmx1ZSwgd2hvbGVBbHBoYSwgd2hvbGVXZWlnaHQpIHtcbiAgICBjb25zdCBib3R0b21SZWQgPSBfV3VRdWFudC5fYm90dG9tKGN1YmUsIGRpcmVjdGlvbiwgdGhpcy5fbW9tZW50c1JlZCkgfCAwO1xuICAgIGNvbnN0IGJvdHRvbUdyZWVuID0gX1d1UXVhbnQuX2JvdHRvbShjdWJlLCBkaXJlY3Rpb24sIHRoaXMuX21vbWVudHNHcmVlbikgfCAwO1xuICAgIGNvbnN0IGJvdHRvbUJsdWUgPSBfV3VRdWFudC5fYm90dG9tKGN1YmUsIGRpcmVjdGlvbiwgdGhpcy5fbW9tZW50c0JsdWUpIHwgMDtcbiAgICBjb25zdCBib3R0b21BbHBoYSA9IF9XdVF1YW50Ll9ib3R0b20oY3ViZSwgZGlyZWN0aW9uLCB0aGlzLl9tb21lbnRzQWxwaGEpIHwgMDtcbiAgICBjb25zdCBib3R0b21XZWlnaHQgPSBfV3VRdWFudC5fYm90dG9tKGN1YmUsIGRpcmVjdGlvbiwgdGhpcy5fd2VpZ2h0cykgfCAwO1xuICAgIGxldCByZXN1bHQgPSAwO1xuICAgIGxldCBjdXRQb3NpdGlvbiA9IC0xO1xuICAgIGZvciAobGV0IHBvc2l0aW9uID0gZmlyc3Q7IHBvc2l0aW9uIDwgbGFzdDsgKytwb3NpdGlvbikge1xuICAgICAgbGV0IGhhbGZSZWQgPSBib3R0b21SZWQgKyBfV3VRdWFudC5fdG9wKGN1YmUsIGRpcmVjdGlvbiwgcG9zaXRpb24sIHRoaXMuX21vbWVudHNSZWQpO1xuICAgICAgbGV0IGhhbGZHcmVlbiA9IGJvdHRvbUdyZWVuICsgX1d1UXVhbnQuX3RvcChjdWJlLCBkaXJlY3Rpb24sIHBvc2l0aW9uLCB0aGlzLl9tb21lbnRzR3JlZW4pO1xuICAgICAgbGV0IGhhbGZCbHVlID0gYm90dG9tQmx1ZSArIF9XdVF1YW50Ll90b3AoY3ViZSwgZGlyZWN0aW9uLCBwb3NpdGlvbiwgdGhpcy5fbW9tZW50c0JsdWUpO1xuICAgICAgbGV0IGhhbGZBbHBoYSA9IGJvdHRvbUFscGhhICsgX1d1UXVhbnQuX3RvcChjdWJlLCBkaXJlY3Rpb24sIHBvc2l0aW9uLCB0aGlzLl9tb21lbnRzQWxwaGEpO1xuICAgICAgbGV0IGhhbGZXZWlnaHQgPSBib3R0b21XZWlnaHQgKyBfV3VRdWFudC5fdG9wKGN1YmUsIGRpcmVjdGlvbiwgcG9zaXRpb24sIHRoaXMuX3dlaWdodHMpO1xuICAgICAgaWYgKGhhbGZXZWlnaHQgIT09IDApIHtcbiAgICAgICAgbGV0IGhhbGZEaXN0YW5jZSA9IGhhbGZSZWQgKiBoYWxmUmVkICsgaGFsZkdyZWVuICogaGFsZkdyZWVuICsgaGFsZkJsdWUgKiBoYWxmQmx1ZSArIGhhbGZBbHBoYSAqIGhhbGZBbHBoYTtcbiAgICAgICAgbGV0IHRlbXAgPSBoYWxmRGlzdGFuY2UgLyBoYWxmV2VpZ2h0O1xuICAgICAgICBoYWxmUmVkID0gd2hvbGVSZWQgLSBoYWxmUmVkO1xuICAgICAgICBoYWxmR3JlZW4gPSB3aG9sZUdyZWVuIC0gaGFsZkdyZWVuO1xuICAgICAgICBoYWxmQmx1ZSA9IHdob2xlQmx1ZSAtIGhhbGZCbHVlO1xuICAgICAgICBoYWxmQWxwaGEgPSB3aG9sZUFscGhhIC0gaGFsZkFscGhhO1xuICAgICAgICBoYWxmV2VpZ2h0ID0gd2hvbGVXZWlnaHQgLSBoYWxmV2VpZ2h0O1xuICAgICAgICBpZiAoaGFsZldlaWdodCAhPT0gMCkge1xuICAgICAgICAgIGhhbGZEaXN0YW5jZSA9IGhhbGZSZWQgKiBoYWxmUmVkICsgaGFsZkdyZWVuICogaGFsZkdyZWVuICsgaGFsZkJsdWUgKiBoYWxmQmx1ZSArIGhhbGZBbHBoYSAqIGhhbGZBbHBoYTtcbiAgICAgICAgICB0ZW1wICs9IGhhbGZEaXN0YW5jZSAvIGhhbGZXZWlnaHQ7XG4gICAgICAgICAgaWYgKHRlbXAgPiByZXN1bHQpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRlbXA7XG4gICAgICAgICAgICBjdXRQb3NpdGlvbiA9IHBvc2l0aW9uO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBtYXg6IHJlc3VsdCwgcG9zaXRpb246IGN1dFBvc2l0aW9uIH07XG4gIH1cbiAgX2N1dChmaXJzdCwgc2Vjb25kKSB7XG4gICAgbGV0IGRpcmVjdGlvbjtcbiAgICBjb25zdCB3aG9sZVJlZCA9IF9XdVF1YW50Ll92b2x1bWUoZmlyc3QsIHRoaXMuX21vbWVudHNSZWQpO1xuICAgIGNvbnN0IHdob2xlR3JlZW4gPSBfV3VRdWFudC5fdm9sdW1lKGZpcnN0LCB0aGlzLl9tb21lbnRzR3JlZW4pO1xuICAgIGNvbnN0IHdob2xlQmx1ZSA9IF9XdVF1YW50Ll92b2x1bWUoZmlyc3QsIHRoaXMuX21vbWVudHNCbHVlKTtcbiAgICBjb25zdCB3aG9sZUFscGhhID0gX1d1UXVhbnQuX3ZvbHVtZShmaXJzdCwgdGhpcy5fbW9tZW50c0FscGhhKTtcbiAgICBjb25zdCB3aG9sZVdlaWdodCA9IF9XdVF1YW50Ll92b2x1bWUoZmlyc3QsIHRoaXMuX3dlaWdodHMpO1xuICAgIGNvbnN0IHJlZCA9IHRoaXMuX21heGltaXplKGZpcnN0LCBfV3VRdWFudC5fcmVkLCBmaXJzdC5yZWRNaW5pbXVtICsgMSwgZmlyc3QucmVkTWF4aW11bSwgd2hvbGVSZWQsIHdob2xlR3JlZW4sIHdob2xlQmx1ZSwgd2hvbGVBbHBoYSwgd2hvbGVXZWlnaHQpO1xuICAgIGNvbnN0IGdyZWVuID0gdGhpcy5fbWF4aW1pemUoZmlyc3QsIF9XdVF1YW50Ll9ncmVlbiwgZmlyc3QuZ3JlZW5NaW5pbXVtICsgMSwgZmlyc3QuZ3JlZW5NYXhpbXVtLCB3aG9sZVJlZCwgd2hvbGVHcmVlbiwgd2hvbGVCbHVlLCB3aG9sZUFscGhhLCB3aG9sZVdlaWdodCk7XG4gICAgY29uc3QgYmx1ZSA9IHRoaXMuX21heGltaXplKGZpcnN0LCBfV3VRdWFudC5fYmx1ZSwgZmlyc3QuYmx1ZU1pbmltdW0gKyAxLCBmaXJzdC5ibHVlTWF4aW11bSwgd2hvbGVSZWQsIHdob2xlR3JlZW4sIHdob2xlQmx1ZSwgd2hvbGVBbHBoYSwgd2hvbGVXZWlnaHQpO1xuICAgIGNvbnN0IGFscGhhID0gdGhpcy5fbWF4aW1pemUoZmlyc3QsIF9XdVF1YW50Ll9hbHBoYSwgZmlyc3QuYWxwaGFNaW5pbXVtICsgMSwgZmlyc3QuYWxwaGFNYXhpbXVtLCB3aG9sZVJlZCwgd2hvbGVHcmVlbiwgd2hvbGVCbHVlLCB3aG9sZUFscGhhLCB3aG9sZVdlaWdodCk7XG4gICAgaWYgKGFscGhhLm1heCA+PSByZWQubWF4ICYmIGFscGhhLm1heCA+PSBncmVlbi5tYXggJiYgYWxwaGEubWF4ID49IGJsdWUubWF4KSB7XG4gICAgICBkaXJlY3Rpb24gPSBfV3VRdWFudC5fYWxwaGE7XG4gICAgICBpZiAoYWxwaGEucG9zaXRpb24gPCAwKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChyZWQubWF4ID49IGFscGhhLm1heCAmJiByZWQubWF4ID49IGdyZWVuLm1heCAmJiByZWQubWF4ID49IGJsdWUubWF4KSB7XG4gICAgICBkaXJlY3Rpb24gPSBfV3VRdWFudC5fcmVkO1xuICAgIH0gZWxzZSBpZiAoZ3JlZW4ubWF4ID49IGFscGhhLm1heCAmJiBncmVlbi5tYXggPj0gcmVkLm1heCAmJiBncmVlbi5tYXggPj0gYmx1ZS5tYXgpIHtcbiAgICAgIGRpcmVjdGlvbiA9IF9XdVF1YW50Ll9ncmVlbjtcbiAgICB9IGVsc2Uge1xuICAgICAgZGlyZWN0aW9uID0gX1d1UXVhbnQuX2JsdWU7XG4gICAgfVxuICAgIHNlY29uZC5yZWRNYXhpbXVtID0gZmlyc3QucmVkTWF4aW11bTtcbiAgICBzZWNvbmQuZ3JlZW5NYXhpbXVtID0gZmlyc3QuZ3JlZW5NYXhpbXVtO1xuICAgIHNlY29uZC5ibHVlTWF4aW11bSA9IGZpcnN0LmJsdWVNYXhpbXVtO1xuICAgIHNlY29uZC5hbHBoYU1heGltdW0gPSBmaXJzdC5hbHBoYU1heGltdW07XG4gICAgc3dpdGNoIChkaXJlY3Rpb24pIHtcbiAgICAgIGNhc2UgX1d1UXVhbnQuX3JlZDpcbiAgICAgICAgc2Vjb25kLnJlZE1pbmltdW0gPSBmaXJzdC5yZWRNYXhpbXVtID0gcmVkLnBvc2l0aW9uO1xuICAgICAgICBzZWNvbmQuZ3JlZW5NaW5pbXVtID0gZmlyc3QuZ3JlZW5NaW5pbXVtO1xuICAgICAgICBzZWNvbmQuYmx1ZU1pbmltdW0gPSBmaXJzdC5ibHVlTWluaW11bTtcbiAgICAgICAgc2Vjb25kLmFscGhhTWluaW11bSA9IGZpcnN0LmFscGhhTWluaW11bTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIF9XdVF1YW50Ll9ncmVlbjpcbiAgICAgICAgc2Vjb25kLmdyZWVuTWluaW11bSA9IGZpcnN0LmdyZWVuTWF4aW11bSA9IGdyZWVuLnBvc2l0aW9uO1xuICAgICAgICBzZWNvbmQucmVkTWluaW11bSA9IGZpcnN0LnJlZE1pbmltdW07XG4gICAgICAgIHNlY29uZC5ibHVlTWluaW11bSA9IGZpcnN0LmJsdWVNaW5pbXVtO1xuICAgICAgICBzZWNvbmQuYWxwaGFNaW5pbXVtID0gZmlyc3QuYWxwaGFNaW5pbXVtO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgX1d1UXVhbnQuX2JsdWU6XG4gICAgICAgIHNlY29uZC5ibHVlTWluaW11bSA9IGZpcnN0LmJsdWVNYXhpbXVtID0gYmx1ZS5wb3NpdGlvbjtcbiAgICAgICAgc2Vjb25kLnJlZE1pbmltdW0gPSBmaXJzdC5yZWRNaW5pbXVtO1xuICAgICAgICBzZWNvbmQuZ3JlZW5NaW5pbXVtID0gZmlyc3QuZ3JlZW5NaW5pbXVtO1xuICAgICAgICBzZWNvbmQuYWxwaGFNaW5pbXVtID0gZmlyc3QuYWxwaGFNaW5pbXVtO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgX1d1UXVhbnQuX2FscGhhOlxuICAgICAgICBzZWNvbmQuYWxwaGFNaW5pbXVtID0gZmlyc3QuYWxwaGFNYXhpbXVtID0gYWxwaGEucG9zaXRpb247XG4gICAgICAgIHNlY29uZC5ibHVlTWluaW11bSA9IGZpcnN0LmJsdWVNaW5pbXVtO1xuICAgICAgICBzZWNvbmQucmVkTWluaW11bSA9IGZpcnN0LnJlZE1pbmltdW07XG4gICAgICAgIHNlY29uZC5ncmVlbk1pbmltdW0gPSBmaXJzdC5ncmVlbk1pbmltdW07XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBmaXJzdC52b2x1bWUgPSAoZmlyc3QucmVkTWF4aW11bSAtIGZpcnN0LnJlZE1pbmltdW0pICogKGZpcnN0LmdyZWVuTWF4aW11bSAtIGZpcnN0LmdyZWVuTWluaW11bSkgKiAoZmlyc3QuYmx1ZU1heGltdW0gLSBmaXJzdC5ibHVlTWluaW11bSkgKiAoZmlyc3QuYWxwaGFNYXhpbXVtIC0gZmlyc3QuYWxwaGFNaW5pbXVtKTtcbiAgICBzZWNvbmQudm9sdW1lID0gKHNlY29uZC5yZWRNYXhpbXVtIC0gc2Vjb25kLnJlZE1pbmltdW0pICogKHNlY29uZC5ncmVlbk1heGltdW0gLSBzZWNvbmQuZ3JlZW5NaW5pbXVtKSAqIChzZWNvbmQuYmx1ZU1heGltdW0gLSBzZWNvbmQuYmx1ZU1pbmltdW0pICogKHNlY29uZC5hbHBoYU1heGltdW0gLSBzZWNvbmQuYWxwaGFNaW5pbXVtKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBfaW5pdGlhbGl6ZShjb2xvcnMpIHtcbiAgICB0aGlzLl9jb2xvcnMgPSBjb2xvcnM7XG4gICAgdGhpcy5fY3ViZXMgPSBbXTtcbiAgICBmb3IgKGxldCBjdWJlSW5kZXggPSAwOyBjdWJlSW5kZXggPCBjb2xvcnM7IGN1YmVJbmRleCsrKSB7XG4gICAgICB0aGlzLl9jdWJlc1tjdWJlSW5kZXhdID0gbmV3IFd1Q29sb3JDdWJlKCk7XG4gICAgfVxuICAgIHRoaXMuX2N1YmVzWzBdLnJlZE1pbmltdW0gPSAwO1xuICAgIHRoaXMuX2N1YmVzWzBdLmdyZWVuTWluaW11bSA9IDA7XG4gICAgdGhpcy5fY3ViZXNbMF0uYmx1ZU1pbmltdW0gPSAwO1xuICAgIHRoaXMuX2N1YmVzWzBdLmFscGhhTWluaW11bSA9IDA7XG4gICAgdGhpcy5fY3ViZXNbMF0ucmVkTWF4aW11bSA9IHRoaXMuX21heFNpZGVJbmRleDtcbiAgICB0aGlzLl9jdWJlc1swXS5ncmVlbk1heGltdW0gPSB0aGlzLl9tYXhTaWRlSW5kZXg7XG4gICAgdGhpcy5fY3ViZXNbMF0uYmx1ZU1heGltdW0gPSB0aGlzLl9tYXhTaWRlSW5kZXg7XG4gICAgdGhpcy5fY3ViZXNbMF0uYWxwaGFNYXhpbXVtID0gdGhpcy5fYWxwaGFNYXhTaWRlSW5kZXg7XG4gICAgdGhpcy5fd2VpZ2h0cyA9IGNyZWF0ZUFycmF5NEQodGhpcy5fYWxwaGFTaWRlU2l6ZSwgdGhpcy5fc2lkZVNpemUsIHRoaXMuX3NpZGVTaXplLCB0aGlzLl9zaWRlU2l6ZSk7XG4gICAgdGhpcy5fbW9tZW50c1JlZCA9IGNyZWF0ZUFycmF5NEQodGhpcy5fYWxwaGFTaWRlU2l6ZSwgdGhpcy5fc2lkZVNpemUsIHRoaXMuX3NpZGVTaXplLCB0aGlzLl9zaWRlU2l6ZSk7XG4gICAgdGhpcy5fbW9tZW50c0dyZWVuID0gY3JlYXRlQXJyYXk0RCh0aGlzLl9hbHBoYVNpZGVTaXplLCB0aGlzLl9zaWRlU2l6ZSwgdGhpcy5fc2lkZVNpemUsIHRoaXMuX3NpZGVTaXplKTtcbiAgICB0aGlzLl9tb21lbnRzQmx1ZSA9IGNyZWF0ZUFycmF5NEQodGhpcy5fYWxwaGFTaWRlU2l6ZSwgdGhpcy5fc2lkZVNpemUsIHRoaXMuX3NpZGVTaXplLCB0aGlzLl9zaWRlU2l6ZSk7XG4gICAgdGhpcy5fbW9tZW50c0FscGhhID0gY3JlYXRlQXJyYXk0RCh0aGlzLl9hbHBoYVNpZGVTaXplLCB0aGlzLl9zaWRlU2l6ZSwgdGhpcy5fc2lkZVNpemUsIHRoaXMuX3NpZGVTaXplKTtcbiAgICB0aGlzLl9tb21lbnRzID0gY3JlYXRlQXJyYXk0RCh0aGlzLl9hbHBoYVNpZGVTaXplLCB0aGlzLl9zaWRlU2l6ZSwgdGhpcy5fc2lkZVNpemUsIHRoaXMuX3NpZGVTaXplKTtcbiAgICB0aGlzLl90YWJsZSA9IFtdO1xuICAgIGZvciAobGV0IHRhYmxlSW5kZXggPSAwOyB0YWJsZUluZGV4IDwgMjU2OyArK3RhYmxlSW5kZXgpIHtcbiAgICAgIHRoaXMuX3RhYmxlW3RhYmxlSW5kZXhdID0gdGFibGVJbmRleCAqIHRhYmxlSW5kZXg7XG4gICAgfVxuICAgIHRoaXMuX3BpeGVscyA9IFtdO1xuICB9XG4gIF9zZXRRdWFsaXR5KHNpZ25pZmljYW50Qml0c1BlckNoYW5uZWwgPSA1KSB7XG4gICAgdGhpcy5fc2lnbmlmaWNhbnRCaXRzUGVyQ2hhbm5lbCA9IHNpZ25pZmljYW50Qml0c1BlckNoYW5uZWw7XG4gICAgdGhpcy5fbWF4U2lkZUluZGV4ID0gMSA8PCB0aGlzLl9zaWduaWZpY2FudEJpdHNQZXJDaGFubmVsO1xuICAgIHRoaXMuX2FscGhhTWF4U2lkZUluZGV4ID0gdGhpcy5fbWF4U2lkZUluZGV4O1xuICAgIHRoaXMuX3NpZGVTaXplID0gdGhpcy5fbWF4U2lkZUluZGV4ICsgMTtcbiAgICB0aGlzLl9hbHBoYVNpZGVTaXplID0gdGhpcy5fYWxwaGFNYXhTaWRlSW5kZXggKyAxO1xuICB9XG59O1xudmFyIFd1UXVhbnQgPSBfV3VRdWFudDtcbl9fcHVibGljRmllbGQoV3VRdWFudCwgXCJfYWxwaGFcIiwgMyk7XG5fX3B1YmxpY0ZpZWxkKFd1UXVhbnQsIFwiX3JlZFwiLCAyKTtcbl9fcHVibGljRmllbGQoV3VRdWFudCwgXCJfZ3JlZW5cIiwgMSk7XG5fX3B1YmxpY0ZpZWxkKFd1UXVhbnQsIFwiX2JsdWVcIiwgMCk7XG5cbi8vIHNyYy9pbWFnZS9pbmRleC50c1xudmFyIGltYWdlX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KGltYWdlX2V4cG9ydHMsIHtcbiAgQWJzdHJhY3RJbWFnZVF1YW50aXplcjogKCkgPT4gQWJzdHJhY3RJbWFnZVF1YW50aXplcixcbiAgRXJyb3JEaWZmdXNpb25BcnJheTogKCkgPT4gRXJyb3JEaWZmdXNpb25BcnJheSxcbiAgRXJyb3JEaWZmdXNpb25BcnJheUtlcm5lbDogKCkgPT4gRXJyb3JEaWZmdXNpb25BcnJheUtlcm5lbCxcbiAgRXJyb3JEaWZmdXNpb25SaWVtZXJzbWE6ICgpID0+IEVycm9yRGlmZnVzaW9uUmllbWVyc21hLFxuICBOZWFyZXN0Q29sb3I6ICgpID0+IE5lYXJlc3RDb2xvclxufSk7XG5cbi8vIHNyYy9pbWFnZS9pbWFnZVF1YW50aXplci50c1xudmFyIEFic3RyYWN0SW1hZ2VRdWFudGl6ZXIgPSBjbGFzcyB7XG4gIHF1YW50aXplU3luYyhwb2ludENvbnRhaW5lciwgcGFsZXR0ZSkge1xuICAgIGZvciAoY29uc3QgdmFsdWUgb2YgdGhpcy5xdWFudGl6ZShwb2ludENvbnRhaW5lciwgcGFsZXR0ZSkpIHtcbiAgICAgIGlmICh2YWx1ZS5wb2ludENvbnRhaW5lcikge1xuICAgICAgICByZXR1cm4gdmFsdWUucG9pbnRDb250YWluZXI7XG4gICAgICB9XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcInVucmVhY2hhYmxlXCIpO1xuICB9XG59O1xuXG4vLyBzcmMvaW1hZ2UvbmVhcmVzdENvbG9yLnRzXG52YXIgTmVhcmVzdENvbG9yID0gY2xhc3MgZXh0ZW5kcyBBYnN0cmFjdEltYWdlUXVhbnRpemVyIHtcbiAgY29uc3RydWN0b3IoY29sb3JEaXN0YW5jZUNhbGN1bGF0b3IpIHtcbiAgICBzdXBlcigpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJfZGlzdGFuY2VcIik7XG4gICAgdGhpcy5fZGlzdGFuY2UgPSBjb2xvckRpc3RhbmNlQ2FsY3VsYXRvcjtcbiAgfVxuICAqcXVhbnRpemUocG9pbnRDb250YWluZXIsIHBhbGV0dGUpIHtcbiAgICBjb25zdCBwb2ludEFycmF5ID0gcG9pbnRDb250YWluZXIuZ2V0UG9pbnRBcnJheSgpO1xuICAgIGNvbnN0IHdpZHRoID0gcG9pbnRDb250YWluZXIuZ2V0V2lkdGgoKTtcbiAgICBjb25zdCBoZWlnaHQgPSBwb2ludENvbnRhaW5lci5nZXRIZWlnaHQoKTtcbiAgICBjb25zdCB0cmFja2VyID0gbmV3IFByb2dyZXNzVHJhY2tlcihoZWlnaHQsIDk5KTtcbiAgICBmb3IgKGxldCB5MiA9IDA7IHkyIDwgaGVpZ2h0OyB5MisrKSB7XG4gICAgICBpZiAodHJhY2tlci5zaG91bGROb3RpZnkoeTIpKSB7XG4gICAgICAgIHlpZWxkIHtcbiAgICAgICAgICBwcm9ncmVzczogdHJhY2tlci5wcm9ncmVzc1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgZm9yIChsZXQgeDIgPSAwLCBpZHggPSB5MiAqIHdpZHRoOyB4MiA8IHdpZHRoOyB4MisrLCBpZHgrKykge1xuICAgICAgICBjb25zdCBwb2ludCA9IHBvaW50QXJyYXlbaWR4XTtcbiAgICAgICAgcG9pbnQuZnJvbShwYWxldHRlLmdldE5lYXJlc3RDb2xvcih0aGlzLl9kaXN0YW5jZSwgcG9pbnQpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgeWllbGQge1xuICAgICAgcG9pbnRDb250YWluZXIsXG4gICAgICBwcm9ncmVzczogMTAwXG4gICAgfTtcbiAgfVxufTtcblxuLy8gc3JjL2ltYWdlL2FycmF5LnRzXG52YXIgRXJyb3JEaWZmdXNpb25BcnJheUtlcm5lbCA9IC8qIEBfX1BVUkVfXyAqLyAoKEVycm9yRGlmZnVzaW9uQXJyYXlLZXJuZWwyKSA9PiB7XG4gIEVycm9yRGlmZnVzaW9uQXJyYXlLZXJuZWwyW0Vycm9yRGlmZnVzaW9uQXJyYXlLZXJuZWwyW1wiRmxveWRTdGVpbmJlcmdcIl0gPSAwXSA9IFwiRmxveWRTdGVpbmJlcmdcIjtcbiAgRXJyb3JEaWZmdXNpb25BcnJheUtlcm5lbDJbRXJyb3JEaWZmdXNpb25BcnJheUtlcm5lbDJbXCJGYWxzZUZsb3lkU3RlaW5iZXJnXCJdID0gMV0gPSBcIkZhbHNlRmxveWRTdGVpbmJlcmdcIjtcbiAgRXJyb3JEaWZmdXNpb25BcnJheUtlcm5lbDJbRXJyb3JEaWZmdXNpb25BcnJheUtlcm5lbDJbXCJTdHVja2lcIl0gPSAyXSA9IFwiU3R1Y2tpXCI7XG4gIEVycm9yRGlmZnVzaW9uQXJyYXlLZXJuZWwyW0Vycm9yRGlmZnVzaW9uQXJyYXlLZXJuZWwyW1wiQXRraW5zb25cIl0gPSAzXSA9IFwiQXRraW5zb25cIjtcbiAgRXJyb3JEaWZmdXNpb25BcnJheUtlcm5lbDJbRXJyb3JEaWZmdXNpb25BcnJheUtlcm5lbDJbXCJKYXJ2aXNcIl0gPSA0XSA9IFwiSmFydmlzXCI7XG4gIEVycm9yRGlmZnVzaW9uQXJyYXlLZXJuZWwyW0Vycm9yRGlmZnVzaW9uQXJyYXlLZXJuZWwyW1wiQnVya2VzXCJdID0gNV0gPSBcIkJ1cmtlc1wiO1xuICBFcnJvckRpZmZ1c2lvbkFycmF5S2VybmVsMltFcnJvckRpZmZ1c2lvbkFycmF5S2VybmVsMltcIlNpZXJyYVwiXSA9IDZdID0gXCJTaWVycmFcIjtcbiAgRXJyb3JEaWZmdXNpb25BcnJheUtlcm5lbDJbRXJyb3JEaWZmdXNpb25BcnJheUtlcm5lbDJbXCJUd29TaWVycmFcIl0gPSA3XSA9IFwiVHdvU2llcnJhXCI7XG4gIEVycm9yRGlmZnVzaW9uQXJyYXlLZXJuZWwyW0Vycm9yRGlmZnVzaW9uQXJyYXlLZXJuZWwyW1wiU2llcnJhTGl0ZVwiXSA9IDhdID0gXCJTaWVycmFMaXRlXCI7XG4gIHJldHVybiBFcnJvckRpZmZ1c2lvbkFycmF5S2VybmVsMjtcbn0pKEVycm9yRGlmZnVzaW9uQXJyYXlLZXJuZWwgfHwge30pO1xudmFyIEVycm9yRGlmZnVzaW9uQXJyYXkgPSBjbGFzcyBleHRlbmRzIEFic3RyYWN0SW1hZ2VRdWFudGl6ZXIge1xuICBjb25zdHJ1Y3Rvcihjb2xvckRpc3RhbmNlQ2FsY3VsYXRvciwga2VybmVsLCBzZXJwZW50aW5lID0gdHJ1ZSwgbWluaW11bUNvbG9yRGlzdGFuY2VUb0RpdGhlciA9IDAsIGNhbGN1bGF0ZUVycm9yTGlrZUdJTVAgPSBmYWxzZSkge1xuICAgIHN1cGVyKCk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIl9taW5Db2xvckRpc3RhbmNlXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJfc2VycGVudGluZVwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiX2tlcm5lbFwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiX2NhbGN1bGF0ZUVycm9yTGlrZUdJTVBcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIl9kaXN0YW5jZVwiKTtcbiAgICB0aGlzLl9zZXRLZXJuZWwoa2VybmVsKTtcbiAgICB0aGlzLl9kaXN0YW5jZSA9IGNvbG9yRGlzdGFuY2VDYWxjdWxhdG9yO1xuICAgIHRoaXMuX21pbkNvbG9yRGlzdGFuY2UgPSBtaW5pbXVtQ29sb3JEaXN0YW5jZVRvRGl0aGVyO1xuICAgIHRoaXMuX3NlcnBlbnRpbmUgPSBzZXJwZW50aW5lO1xuICAgIHRoaXMuX2NhbGN1bGF0ZUVycm9yTGlrZUdJTVAgPSBjYWxjdWxhdGVFcnJvckxpa2VHSU1QO1xuICB9XG4gICpxdWFudGl6ZShwb2ludENvbnRhaW5lciwgcGFsZXR0ZSkge1xuICAgIGNvbnN0IHBvaW50QXJyYXkgPSBwb2ludENvbnRhaW5lci5nZXRQb2ludEFycmF5KCk7XG4gICAgY29uc3Qgb3JpZ2luYWxQb2ludCA9IG5ldyBQb2ludCgpO1xuICAgIGNvbnN0IHdpZHRoID0gcG9pbnRDb250YWluZXIuZ2V0V2lkdGgoKTtcbiAgICBjb25zdCBoZWlnaHQgPSBwb2ludENvbnRhaW5lci5nZXRIZWlnaHQoKTtcbiAgICBjb25zdCBlcnJvckxpbmVzID0gW107XG4gICAgbGV0IGRpciA9IDE7XG4gICAgbGV0IG1heEVycm9yTGluZXMgPSAxO1xuICAgIGZvciAoY29uc3Qga2VybmVsIG9mIHRoaXMuX2tlcm5lbCkge1xuICAgICAgY29uc3Qga2VybmVsRXJyb3JMaW5lcyA9IGtlcm5lbFsyXSArIDE7XG4gICAgICBpZiAobWF4RXJyb3JMaW5lcyA8IGtlcm5lbEVycm9yTGluZXMpXG4gICAgICAgIG1heEVycm9yTGluZXMgPSBrZXJuZWxFcnJvckxpbmVzO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1heEVycm9yTGluZXM7IGkrKykge1xuICAgICAgdGhpcy5fZmlsbEVycm9yTGluZShlcnJvckxpbmVzW2ldID0gW10sIHdpZHRoKTtcbiAgICB9XG4gICAgY29uc3QgdHJhY2tlciA9IG5ldyBQcm9ncmVzc1RyYWNrZXIoaGVpZ2h0LCA5OSk7XG4gICAgZm9yIChsZXQgeTIgPSAwOyB5MiA8IGhlaWdodDsgeTIrKykge1xuICAgICAgaWYgKHRyYWNrZXIuc2hvdWxkTm90aWZ5KHkyKSkge1xuICAgICAgICB5aWVsZCB7XG4gICAgICAgICAgcHJvZ3Jlc3M6IHRyYWNrZXIucHJvZ3Jlc3NcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9zZXJwZW50aW5lKVxuICAgICAgICBkaXIgKj0gLTE7XG4gICAgICBjb25zdCBsbmkgPSB5MiAqIHdpZHRoO1xuICAgICAgY29uc3QgeFN0YXJ0ID0gZGlyID09PSAxID8gMCA6IHdpZHRoIC0gMTtcbiAgICAgIGNvbnN0IHhFbmQgPSBkaXIgPT09IDEgPyB3aWR0aCA6IC0xO1xuICAgICAgdGhpcy5fZmlsbEVycm9yTGluZShlcnJvckxpbmVzWzBdLCB3aWR0aCk7XG4gICAgICBlcnJvckxpbmVzLnB1c2goZXJyb3JMaW5lcy5zaGlmdCgpKTtcbiAgICAgIGNvbnN0IGVycm9yTGluZSA9IGVycm9yTGluZXNbMF07XG4gICAgICBmb3IgKGxldCB4MiA9IHhTdGFydCwgaWR4ID0gbG5pICsgeFN0YXJ0OyB4MiAhPT0geEVuZDsgeDIgKz0gZGlyLCBpZHggKz0gZGlyKSB7XG4gICAgICAgIGNvbnN0IHBvaW50ID0gcG9pbnRBcnJheVtpZHhdO1xuICAgICAgICBjb25zdCBlcnJvciA9IGVycm9yTGluZVt4Ml07XG4gICAgICAgIG9yaWdpbmFsUG9pbnQuZnJvbShwb2ludCk7XG4gICAgICAgIGNvbnN0IGNvcnJlY3RlZFBvaW50ID0gUG9pbnQuY3JlYXRlQnlSR0JBKGluUmFuZ2UwdG8yNTVSb3VuZGVkKHBvaW50LnIgKyBlcnJvclswXSksIGluUmFuZ2UwdG8yNTVSb3VuZGVkKHBvaW50LmcgKyBlcnJvclsxXSksIGluUmFuZ2UwdG8yNTVSb3VuZGVkKHBvaW50LmIgKyBlcnJvclsyXSksIGluUmFuZ2UwdG8yNTVSb3VuZGVkKHBvaW50LmEgKyBlcnJvclszXSkpO1xuICAgICAgICBjb25zdCBwYWxldHRlUG9pbnQgPSBwYWxldHRlLmdldE5lYXJlc3RDb2xvcih0aGlzLl9kaXN0YW5jZSwgY29ycmVjdGVkUG9pbnQpO1xuICAgICAgICBwb2ludC5mcm9tKHBhbGV0dGVQb2ludCk7XG4gICAgICAgIGlmICh0aGlzLl9taW5Db2xvckRpc3RhbmNlKSB7XG4gICAgICAgICAgY29uc3QgZGlzdCA9IHRoaXMuX2Rpc3RhbmNlLmNhbGN1bGF0ZU5vcm1hbGl6ZWQob3JpZ2luYWxQb2ludCwgcGFsZXR0ZVBvaW50KTtcbiAgICAgICAgICBpZiAoZGlzdCA8IHRoaXMuX21pbkNvbG9yRGlzdGFuY2UpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZXI7XG4gICAgICAgIGxldCBlZztcbiAgICAgICAgbGV0IGViO1xuICAgICAgICBsZXQgZWE7XG4gICAgICAgIGlmICh0aGlzLl9jYWxjdWxhdGVFcnJvckxpa2VHSU1QKSB7XG4gICAgICAgICAgZXIgPSBjb3JyZWN0ZWRQb2ludC5yIC0gcGFsZXR0ZVBvaW50LnI7XG4gICAgICAgICAgZWcgPSBjb3JyZWN0ZWRQb2ludC5nIC0gcGFsZXR0ZVBvaW50Lmc7XG4gICAgICAgICAgZWIgPSBjb3JyZWN0ZWRQb2ludC5iIC0gcGFsZXR0ZVBvaW50LmI7XG4gICAgICAgICAgZWEgPSBjb3JyZWN0ZWRQb2ludC5hIC0gcGFsZXR0ZVBvaW50LmE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZXIgPSBvcmlnaW5hbFBvaW50LnIgLSBwYWxldHRlUG9pbnQucjtcbiAgICAgICAgICBlZyA9IG9yaWdpbmFsUG9pbnQuZyAtIHBhbGV0dGVQb2ludC5nO1xuICAgICAgICAgIGViID0gb3JpZ2luYWxQb2ludC5iIC0gcGFsZXR0ZVBvaW50LmI7XG4gICAgICAgICAgZWEgPSBvcmlnaW5hbFBvaW50LmEgLSBwYWxldHRlUG9pbnQuYTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkU3RhcnQgPSBkaXIgPT09IDEgPyAwIDogdGhpcy5fa2VybmVsLmxlbmd0aCAtIDE7XG4gICAgICAgIGNvbnN0IGRFbmQgPSBkaXIgPT09IDEgPyB0aGlzLl9rZXJuZWwubGVuZ3RoIDogLTE7XG4gICAgICAgIGZvciAobGV0IGkgPSBkU3RhcnQ7IGkgIT09IGRFbmQ7IGkgKz0gZGlyKSB7XG4gICAgICAgICAgY29uc3QgeDEgPSB0aGlzLl9rZXJuZWxbaV1bMV0gKiBkaXI7XG4gICAgICAgICAgY29uc3QgeTEgPSB0aGlzLl9rZXJuZWxbaV1bMl07XG4gICAgICAgICAgaWYgKHgxICsgeDIgPj0gMCAmJiB4MSArIHgyIDwgd2lkdGggJiYgeTEgKyB5MiA+PSAwICYmIHkxICsgeTIgPCBoZWlnaHQpIHtcbiAgICAgICAgICAgIGNvbnN0IGQgPSB0aGlzLl9rZXJuZWxbaV1bMF07XG4gICAgICAgICAgICBjb25zdCBlID0gZXJyb3JMaW5lc1t5MV1beDEgKyB4Ml07XG4gICAgICAgICAgICBlWzBdICs9IGVyICogZDtcbiAgICAgICAgICAgIGVbMV0gKz0gZWcgKiBkO1xuICAgICAgICAgICAgZVsyXSArPSBlYiAqIGQ7XG4gICAgICAgICAgICBlWzNdICs9IGVhICogZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgeWllbGQge1xuICAgICAgcG9pbnRDb250YWluZXIsXG4gICAgICBwcm9ncmVzczogMTAwXG4gICAgfTtcbiAgfVxuICBfZmlsbEVycm9yTGluZShlcnJvckxpbmUsIHdpZHRoKSB7XG4gICAgaWYgKGVycm9yTGluZS5sZW5ndGggPiB3aWR0aCkge1xuICAgICAgZXJyb3JMaW5lLmxlbmd0aCA9IHdpZHRoO1xuICAgIH1cbiAgICBjb25zdCBsID0gZXJyb3JMaW5lLmxlbmd0aDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgY29uc3QgZXJyb3IgPSBlcnJvckxpbmVbaV07XG4gICAgICBlcnJvclswXSA9IGVycm9yWzFdID0gZXJyb3JbMl0gPSBlcnJvclszXSA9IDA7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSBsOyBpIDwgd2lkdGg7IGkrKykge1xuICAgICAgZXJyb3JMaW5lW2ldID0gWzAsIDAsIDAsIDBdO1xuICAgIH1cbiAgfVxuICBfc2V0S2VybmVsKGtlcm5lbCkge1xuICAgIHN3aXRjaCAoa2VybmVsKSB7XG4gICAgICBjYXNlIDAgLyogRmxveWRTdGVpbmJlcmcgKi86XG4gICAgICAgIHRoaXMuX2tlcm5lbCA9IFtcbiAgICAgICAgICBbNyAvIDE2LCAxLCAwXSxcbiAgICAgICAgICBbMyAvIDE2LCAtMSwgMV0sXG4gICAgICAgICAgWzUgLyAxNiwgMCwgMV0sXG4gICAgICAgICAgWzEgLyAxNiwgMSwgMV1cbiAgICAgICAgXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDEgLyogRmFsc2VGbG95ZFN0ZWluYmVyZyAqLzpcbiAgICAgICAgdGhpcy5fa2VybmVsID0gW1xuICAgICAgICAgIFszIC8gOCwgMSwgMF0sXG4gICAgICAgICAgWzMgLyA4LCAwLCAxXSxcbiAgICAgICAgICBbMiAvIDgsIDEsIDFdXG4gICAgICAgIF07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyIC8qIFN0dWNraSAqLzpcbiAgICAgICAgdGhpcy5fa2VybmVsID0gW1xuICAgICAgICAgIFs4IC8gNDIsIDEsIDBdLFxuICAgICAgICAgIFs0IC8gNDIsIDIsIDBdLFxuICAgICAgICAgIFsyIC8gNDIsIC0yLCAxXSxcbiAgICAgICAgICBbNCAvIDQyLCAtMSwgMV0sXG4gICAgICAgICAgWzggLyA0MiwgMCwgMV0sXG4gICAgICAgICAgWzQgLyA0MiwgMSwgMV0sXG4gICAgICAgICAgWzIgLyA0MiwgMiwgMV0sXG4gICAgICAgICAgWzEgLyA0MiwgLTIsIDJdLFxuICAgICAgICAgIFsyIC8gNDIsIC0xLCAyXSxcbiAgICAgICAgICBbNCAvIDQyLCAwLCAyXSxcbiAgICAgICAgICBbMiAvIDQyLCAxLCAyXSxcbiAgICAgICAgICBbMSAvIDQyLCAyLCAyXVxuICAgICAgICBdO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMyAvKiBBdGtpbnNvbiAqLzpcbiAgICAgICAgdGhpcy5fa2VybmVsID0gW1xuICAgICAgICAgIFsxIC8gOCwgMSwgMF0sXG4gICAgICAgICAgWzEgLyA4LCAyLCAwXSxcbiAgICAgICAgICBbMSAvIDgsIC0xLCAxXSxcbiAgICAgICAgICBbMSAvIDgsIDAsIDFdLFxuICAgICAgICAgIFsxIC8gOCwgMSwgMV0sXG4gICAgICAgICAgWzEgLyA4LCAwLCAyXVxuICAgICAgICBdO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgNCAvKiBKYXJ2aXMgKi86XG4gICAgICAgIHRoaXMuX2tlcm5lbCA9IFtcbiAgICAgICAgICBbNyAvIDQ4LCAxLCAwXSxcbiAgICAgICAgICBbNSAvIDQ4LCAyLCAwXSxcbiAgICAgICAgICBbMyAvIDQ4LCAtMiwgMV0sXG4gICAgICAgICAgWzUgLyA0OCwgLTEsIDFdLFxuICAgICAgICAgIFs3IC8gNDgsIDAsIDFdLFxuICAgICAgICAgIFs1IC8gNDgsIDEsIDFdLFxuICAgICAgICAgIFszIC8gNDgsIDIsIDFdLFxuICAgICAgICAgIFsxIC8gNDgsIC0yLCAyXSxcbiAgICAgICAgICBbMyAvIDQ4LCAtMSwgMl0sXG4gICAgICAgICAgWzUgLyA0OCwgMCwgMl0sXG4gICAgICAgICAgWzMgLyA0OCwgMSwgMl0sXG4gICAgICAgICAgWzEgLyA0OCwgMiwgMl1cbiAgICAgICAgXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDUgLyogQnVya2VzICovOlxuICAgICAgICB0aGlzLl9rZXJuZWwgPSBbXG4gICAgICAgICAgWzggLyAzMiwgMSwgMF0sXG4gICAgICAgICAgWzQgLyAzMiwgMiwgMF0sXG4gICAgICAgICAgWzIgLyAzMiwgLTIsIDFdLFxuICAgICAgICAgIFs0IC8gMzIsIC0xLCAxXSxcbiAgICAgICAgICBbOCAvIDMyLCAwLCAxXSxcbiAgICAgICAgICBbNCAvIDMyLCAxLCAxXSxcbiAgICAgICAgICBbMiAvIDMyLCAyLCAxXVxuICAgICAgICBdO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgNiAvKiBTaWVycmEgKi86XG4gICAgICAgIHRoaXMuX2tlcm5lbCA9IFtcbiAgICAgICAgICBbNSAvIDMyLCAxLCAwXSxcbiAgICAgICAgICBbMyAvIDMyLCAyLCAwXSxcbiAgICAgICAgICBbMiAvIDMyLCAtMiwgMV0sXG4gICAgICAgICAgWzQgLyAzMiwgLTEsIDFdLFxuICAgICAgICAgIFs1IC8gMzIsIDAsIDFdLFxuICAgICAgICAgIFs0IC8gMzIsIDEsIDFdLFxuICAgICAgICAgIFsyIC8gMzIsIDIsIDFdLFxuICAgICAgICAgIFsyIC8gMzIsIC0xLCAyXSxcbiAgICAgICAgICBbMyAvIDMyLCAwLCAyXSxcbiAgICAgICAgICBbMiAvIDMyLCAxLCAyXVxuICAgICAgICBdO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgNyAvKiBUd29TaWVycmEgKi86XG4gICAgICAgIHRoaXMuX2tlcm5lbCA9IFtcbiAgICAgICAgICBbNCAvIDE2LCAxLCAwXSxcbiAgICAgICAgICBbMyAvIDE2LCAyLCAwXSxcbiAgICAgICAgICBbMSAvIDE2LCAtMiwgMV0sXG4gICAgICAgICAgWzIgLyAxNiwgLTEsIDFdLFxuICAgICAgICAgIFszIC8gMTYsIDAsIDFdLFxuICAgICAgICAgIFsyIC8gMTYsIDEsIDFdLFxuICAgICAgICAgIFsxIC8gMTYsIDIsIDFdXG4gICAgICAgIF07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA4IC8qIFNpZXJyYUxpdGUgKi86XG4gICAgICAgIHRoaXMuX2tlcm5lbCA9IFtcbiAgICAgICAgICBbMiAvIDQsIDEsIDBdLFxuICAgICAgICAgIFsxIC8gNCwgLTEsIDFdLFxuICAgICAgICAgIFsxIC8gNCwgMCwgMV1cbiAgICAgICAgXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yRGlmZnVzaW9uQXJyYXk6IHVua25vd24ga2VybmVsID0gJHtrZXJuZWx9YCk7XG4gICAgfVxuICB9XG59O1xuXG4vLyBzcmMvaW1hZ2Uvc3BhY2VGaWxsaW5nQ3VydmVzL2hpbGJlcnRDdXJ2ZS50c1xuZnVuY3Rpb24qIGhpbGJlcnRDdXJ2ZSh3aWR0aCwgaGVpZ2h0LCBjYWxsYmFjaykge1xuICBjb25zdCBtYXhCb3VuZCA9IE1hdGgubWF4KHdpZHRoLCBoZWlnaHQpO1xuICBjb25zdCBsZXZlbCA9IE1hdGguZmxvb3IoTWF0aC5sb2cobWF4Qm91bmQpIC8gTWF0aC5sb2coMikgKyAxKTtcbiAgY29uc3QgdHJhY2tlciA9IG5ldyBQcm9ncmVzc1RyYWNrZXIod2lkdGggKiBoZWlnaHQsIDk5KTtcbiAgY29uc3QgZGF0YSA9IHtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgbGV2ZWwsXG4gICAgY2FsbGJhY2ssXG4gICAgdHJhY2tlcixcbiAgICBpbmRleDogMCxcbiAgICB4OiAwLFxuICAgIHk6IDBcbiAgfTtcbiAgeWllbGQqIHdhbGtIaWxiZXJ0KGRhdGEsIDEgLyogVVAgKi8pO1xuICB2aXNpdChkYXRhLCAwIC8qIE5PTkUgKi8pO1xufVxuZnVuY3Rpb24qIHdhbGtIaWxiZXJ0KGRhdGEsIGRpcmVjdGlvbikge1xuICBpZiAoZGF0YS5sZXZlbCA8IDEpXG4gICAgcmV0dXJuO1xuICBpZiAoZGF0YS50cmFja2VyLnNob3VsZE5vdGlmeShkYXRhLmluZGV4KSkge1xuICAgIHlpZWxkIHsgcHJvZ3Jlc3M6IGRhdGEudHJhY2tlci5wcm9ncmVzcyB9O1xuICB9XG4gIGRhdGEubGV2ZWwtLTtcbiAgc3dpdGNoIChkaXJlY3Rpb24pIHtcbiAgICBjYXNlIDIgLyogTEVGVCAqLzpcbiAgICAgIHlpZWxkKiB3YWxrSGlsYmVydChkYXRhLCAxIC8qIFVQICovKTtcbiAgICAgIHZpc2l0KGRhdGEsIDMgLyogUklHSFQgKi8pO1xuICAgICAgeWllbGQqIHdhbGtIaWxiZXJ0KGRhdGEsIDIgLyogTEVGVCAqLyk7XG4gICAgICB2aXNpdChkYXRhLCA0IC8qIERPV04gKi8pO1xuICAgICAgeWllbGQqIHdhbGtIaWxiZXJ0KGRhdGEsIDIgLyogTEVGVCAqLyk7XG4gICAgICB2aXNpdChkYXRhLCAyIC8qIExFRlQgKi8pO1xuICAgICAgeWllbGQqIHdhbGtIaWxiZXJ0KGRhdGEsIDQgLyogRE9XTiAqLyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDMgLyogUklHSFQgKi86XG4gICAgICB5aWVsZCogd2Fsa0hpbGJlcnQoZGF0YSwgNCAvKiBET1dOICovKTtcbiAgICAgIHZpc2l0KGRhdGEsIDIgLyogTEVGVCAqLyk7XG4gICAgICB5aWVsZCogd2Fsa0hpbGJlcnQoZGF0YSwgMyAvKiBSSUdIVCAqLyk7XG4gICAgICB2aXNpdChkYXRhLCAxIC8qIFVQICovKTtcbiAgICAgIHlpZWxkKiB3YWxrSGlsYmVydChkYXRhLCAzIC8qIFJJR0hUICovKTtcbiAgICAgIHZpc2l0KGRhdGEsIDMgLyogUklHSFQgKi8pO1xuICAgICAgeWllbGQqIHdhbGtIaWxiZXJ0KGRhdGEsIDEgLyogVVAgKi8pO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAxIC8qIFVQICovOlxuICAgICAgeWllbGQqIHdhbGtIaWxiZXJ0KGRhdGEsIDIgLyogTEVGVCAqLyk7XG4gICAgICB2aXNpdChkYXRhLCA0IC8qIERPV04gKi8pO1xuICAgICAgeWllbGQqIHdhbGtIaWxiZXJ0KGRhdGEsIDEgLyogVVAgKi8pO1xuICAgICAgdmlzaXQoZGF0YSwgMyAvKiBSSUdIVCAqLyk7XG4gICAgICB5aWVsZCogd2Fsa0hpbGJlcnQoZGF0YSwgMSAvKiBVUCAqLyk7XG4gICAgICB2aXNpdChkYXRhLCAxIC8qIFVQICovKTtcbiAgICAgIHlpZWxkKiB3YWxrSGlsYmVydChkYXRhLCAzIC8qIFJJR0hUICovKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgNCAvKiBET1dOICovOlxuICAgICAgeWllbGQqIHdhbGtIaWxiZXJ0KGRhdGEsIDMgLyogUklHSFQgKi8pO1xuICAgICAgdmlzaXQoZGF0YSwgMSAvKiBVUCAqLyk7XG4gICAgICB5aWVsZCogd2Fsa0hpbGJlcnQoZGF0YSwgNCAvKiBET1dOICovKTtcbiAgICAgIHZpc2l0KGRhdGEsIDIgLyogTEVGVCAqLyk7XG4gICAgICB5aWVsZCogd2Fsa0hpbGJlcnQoZGF0YSwgNCAvKiBET1dOICovKTtcbiAgICAgIHZpc2l0KGRhdGEsIDQgLyogRE9XTiAqLyk7XG4gICAgICB5aWVsZCogd2Fsa0hpbGJlcnQoZGF0YSwgMiAvKiBMRUZUICovKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBicmVhaztcbiAgfVxuICBkYXRhLmxldmVsKys7XG59XG5mdW5jdGlvbiB2aXNpdChkYXRhLCBkaXJlY3Rpb24pIHtcbiAgaWYgKGRhdGEueCA+PSAwICYmIGRhdGEueCA8IGRhdGEud2lkdGggJiYgZGF0YS55ID49IDAgJiYgZGF0YS55IDwgZGF0YS5oZWlnaHQpIHtcbiAgICBkYXRhLmNhbGxiYWNrKGRhdGEueCwgZGF0YS55KTtcbiAgICBkYXRhLmluZGV4Kys7XG4gIH1cbiAgc3dpdGNoIChkaXJlY3Rpb24pIHtcbiAgICBjYXNlIDIgLyogTEVGVCAqLzpcbiAgICAgIGRhdGEueC0tO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAzIC8qIFJJR0hUICovOlxuICAgICAgZGF0YS54Kys7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDEgLyogVVAgKi86XG4gICAgICBkYXRhLnktLTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgNCAvKiBET1dOICovOlxuICAgICAgZGF0YS55Kys7XG4gICAgICBicmVhaztcbiAgfVxufVxuXG4vLyBzcmMvaW1hZ2UvcmllbWVyc21hLnRzXG52YXIgRXJyb3JEaWZmdXNpb25SaWVtZXJzbWEgPSBjbGFzcyBleHRlbmRzIEFic3RyYWN0SW1hZ2VRdWFudGl6ZXIge1xuICBjb25zdHJ1Y3Rvcihjb2xvckRpc3RhbmNlQ2FsY3VsYXRvciwgZXJyb3JRdWV1ZVNpemUgPSAxNiwgZXJyb3JQcm9wYWdhdGlvbiA9IDEpIHtcbiAgICBzdXBlcigpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJfZGlzdGFuY2VcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIl93ZWlnaHRzXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJfZXJyb3JRdWV1ZVNpemVcIik7XG4gICAgdGhpcy5fZGlzdGFuY2UgPSBjb2xvckRpc3RhbmNlQ2FsY3VsYXRvcjtcbiAgICB0aGlzLl9lcnJvclF1ZXVlU2l6ZSA9IGVycm9yUXVldWVTaXplO1xuICAgIHRoaXMuX3dlaWdodHMgPSBFcnJvckRpZmZ1c2lvblJpZW1lcnNtYS5fY3JlYXRlV2VpZ2h0cyhlcnJvclByb3BhZ2F0aW9uLCBlcnJvclF1ZXVlU2l6ZSk7XG4gIH1cbiAgKnF1YW50aXplKHBvaW50Q29udGFpbmVyLCBwYWxldHRlKSB7XG4gICAgY29uc3QgcG9pbnRBcnJheSA9IHBvaW50Q29udGFpbmVyLmdldFBvaW50QXJyYXkoKTtcbiAgICBjb25zdCB3aWR0aCA9IHBvaW50Q29udGFpbmVyLmdldFdpZHRoKCk7XG4gICAgY29uc3QgaGVpZ2h0ID0gcG9pbnRDb250YWluZXIuZ2V0SGVpZ2h0KCk7XG4gICAgY29uc3QgZXJyb3JRdWV1ZSA9IFtdO1xuICAgIGxldCBoZWFkID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2Vycm9yUXVldWVTaXplOyBpKyspIHtcbiAgICAgIGVycm9yUXVldWVbaV0gPSB7IHI6IDAsIGc6IDAsIGI6IDAsIGE6IDAgfTtcbiAgICB9XG4gICAgeWllbGQqIGhpbGJlcnRDdXJ2ZSh3aWR0aCwgaGVpZ2h0LCAoeDIsIHkyKSA9PiB7XG4gICAgICBjb25zdCBwID0gcG9pbnRBcnJheVt4MiArIHkyICogd2lkdGhdO1xuICAgICAgbGV0IHsgciwgZywgYiwgYSB9ID0gcDtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fZXJyb3JRdWV1ZVNpemU7IGkrKykge1xuICAgICAgICBjb25zdCB3ZWlnaHQgPSB0aGlzLl93ZWlnaHRzW2ldO1xuICAgICAgICBjb25zdCBlID0gZXJyb3JRdWV1ZVsoaSArIGhlYWQpICUgdGhpcy5fZXJyb3JRdWV1ZVNpemVdO1xuICAgICAgICByICs9IGUuciAqIHdlaWdodDtcbiAgICAgICAgZyArPSBlLmcgKiB3ZWlnaHQ7XG4gICAgICAgIGIgKz0gZS5iICogd2VpZ2h0O1xuICAgICAgICBhICs9IGUuYSAqIHdlaWdodDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNvcnJlY3RlZFBvaW50ID0gUG9pbnQuY3JlYXRlQnlSR0JBKGluUmFuZ2UwdG8yNTVSb3VuZGVkKHIpLCBpblJhbmdlMHRvMjU1Um91bmRlZChnKSwgaW5SYW5nZTB0bzI1NVJvdW5kZWQoYiksIGluUmFuZ2UwdG8yNTVSb3VuZGVkKGEpKTtcbiAgICAgIGNvbnN0IHF1YW50aXplZFBvaW50ID0gcGFsZXR0ZS5nZXROZWFyZXN0Q29sb3IodGhpcy5fZGlzdGFuY2UsIGNvcnJlY3RlZFBvaW50KTtcbiAgICAgIGhlYWQgPSAoaGVhZCArIDEpICUgdGhpcy5fZXJyb3JRdWV1ZVNpemU7XG4gICAgICBjb25zdCB0YWlsID0gKGhlYWQgKyB0aGlzLl9lcnJvclF1ZXVlU2l6ZSAtIDEpICUgdGhpcy5fZXJyb3JRdWV1ZVNpemU7XG4gICAgICBlcnJvclF1ZXVlW3RhaWxdLnIgPSBwLnIgLSBxdWFudGl6ZWRQb2ludC5yO1xuICAgICAgZXJyb3JRdWV1ZVt0YWlsXS5nID0gcC5nIC0gcXVhbnRpemVkUG9pbnQuZztcbiAgICAgIGVycm9yUXVldWVbdGFpbF0uYiA9IHAuYiAtIHF1YW50aXplZFBvaW50LmI7XG4gICAgICBlcnJvclF1ZXVlW3RhaWxdLmEgPSBwLmEgLSBxdWFudGl6ZWRQb2ludC5hO1xuICAgICAgcC5mcm9tKHF1YW50aXplZFBvaW50KTtcbiAgICB9KTtcbiAgICB5aWVsZCB7XG4gICAgICBwb2ludENvbnRhaW5lcixcbiAgICAgIHByb2dyZXNzOiAxMDBcbiAgICB9O1xuICB9XG4gIHN0YXRpYyBfY3JlYXRlV2VpZ2h0cyhlcnJvclByb3BhZ2F0aW9uLCBlcnJvclF1ZXVlU2l6ZSkge1xuICAgIGNvbnN0IHdlaWdodHMgPSBbXTtcbiAgICBjb25zdCBtdWx0aXBsaWVyID0gTWF0aC5leHAoTWF0aC5sb2coZXJyb3JRdWV1ZVNpemUpIC8gKGVycm9yUXVldWVTaXplIC0gMSkpO1xuICAgIGZvciAobGV0IGkgPSAwLCBuZXh0ID0gMTsgaSA8IGVycm9yUXVldWVTaXplOyBpKyspIHtcbiAgICAgIHdlaWdodHNbaV0gPSAobmV4dCArIDAuNSB8IDApIC8gZXJyb3JRdWV1ZVNpemUgKiBlcnJvclByb3BhZ2F0aW9uO1xuICAgICAgbmV4dCAqPSBtdWx0aXBsaWVyO1xuICAgIH1cbiAgICByZXR1cm4gd2VpZ2h0cztcbiAgfVxufTtcblxuLy8gc3JjL3F1YWxpdHkvaW5kZXgudHNcbnZhciBxdWFsaXR5X2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KHF1YWxpdHlfZXhwb3J0cywge1xuICBzc2ltOiAoKSA9PiBzc2ltXG59KTtcblxuLy8gc3JjL3F1YWxpdHkvc3NpbS50c1xudmFyIEsxID0gMC4wMTtcbnZhciBLMiA9IDAuMDM7XG5mdW5jdGlvbiBzc2ltKGltYWdlMSwgaW1hZ2UyKSB7XG4gIGlmIChpbWFnZTEuZ2V0SGVpZ2h0KCkgIT09IGltYWdlMi5nZXRIZWlnaHQoKSB8fCBpbWFnZTEuZ2V0V2lkdGgoKSAhPT0gaW1hZ2UyLmdldFdpZHRoKCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbWFnZXMgaGF2ZSBkaWZmZXJlbnQgc2l6ZXMhXCIpO1xuICB9XG4gIGNvbnN0IGJpdHNQZXJDb21wb25lbnQgPSA4O1xuICBjb25zdCBMID0gKDEgPDwgYml0c1BlckNvbXBvbmVudCkgLSAxO1xuICBjb25zdCBjMSA9IChLMSAqIEwpICoqIDI7XG4gIGNvbnN0IGMyID0gKEsyICogTCkgKiogMjtcbiAgbGV0IG51bVdpbmRvd3MgPSAwO1xuICBsZXQgbXNzaW0gPSAwO1xuICBpdGVyYXRlKGltYWdlMSwgaW1hZ2UyLCAobHVtYVZhbHVlczEsIGx1bWFWYWx1ZXMyLCBhdmVyYWdlTHVtYVZhbHVlMSwgYXZlcmFnZUx1bWFWYWx1ZTIpID0+IHtcbiAgICBsZXQgc2lneHkgPSAwO1xuICAgIGxldCBzaWdzcXggPSAwO1xuICAgIGxldCBzaWdzcXkgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbHVtYVZhbHVlczEubGVuZ3RoOyBpKyspIHtcbiAgICAgIHNpZ3NxeCArPSAobHVtYVZhbHVlczFbaV0gLSBhdmVyYWdlTHVtYVZhbHVlMSkgKiogMjtcbiAgICAgIHNpZ3NxeSArPSAobHVtYVZhbHVlczJbaV0gLSBhdmVyYWdlTHVtYVZhbHVlMikgKiogMjtcbiAgICAgIHNpZ3h5ICs9IChsdW1hVmFsdWVzMVtpXSAtIGF2ZXJhZ2VMdW1hVmFsdWUxKSAqIChsdW1hVmFsdWVzMltpXSAtIGF2ZXJhZ2VMdW1hVmFsdWUyKTtcbiAgICB9XG4gICAgY29uc3QgbnVtUGl4ZWxzSW5XaW4gPSBsdW1hVmFsdWVzMS5sZW5ndGggLSAxO1xuICAgIHNpZ3NxeCAvPSBudW1QaXhlbHNJbldpbjtcbiAgICBzaWdzcXkgLz0gbnVtUGl4ZWxzSW5XaW47XG4gICAgc2lneHkgLz0gbnVtUGl4ZWxzSW5XaW47XG4gICAgY29uc3QgbnVtZXJhdG9yID0gKDIgKiBhdmVyYWdlTHVtYVZhbHVlMSAqIGF2ZXJhZ2VMdW1hVmFsdWUyICsgYzEpICogKDIgKiBzaWd4eSArIGMyKTtcbiAgICBjb25zdCBkZW5vbWluYXRvciA9IChhdmVyYWdlTHVtYVZhbHVlMSAqKiAyICsgYXZlcmFnZUx1bWFWYWx1ZTIgKiogMiArIGMxKSAqIChzaWdzcXggKyBzaWdzcXkgKyBjMik7XG4gICAgY29uc3Qgc3NpbTIgPSBudW1lcmF0b3IgLyBkZW5vbWluYXRvcjtcbiAgICBtc3NpbSArPSBzc2ltMjtcbiAgICBudW1XaW5kb3dzKys7XG4gIH0pO1xuICByZXR1cm4gbXNzaW0gLyBudW1XaW5kb3dzO1xufVxuZnVuY3Rpb24gaXRlcmF0ZShpbWFnZTEsIGltYWdlMiwgY2FsbGJhY2spIHtcbiAgY29uc3Qgd2luZG93U2l6ZSA9IDg7XG4gIGNvbnN0IHdpZHRoID0gaW1hZ2UxLmdldFdpZHRoKCk7XG4gIGNvbnN0IGhlaWdodCA9IGltYWdlMS5nZXRIZWlnaHQoKTtcbiAgZm9yIChsZXQgeTIgPSAwOyB5MiA8IGhlaWdodDsgeTIgKz0gd2luZG93U2l6ZSkge1xuICAgIGZvciAobGV0IHgyID0gMDsgeDIgPCB3aWR0aDsgeDIgKz0gd2luZG93U2l6ZSkge1xuICAgICAgY29uc3Qgd2luZG93V2lkdGggPSBNYXRoLm1pbih3aW5kb3dTaXplLCB3aWR0aCAtIHgyKTtcbiAgICAgIGNvbnN0IHdpbmRvd0hlaWdodCA9IE1hdGgubWluKHdpbmRvd1NpemUsIGhlaWdodCAtIHkyKTtcbiAgICAgIGNvbnN0IGx1bWFWYWx1ZXMxID0gY2FsY3VsYXRlTHVtYVZhbHVlc0ZvcldpbmRvdyhpbWFnZTEsIHgyLCB5Miwgd2luZG93V2lkdGgsIHdpbmRvd0hlaWdodCk7XG4gICAgICBjb25zdCBsdW1hVmFsdWVzMiA9IGNhbGN1bGF0ZUx1bWFWYWx1ZXNGb3JXaW5kb3coaW1hZ2UyLCB4MiwgeTIsIHdpbmRvd1dpZHRoLCB3aW5kb3dIZWlnaHQpO1xuICAgICAgY29uc3QgYXZlcmFnZUx1bWExID0gY2FsY3VsYXRlQXZlcmFnZUx1bWEobHVtYVZhbHVlczEpO1xuICAgICAgY29uc3QgYXZlcmFnZUx1bWEyID0gY2FsY3VsYXRlQXZlcmFnZUx1bWEobHVtYVZhbHVlczIpO1xuICAgICAgY2FsbGJhY2sobHVtYVZhbHVlczEsIGx1bWFWYWx1ZXMyLCBhdmVyYWdlTHVtYTEsIGF2ZXJhZ2VMdW1hMik7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVMdW1hVmFsdWVzRm9yV2luZG93KGltYWdlLCB4MiwgeTIsIHdpZHRoLCBoZWlnaHQpIHtcbiAgY29uc3QgcG9pbnRBcnJheSA9IGltYWdlLmdldFBvaW50QXJyYXkoKTtcbiAgY29uc3QgbHVtYVZhbHVlcyA9IFtdO1xuICBsZXQgY291bnRlciA9IDA7XG4gIGZvciAobGV0IGogPSB5MjsgaiA8IHkyICsgaGVpZ2h0OyBqKyspIHtcbiAgICBjb25zdCBvZmZzZXQgPSBqICogaW1hZ2UuZ2V0V2lkdGgoKTtcbiAgICBmb3IgKGxldCBpID0geDI7IGkgPCB4MiArIHdpZHRoOyBpKyspIHtcbiAgICAgIGNvbnN0IHBvaW50ID0gcG9pbnRBcnJheVtvZmZzZXQgKyBpXTtcbiAgICAgIGx1bWFWYWx1ZXNbY291bnRlcl0gPSBwb2ludC5yICogMC4yMTI2IC8qIFJFRCAqLyArIHBvaW50LmcgKiAwLjcxNTIgLyogR1JFRU4gKi8gKyBwb2ludC5iICogMC4wNzIyIC8qIEJMVUUgKi87XG4gICAgICBjb3VudGVyKys7XG4gICAgfVxuICB9XG4gIHJldHVybiBsdW1hVmFsdWVzO1xufVxuZnVuY3Rpb24gY2FsY3VsYXRlQXZlcmFnZUx1bWEobHVtYVZhbHVlcykge1xuICBsZXQgc3VtTHVtYSA9IDA7XG4gIGZvciAoY29uc3QgbHVtYSBvZiBsdW1hVmFsdWVzKSB7XG4gICAgc3VtTHVtYSArPSBsdW1hO1xuICB9XG4gIHJldHVybiBzdW1MdW1hIC8gbHVtYVZhbHVlcy5sZW5ndGg7XG59XG5cbi8vIHNyYy9iYXNpY0FQSS50c1xudmFyIHNldEltbWVkaWF0ZUltcGwgPSB0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSBcImZ1bmN0aW9uXCIgPyBzZXRJbW1lZGlhdGUgOiB0eXBlb2YgcHJvY2VzcyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgKHByb2Nlc3MgPT0gbnVsbCA/IHZvaWQgMCA6IHByb2Nlc3MubmV4dFRpY2spID09PSBcImZ1bmN0aW9uXCIgPyAoY2FsbGJhY2spID0+IHByb2Nlc3MubmV4dFRpY2soY2FsbGJhY2spIDogKGNhbGxiYWNrKSA9PiBzZXRUaW1lb3V0KGNhbGxiYWNrLCAwKTtcbmZ1bmN0aW9uIGJ1aWxkUGFsZXR0ZVN5bmMoaW1hZ2VzLCB7XG4gIGNvbG9yRGlzdGFuY2VGb3JtdWxhLFxuICBwYWxldHRlUXVhbnRpemF0aW9uLFxuICBjb2xvcnNcbn0gPSB7fSkge1xuICBjb25zdCBkaXN0YW5jZUNhbGN1bGF0b3IgPSBjb2xvckRpc3RhbmNlRm9ybXVsYVRvQ29sb3JEaXN0YW5jZShjb2xvckRpc3RhbmNlRm9ybXVsYSk7XG4gIGNvbnN0IHBhbGV0dGVRdWFudGl6ZXIgPSBwYWxldHRlUXVhbnRpemF0aW9uVG9QYWxldHRlUXVhbnRpemVyKGRpc3RhbmNlQ2FsY3VsYXRvciwgcGFsZXR0ZVF1YW50aXphdGlvbiwgY29sb3JzKTtcbiAgaW1hZ2VzLmZvckVhY2goKGltYWdlKSA9PiBwYWxldHRlUXVhbnRpemVyLnNhbXBsZShpbWFnZSkpO1xuICByZXR1cm4gcGFsZXR0ZVF1YW50aXplci5xdWFudGl6ZVN5bmMoKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGJ1aWxkUGFsZXR0ZShpbWFnZXMsIHtcbiAgY29sb3JEaXN0YW5jZUZvcm11bGEsXG4gIHBhbGV0dGVRdWFudGl6YXRpb24sXG4gIGNvbG9ycyxcbiAgb25Qcm9ncmVzc1xufSA9IHt9KSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgY29uc3QgZGlzdGFuY2VDYWxjdWxhdG9yID0gY29sb3JEaXN0YW5jZUZvcm11bGFUb0NvbG9yRGlzdGFuY2UoY29sb3JEaXN0YW5jZUZvcm11bGEpO1xuICAgIGNvbnN0IHBhbGV0dGVRdWFudGl6ZXIgPSBwYWxldHRlUXVhbnRpemF0aW9uVG9QYWxldHRlUXVhbnRpemVyKGRpc3RhbmNlQ2FsY3VsYXRvciwgcGFsZXR0ZVF1YW50aXphdGlvbiwgY29sb3JzKTtcbiAgICBpbWFnZXMuZm9yRWFjaCgoaW1hZ2UpID0+IHBhbGV0dGVRdWFudGl6ZXIuc2FtcGxlKGltYWdlKSk7XG4gICAgbGV0IHBhbGV0dGU7XG4gICAgY29uc3QgaXRlcmF0b3IgPSBwYWxldHRlUXVhbnRpemVyLnF1YW50aXplKCk7XG4gICAgY29uc3QgbmV4dCA9ICgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgaWYgKHJlc3VsdC5kb25lKSB7XG4gICAgICAgICAgcmVzb2x2ZShwYWxldHRlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAocmVzdWx0LnZhbHVlLnBhbGV0dGUpXG4gICAgICAgICAgICBwYWxldHRlID0gcmVzdWx0LnZhbHVlLnBhbGV0dGU7XG4gICAgICAgICAgaWYgKG9uUHJvZ3Jlc3MpXG4gICAgICAgICAgICBvblByb2dyZXNzKHJlc3VsdC52YWx1ZS5wcm9ncmVzcyk7XG4gICAgICAgICAgc2V0SW1tZWRpYXRlSW1wbChuZXh0KTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHNldEltbWVkaWF0ZUltcGwobmV4dCk7XG4gIH0pO1xufVxuZnVuY3Rpb24gYXBwbHlQYWxldHRlU3luYyhpbWFnZSwgcGFsZXR0ZSwgeyBjb2xvckRpc3RhbmNlRm9ybXVsYSwgaW1hZ2VRdWFudGl6YXRpb24gfSA9IHt9KSB7XG4gIGNvbnN0IGRpc3RhbmNlQ2FsY3VsYXRvciA9IGNvbG9yRGlzdGFuY2VGb3JtdWxhVG9Db2xvckRpc3RhbmNlKGNvbG9yRGlzdGFuY2VGb3JtdWxhKTtcbiAgY29uc3QgaW1hZ2VRdWFudGl6ZXIgPSBpbWFnZVF1YW50aXphdGlvblRvSW1hZ2VRdWFudGl6ZXIoZGlzdGFuY2VDYWxjdWxhdG9yLCBpbWFnZVF1YW50aXphdGlvbik7XG4gIHJldHVybiBpbWFnZVF1YW50aXplci5xdWFudGl6ZVN5bmMoaW1hZ2UsIHBhbGV0dGUpO1xufVxuYXN5bmMgZnVuY3Rpb24gYXBwbHlQYWxldHRlKGltYWdlLCBwYWxldHRlLCB7XG4gIGNvbG9yRGlzdGFuY2VGb3JtdWxhLFxuICBpbWFnZVF1YW50aXphdGlvbixcbiAgb25Qcm9ncmVzc1xufSA9IHt9KSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgY29uc3QgZGlzdGFuY2VDYWxjdWxhdG9yID0gY29sb3JEaXN0YW5jZUZvcm11bGFUb0NvbG9yRGlzdGFuY2UoY29sb3JEaXN0YW5jZUZvcm11bGEpO1xuICAgIGNvbnN0IGltYWdlUXVhbnRpemVyID0gaW1hZ2VRdWFudGl6YXRpb25Ub0ltYWdlUXVhbnRpemVyKGRpc3RhbmNlQ2FsY3VsYXRvciwgaW1hZ2VRdWFudGl6YXRpb24pO1xuICAgIGxldCBvdXRQb2ludENvbnRhaW5lcjtcbiAgICBjb25zdCBpdGVyYXRvciA9IGltYWdlUXVhbnRpemVyLnF1YW50aXplKGltYWdlLCBwYWxldHRlKTtcbiAgICBjb25zdCBuZXh0ID0gKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICBpZiAocmVzdWx0LmRvbmUpIHtcbiAgICAgICAgICByZXNvbHZlKG91dFBvaW50Q29udGFpbmVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAocmVzdWx0LnZhbHVlLnBvaW50Q29udGFpbmVyKSB7XG4gICAgICAgICAgICBvdXRQb2ludENvbnRhaW5lciA9IHJlc3VsdC52YWx1ZS5wb2ludENvbnRhaW5lcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9uUHJvZ3Jlc3MpXG4gICAgICAgICAgICBvblByb2dyZXNzKHJlc3VsdC52YWx1ZS5wcm9ncmVzcyk7XG4gICAgICAgICAgc2V0SW1tZWRpYXRlSW1wbChuZXh0KTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHNldEltbWVkaWF0ZUltcGwobmV4dCk7XG4gIH0pO1xufVxuZnVuY3Rpb24gY29sb3JEaXN0YW5jZUZvcm11bGFUb0NvbG9yRGlzdGFuY2UoY29sb3JEaXN0YW5jZUZvcm11bGEgPSBcImV1Y2xpZGVhbi1idDcwOVwiKSB7XG4gIHN3aXRjaCAoY29sb3JEaXN0YW5jZUZvcm11bGEpIHtcbiAgICBjYXNlIFwiY2llOTQtZ3JhcGhpYy1hcnRzXCI6XG4gICAgICByZXR1cm4gbmV3IENJRTk0R3JhcGhpY0FydHMoKTtcbiAgICBjYXNlIFwiY2llOTQtdGV4dGlsZXNcIjpcbiAgICAgIHJldHVybiBuZXcgQ0lFOTRUZXh0aWxlcygpO1xuICAgIGNhc2UgXCJjaWVkZTIwMDBcIjpcbiAgICAgIHJldHVybiBuZXcgQ0lFREUyMDAwKCk7XG4gICAgY2FzZSBcImNvbG9yLW1ldHJpY1wiOlxuICAgICAgcmV0dXJuIG5ldyBDTWV0cmljKCk7XG4gICAgY2FzZSBcImV1Y2xpZGVhblwiOlxuICAgICAgcmV0dXJuIG5ldyBFdWNsaWRlYW4oKTtcbiAgICBjYXNlIFwiZXVjbGlkZWFuLWJ0NzA5XCI6XG4gICAgICByZXR1cm4gbmV3IEV1Y2xpZGVhbkJUNzA5KCk7XG4gICAgY2FzZSBcImV1Y2xpZGVhbi1idDcwOS1ub2FscGhhXCI6XG4gICAgICByZXR1cm4gbmV3IEV1Y2xpZGVhbkJUNzA5Tm9BbHBoYSgpO1xuICAgIGNhc2UgXCJtYW5oYXR0YW5cIjpcbiAgICAgIHJldHVybiBuZXcgTWFuaGF0dGFuKCk7XG4gICAgY2FzZSBcIm1hbmhhdHRhbi1idDcwOVwiOlxuICAgICAgcmV0dXJuIG5ldyBNYW5oYXR0YW5CVDcwOSgpO1xuICAgIGNhc2UgXCJtYW5oYXR0YW4tbm9tbXlkZVwiOlxuICAgICAgcmV0dXJuIG5ldyBNYW5oYXR0YW5Ob21teWRlKCk7XG4gICAgY2FzZSBcInBuZ3F1YW50XCI6XG4gICAgICByZXR1cm4gbmV3IFBOR1F1YW50KCk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBjb2xvckRpc3RhbmNlRm9ybXVsYSAke2NvbG9yRGlzdGFuY2VGb3JtdWxhfWApO1xuICB9XG59XG5mdW5jdGlvbiBpbWFnZVF1YW50aXphdGlvblRvSW1hZ2VRdWFudGl6ZXIoZGlzdGFuY2VDYWxjdWxhdG9yLCBpbWFnZVF1YW50aXphdGlvbiA9IFwiZmxveWQtc3RlaW5iZXJnXCIpIHtcbiAgc3dpdGNoIChpbWFnZVF1YW50aXphdGlvbikge1xuICAgIGNhc2UgXCJuZWFyZXN0XCI6XG4gICAgICByZXR1cm4gbmV3IE5lYXJlc3RDb2xvcihkaXN0YW5jZUNhbGN1bGF0b3IpO1xuICAgIGNhc2UgXCJyaWVtZXJzbWFcIjpcbiAgICAgIHJldHVybiBuZXcgRXJyb3JEaWZmdXNpb25SaWVtZXJzbWEoZGlzdGFuY2VDYWxjdWxhdG9yKTtcbiAgICBjYXNlIFwiZmxveWQtc3RlaW5iZXJnXCI6XG4gICAgICByZXR1cm4gbmV3IEVycm9yRGlmZnVzaW9uQXJyYXkoZGlzdGFuY2VDYWxjdWxhdG9yLCAwIC8qIEZsb3lkU3RlaW5iZXJnICovKTtcbiAgICBjYXNlIFwiZmFsc2UtZmxveWQtc3RlaW5iZXJnXCI6XG4gICAgICByZXR1cm4gbmV3IEVycm9yRGlmZnVzaW9uQXJyYXkoZGlzdGFuY2VDYWxjdWxhdG9yLCAxIC8qIEZhbHNlRmxveWRTdGVpbmJlcmcgKi8pO1xuICAgIGNhc2UgXCJzdHVja2lcIjpcbiAgICAgIHJldHVybiBuZXcgRXJyb3JEaWZmdXNpb25BcnJheShkaXN0YW5jZUNhbGN1bGF0b3IsIDIgLyogU3R1Y2tpICovKTtcbiAgICBjYXNlIFwiYXRraW5zb25cIjpcbiAgICAgIHJldHVybiBuZXcgRXJyb3JEaWZmdXNpb25BcnJheShkaXN0YW5jZUNhbGN1bGF0b3IsIDMgLyogQXRraW5zb24gKi8pO1xuICAgIGNhc2UgXCJqYXJ2aXNcIjpcbiAgICAgIHJldHVybiBuZXcgRXJyb3JEaWZmdXNpb25BcnJheShkaXN0YW5jZUNhbGN1bGF0b3IsIDQgLyogSmFydmlzICovKTtcbiAgICBjYXNlIFwiYnVya2VzXCI6XG4gICAgICByZXR1cm4gbmV3IEVycm9yRGlmZnVzaW9uQXJyYXkoZGlzdGFuY2VDYWxjdWxhdG9yLCA1IC8qIEJ1cmtlcyAqLyk7XG4gICAgY2FzZSBcInNpZXJyYVwiOlxuICAgICAgcmV0dXJuIG5ldyBFcnJvckRpZmZ1c2lvbkFycmF5KGRpc3RhbmNlQ2FsY3VsYXRvciwgNiAvKiBTaWVycmEgKi8pO1xuICAgIGNhc2UgXCJ0d28tc2llcnJhXCI6XG4gICAgICByZXR1cm4gbmV3IEVycm9yRGlmZnVzaW9uQXJyYXkoZGlzdGFuY2VDYWxjdWxhdG9yLCA3IC8qIFR3b1NpZXJyYSAqLyk7XG4gICAgY2FzZSBcInNpZXJyYS1saXRlXCI6XG4gICAgICByZXR1cm4gbmV3IEVycm9yRGlmZnVzaW9uQXJyYXkoZGlzdGFuY2VDYWxjdWxhdG9yLCA4IC8qIFNpZXJyYUxpdGUgKi8pO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gaW1hZ2VRdWFudGl6YXRpb24gJHtpbWFnZVF1YW50aXphdGlvbn1gKTtcbiAgfVxufVxuZnVuY3Rpb24gcGFsZXR0ZVF1YW50aXphdGlvblRvUGFsZXR0ZVF1YW50aXplcihkaXN0YW5jZUNhbGN1bGF0b3IsIHBhbGV0dGVRdWFudGl6YXRpb24gPSBcInd1cXVhbnRcIiwgY29sb3JzID0gMjU2KSB7XG4gIHN3aXRjaCAocGFsZXR0ZVF1YW50aXphdGlvbikge1xuICAgIGNhc2UgXCJuZXVxdWFudFwiOlxuICAgICAgcmV0dXJuIG5ldyBOZXVRdWFudChkaXN0YW5jZUNhbGN1bGF0b3IsIGNvbG9ycyk7XG4gICAgY2FzZSBcInJnYnF1YW50XCI6XG4gICAgICByZXR1cm4gbmV3IFJHQlF1YW50KGRpc3RhbmNlQ2FsY3VsYXRvciwgY29sb3JzKTtcbiAgICBjYXNlIFwid3VxdWFudFwiOlxuICAgICAgcmV0dXJuIG5ldyBXdVF1YW50KGRpc3RhbmNlQ2FsY3VsYXRvciwgY29sb3JzKTtcbiAgICBjYXNlIFwibmV1cXVhbnQtZmxvYXRcIjpcbiAgICAgIHJldHVybiBuZXcgTmV1UXVhbnRGbG9hdChkaXN0YW5jZUNhbGN1bGF0b3IsIGNvbG9ycyk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBwYWxldHRlUXVhbnRpemF0aW9uICR7cGFsZXR0ZVF1YW50aXphdGlvbn1gKTtcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSBfX3RvQ29tbW9uSlMoc3JjX2V4cG9ydHMpO1xuLy8gQW5ub3RhdGUgdGhlIENvbW1vbkpTIGV4cG9ydCBuYW1lcyBmb3IgRVNNIGltcG9ydCBpbiBub2RlOlxuMCAmJiAobW9kdWxlLmV4cG9ydHMgPSB7XG4gIGFwcGx5UGFsZXR0ZSxcbiAgYXBwbHlQYWxldHRlU3luYyxcbiAgYnVpbGRQYWxldHRlLFxuICBidWlsZFBhbGV0dGVTeW5jLFxuICBjb25zdGFudHMsXG4gIGNvbnZlcnNpb24sXG4gIGRpc3RhbmNlLFxuICBpbWFnZSxcbiAgcGFsZXR0ZSxcbiAgcXVhbGl0eSxcbiAgdXRpbHNcbn0pO1xuLyoqXG4gKiBAcHJlc2VydmVcbiAqIENvcHlyaWdodCAyMDE1LTIwMTggSWdvciBCZXprcm92bnlpXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLiAoTUlUIExpY2Vuc2VkKVxuICpcbiAqIGNpZTk0LnRzIC0gcGFydCBvZiBJbWFnZSBRdWFudGl6YXRpb24gTGlicmFyeVxuICovXG4vKipcbiAqIEBwcmVzZXJ2ZVxuICogQ29weXJpZ2h0IDIwMTUtMjAxOCBJZ29yIEJlemtyb3ZueWlcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuIChNSVQgTGljZW5zZWQpXG4gKlxuICogY2llZGUyMDAwLnRzIC0gcGFydCBvZiBJbWFnZSBRdWFudGl6YXRpb24gTGlicmFyeVxuICovXG4vKipcbiAqIEBwcmVzZXJ2ZVxuICogQ29weXJpZ2h0IDIwMTUtMjAxOCBJZ29yIEJlemtyb3ZueWlcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuIChNSVQgTGljZW5zZWQpXG4gKlxuICogY21ldHJpYy50cyAtIHBhcnQgb2YgSW1hZ2UgUXVhbnRpemF0aW9uIExpYnJhcnlcbiAqL1xuLyoqXG4gKiBAcHJlc2VydmVcbiAqIENvcHlyaWdodCAyMDE1LTIwMTggSWdvciBCZXprcm92bnlpXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLiAoTUlUIExpY2Vuc2VkKVxuICpcbiAqIGNvbW1vbi50cyAtIHBhcnQgb2YgSW1hZ2UgUXVhbnRpemF0aW9uIExpYnJhcnlcbiAqL1xuLyoqXG4gKiBAcHJlc2VydmVcbiAqIENvcHlyaWdodCAyMDE1LTIwMTggSWdvciBCZXprcm92bnlpXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLiAoTUlUIExpY2Vuc2VkKVxuICpcbiAqIGNvbnN0YW50cy50cyAtIHBhcnQgb2YgSW1hZ2UgUXVhbnRpemF0aW9uIExpYnJhcnlcbiAqL1xuLyoqXG4gKiBAcHJlc2VydmVcbiAqIENvcHlyaWdodCAyMDE1LTIwMTggSWdvciBCZXprcm92bnlpXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLiAoTUlUIExpY2Vuc2VkKVxuICpcbiAqIGRpdGhlckVycm9yRGlmZnVzaW9uQXJyYXkudHMgLSBwYXJ0IG9mIEltYWdlIFF1YW50aXphdGlvbiBMaWJyYXJ5XG4gKi9cbi8qKlxuICogQHByZXNlcnZlXG4gKiBDb3B5cmlnaHQgMjAxNS0yMDE4IElnb3IgQmV6a3Jvdm55aVxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC4gKE1JVCBMaWNlbnNlZClcbiAqXG4gKiBldWNsaWRlYW4udHMgLSBwYXJ0IG9mIEltYWdlIFF1YW50aXphdGlvbiBMaWJyYXJ5XG4gKi9cbi8qKlxuICogQHByZXNlcnZlXG4gKiBDb3B5cmlnaHQgMjAxNS0yMDE4IElnb3IgQmV6a3Jvdm55aVxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC4gKE1JVCBMaWNlbnNlZClcbiAqXG4gKiBoZWxwZXIudHMgLSBwYXJ0IG9mIEltYWdlIFF1YW50aXphdGlvbiBMaWJyYXJ5XG4gKi9cbi8qKlxuICogQHByZXNlcnZlXG4gKiBDb3B5cmlnaHQgMjAxNS0yMDE4IElnb3IgQmV6a3Jvdm55aVxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC4gKE1JVCBMaWNlbnNlZClcbiAqXG4gKiBodWVTdGF0aXN0aWNzLnRzIC0gcGFydCBvZiBJbWFnZSBRdWFudGl6YXRpb24gTGlicmFyeVxuICovXG4vKipcbiAqIEBwcmVzZXJ2ZVxuICogQ29weXJpZ2h0IDIwMTUtMjAxOCBJZ29yIEJlemtyb3ZueWlcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuIChNSVQgTGljZW5zZWQpXG4gKlxuICogaXEudHMgLSBJbWFnZSBRdWFudGl6YXRpb24gTGlicmFyeVxuICovXG4vKipcbiAqIEBwcmVzZXJ2ZVxuICogQ29weXJpZ2h0IDIwMTUtMjAxOCBJZ29yIEJlemtyb3ZueWlcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuIChNSVQgTGljZW5zZWQpXG4gKlxuICogbGFiMnJnYi50cyAtIHBhcnQgb2YgSW1hZ2UgUXVhbnRpemF0aW9uIExpYnJhcnlcbiAqL1xuLyoqXG4gKiBAcHJlc2VydmVcbiAqIENvcHlyaWdodCAyMDE1LTIwMTggSWdvciBCZXprcm92bnlpXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLiAoTUlUIExpY2Vuc2VkKVxuICpcbiAqIGxhYjJ4eXoudHMgLSBwYXJ0IG9mIEltYWdlIFF1YW50aXphdGlvbiBMaWJyYXJ5XG4gKi9cbi8qKlxuICogQHByZXNlcnZlXG4gKiBDb3B5cmlnaHQgMjAxNS0yMDE4IElnb3IgQmV6a3Jvdm55aVxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC4gKE1JVCBMaWNlbnNlZClcbiAqXG4gKiBtYW5oYXR0YW5OZXVRdWFudC50cyAtIHBhcnQgb2YgSW1hZ2UgUXVhbnRpemF0aW9uIExpYnJhcnlcbiAqL1xuLyoqXG4gKiBAcHJlc2VydmVcbiAqIENvcHlyaWdodCAyMDE1LTIwMTggSWdvciBCZXprcm92bnlpXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLiAoTUlUIExpY2Vuc2VkKVxuICpcbiAqIG5lYXJlc3RDb2xvci50cyAtIHBhcnQgb2YgSW1hZ2UgUXVhbnRpemF0aW9uIExpYnJhcnlcbiAqL1xuLyoqXG4gKiBAcHJlc2VydmVcbiAqIENvcHlyaWdodCAyMDE1LTIwMTggSWdvciBCZXprcm92bnlpXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLiAoTUlUIExpY2Vuc2VkKVxuICpcbiAqIHBhbGV0dGUudHMgLSBwYXJ0IG9mIEltYWdlIFF1YW50aXphdGlvbiBMaWJyYXJ5XG4gKi9cbi8qKlxuICogQHByZXNlcnZlXG4gKiBDb3B5cmlnaHQgMjAxNS0yMDE4IElnb3IgQmV6a3Jvdm55aVxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC4gKE1JVCBMaWNlbnNlZClcbiAqXG4gKiBwbmdRdWFudC50cyAtIHBhcnQgb2YgSW1hZ2UgUXVhbnRpemF0aW9uIExpYnJhcnlcbiAqL1xuLyoqXG4gKiBAcHJlc2VydmVcbiAqIENvcHlyaWdodCAyMDE1LTIwMTggSWdvciBCZXprcm92bnlpXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLiAoTUlUIExpY2Vuc2VkKVxuICpcbiAqIHBvaW50LnRzIC0gcGFydCBvZiBJbWFnZSBRdWFudGl6YXRpb24gTGlicmFyeVxuICovXG4vKipcbiAqIEBwcmVzZXJ2ZVxuICogQ29weXJpZ2h0IDIwMTUtMjAxOCBJZ29yIEJlemtyb3ZueWlcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuIChNSVQgTGljZW5zZWQpXG4gKlxuICogcG9pbnRDb250YWluZXIudHMgLSBwYXJ0IG9mIEltYWdlIFF1YW50aXphdGlvbiBMaWJyYXJ5XG4gKi9cbi8qKlxuICogQHByZXNlcnZlXG4gKiBDb3B5cmlnaHQgMjAxNS0yMDE4IElnb3IgQmV6a3Jvdm55aVxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC4gKE1JVCBMaWNlbnNlZClcbiAqXG4gKiByZ2IyaHNsLnRzIC0gcGFydCBvZiBJbWFnZSBRdWFudGl6YXRpb24gTGlicmFyeVxuICovXG4vKipcbiAqIEBwcmVzZXJ2ZVxuICogQ29weXJpZ2h0IDIwMTUtMjAxOCBJZ29yIEJlemtyb3ZueWlcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuIChNSVQgTGljZW5zZWQpXG4gKlxuICogcmdiMmxhYi50cyAtIHBhcnQgb2YgSW1hZ2UgUXVhbnRpemF0aW9uIExpYnJhcnlcbiAqL1xuLyoqXG4gKiBAcHJlc2VydmVcbiAqIENvcHlyaWdodCAyMDE1LTIwMTggSWdvciBCZXprcm92bnlpXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLiAoTUlUIExpY2Vuc2VkKVxuICpcbiAqIHJnYjJ4eXoudHMgLSBwYXJ0IG9mIEltYWdlIFF1YW50aXphdGlvbiBMaWJyYXJ5XG4gKi9cbi8qKlxuICogQHByZXNlcnZlXG4gKiBDb3B5cmlnaHQgMjAxNS0yMDE4IElnb3IgQmV6a3Jvdm55aVxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC4gKE1JVCBMaWNlbnNlZClcbiAqXG4gKiBzc2ltLnRzIC0gcGFydCBvZiBJbWFnZSBRdWFudGl6YXRpb24gTGlicmFyeVxuICovXG4vKipcbiAqIEBwcmVzZXJ2ZVxuICogQ29weXJpZ2h0IDIwMTUtMjAxOCBJZ29yIEJlemtyb3ZueWlcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuIChNSVQgTGljZW5zZWQpXG4gKlxuICogd3VRdWFudC50cyAtIHBhcnQgb2YgSW1hZ2UgUXVhbnRpemF0aW9uIExpYnJhcnlcbiAqL1xuLyoqXG4gKiBAcHJlc2VydmVcbiAqIENvcHlyaWdodCAyMDE1LTIwMTggSWdvciBCZXprcm92bnlpXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLiAoTUlUIExpY2Vuc2VkKVxuICpcbiAqIHh5ejJsYWIudHMgLSBwYXJ0IG9mIEltYWdlIFF1YW50aXphdGlvbiBMaWJyYXJ5XG4gKi9cbi8qKlxuICogQHByZXNlcnZlXG4gKiBDb3B5cmlnaHQgMjAxNS0yMDE4IElnb3IgQmV6a3Jvdm55aVxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC4gKE1JVCBMaWNlbnNlZClcbiAqXG4gKiB4eXoycmdiLnRzIC0gcGFydCBvZiBJbWFnZSBRdWFudGl6YXRpb24gTGlicmFyeVxuICovXG4vKipcbiAqIEBwcmVzZXJ2ZVxuICogTUlUIExpY2Vuc2VcbiAqXG4gKiBDb3B5cmlnaHQgMjAxNS0yMDE4IElnb3IgQmV6a3Jvdm55aVxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvXG4gKiBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZVxuICogcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yXG4gKiBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTFxuICogVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HXG4gKiBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTXG4gKiBJTiBUSEUgU09GVFdBUkUuXG4gKlxuICogcmllbWVyc21hLnRzIC0gcGFydCBvZiBJbWFnZSBRdWFudGl6YXRpb24gTGlicmFyeVxuICovXG4vKipcbiAqIEBwcmVzZXJ2ZSBUeXBlU2NyaXB0IHBvcnQ6XG4gKiBDb3B5cmlnaHQgMjAxNS0yMDE4IElnb3IgQmV6a3Jvdm55aVxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC4gKE1JVCBMaWNlbnNlZClcbiAqXG4gKiBjb2xvckhpc3RvZ3JhbS50cyAtIHBhcnQgb2YgSW1hZ2UgUXVhbnRpemF0aW9uIExpYnJhcnlcbiAqL1xuLyoqXG4gKiBAcHJlc2VydmUgVHlwZVNjcmlwdCBwb3J0OlxuICogQ29weXJpZ2h0IDIwMTUtMjAxOCBJZ29yIEJlemtyb3ZueWlcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuIChNSVQgTGljZW5zZWQpXG4gKlxuICogbmV1cXVhbnQudHMgLSBwYXJ0IG9mIEltYWdlIFF1YW50aXphdGlvbiBMaWJyYXJ5XG4gKi9cbi8qKlxuICogQHByZXNlcnZlIFR5cGVTY3JpcHQgcG9ydDpcbiAqIENvcHlyaWdodCAyMDE1LTIwMTggSWdvciBCZXprcm92bnlpXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLiAoTUlUIExpY2Vuc2VkKVxuICpcbiAqIHJnYnF1YW50LnRzIC0gcGFydCBvZiBJbWFnZSBRdWFudGl6YXRpb24gTGlicmFyeVxuICovXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbWFnZS1xLmNqcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/image-q@4.0.0/node_modules/image-q/dist/cjs/image-q.cjs\n");

/***/ })

};
;