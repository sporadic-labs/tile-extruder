"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@jimp+core@1.6.0";
exports.ids = ["vendor-chunks/@jimp+core@1.6.0"];
exports.modules = {

/***/ "(ssr)/../../node_modules/.pnpm/@jimp+core@1.6.0/node_modules/@jimp/core/dist/commonjs/index.js":
/*!************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@jimp+core@1.6.0/node_modules/@jimp/core/dist/commonjs/index.js ***!
  \************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.composite = exports.getExifOrientation = void 0;\nexports.createJimp = createJimp;\nconst types_1 = __webpack_require__(/*! @jimp/types */ \"(ssr)/../../node_modules/.pnpm/@jimp+types@1.6.0/node_modules/@jimp/types/dist/commonjs/index.js\");\nconst utils_1 = __webpack_require__(/*! @jimp/utils */ \"(ssr)/../../node_modules/.pnpm/@jimp+utils@1.6.0/node_modules/@jimp/utils/dist/commonjs/index.js\");\nconst core_js_1 = __importDefault(__webpack_require__(/*! file-type/core.js */ \"(ssr)/../../node_modules/.pnpm/file-type@16.5.4/node_modules/file-type/core.js\"));\nconst await_to_js_1 = __webpack_require__(/*! await-to-js */ \"(ssr)/../../node_modules/.pnpm/await-to-js@3.0.0/node_modules/await-to-js/dist/await-to-js.es5.js\");\nconst file_ops_1 = __webpack_require__(/*! @jimp/file-ops */ \"(ssr)/../../node_modules/.pnpm/@jimp+file-ops@1.6.0/node_modules/@jimp/file-ops/dist/commonjs/index.js\");\nconst lite_js_1 = __importDefault(__webpack_require__(/*! mime/lite.js */ \"(ssr)/../../node_modules/.pnpm/mime@3.0.0/node_modules/mime/lite.js\"));\nconst composite_js_1 = __webpack_require__(/*! ./utils/composite.js */ \"(ssr)/../../node_modules/.pnpm/@jimp+core@1.6.0/node_modules/@jimp/core/dist/commonjs/utils/composite.js\");\nconst image_bitmap_js_1 = __webpack_require__(/*! ./utils/image-bitmap.js */ \"(ssr)/../../node_modules/.pnpm/@jimp+core@1.6.0/node_modules/@jimp/core/dist/commonjs/utils/image-bitmap.js\");\nconst emptyBitmap = {\n    data: Buffer.alloc(0),\n    width: 0,\n    height: 0,\n};\n/**\n * Prepare a Buffer object from the arrayBuffer.\n */\nfunction bufferFromArrayBuffer(arrayBuffer) {\n    const buffer = Buffer.alloc(arrayBuffer.byteLength);\n    const view = new Uint8Array(arrayBuffer);\n    for (let i = 0; i < buffer.length; ++i) {\n        buffer[i] = view[i];\n    }\n    return buffer;\n}\nvar image_bitmap_js_2 = __webpack_require__(/*! ./utils/image-bitmap.js */ \"(ssr)/../../node_modules/.pnpm/@jimp+core@1.6.0/node_modules/@jimp/core/dist/commonjs/utils/image-bitmap.js\");\nObject.defineProperty(exports, \"getExifOrientation\", ({ enumerable: true, get: function () { return image_bitmap_js_2.getExifOrientation; } }));\nvar composite_js_2 = __webpack_require__(/*! ./utils/composite.js */ \"(ssr)/../../node_modules/.pnpm/@jimp+core@1.6.0/node_modules/@jimp/core/dist/commonjs/utils/composite.js\");\nObject.defineProperty(exports, \"composite\", ({ enumerable: true, get: function () { return composite_js_2.composite; } }));\n__exportStar(__webpack_require__(/*! ./utils/constants.js */ \"(ssr)/../../node_modules/.pnpm/@jimp+core@1.6.0/node_modules/@jimp/core/dist/commonjs/utils/constants.js\"), exports);\n/**\n * Create a Jimp class that support the given image formats and methods\n */\nfunction createJimp({ plugins: pluginsArg, formats: formatsArg, } = {}) {\n    const plugins = pluginsArg || [];\n    const formats = (formatsArg || []).map((format) => format());\n    const CustomJimp = class Jimp {\n        /**\n         * The bitmap data of the image\n         */\n        bitmap = emptyBitmap;\n        /**  Default color to use for new pixels */\n        background = 0x00000000;\n        /** Formats that can be used with Jimp */\n        formats = [];\n        /** The original MIME type of the image */\n        mime;\n        constructor(options = emptyBitmap) {\n            // Add the formats\n            this.formats = formats;\n            if (\"data\" in options) {\n                this.bitmap = options;\n            }\n            else {\n                this.bitmap = {\n                    data: Buffer.alloc(options.width * options.height * 4),\n                    width: options.width,\n                    height: options.height,\n                };\n                if (options.color) {\n                    this.background =\n                        typeof options.color === \"string\"\n                            ? (0, utils_1.cssColorToHex)(options.color)\n                            : options.color;\n                    for (let i = 0; i < this.bitmap.data.length; i += 4) {\n                        this.bitmap.data.writeUInt32BE(this.background, i);\n                    }\n                }\n            }\n            // Add the plugins\n            for (const methods of plugins) {\n                for (const key in methods) {\n                    this[key] = (...args) => {\n                        const result = methods[key]?.(this, ...args);\n                        if (typeof result === \"object\" && \"bitmap\" in result) {\n                            this.bitmap = result.bitmap;\n                            return this;\n                        }\n                        return result;\n                    };\n                }\n            }\n        }\n        /**\n         * Create a Jimp instance from a URL, a file path, or a Buffer\n         * @example\n         * ```ts\n         * import { Jimp } from \"jimp\";\n         *\n         * // Read from a file path\n         * const image = await Jimp.read(\"test/image.png\");\n         *\n         * // Read from a URL\n         * const image = await Jimp.read(\"https://upload.wikimedia.org/wikipedia/commons/0/01/Bot-Test.jpg\");\n         * ```\n         */\n        static async read(url, options) {\n            if (Buffer.isBuffer(url) || url instanceof ArrayBuffer) {\n                return this.fromBuffer(url);\n            }\n            if ((0, file_ops_1.existsSync)(url)) {\n                return this.fromBuffer(await (0, file_ops_1.readFile)(url));\n            }\n            const [fetchErr, response] = await (0, await_to_js_1.to)(fetch(url));\n            if (fetchErr) {\n                throw new Error(`Could not load Buffer from URL: ${url}`);\n            }\n            if (!response.ok) {\n                throw new Error(`HTTP Status ${response.status} for url ${url}`);\n            }\n            const [arrayBufferErr, data] = await (0, await_to_js_1.to)(response.arrayBuffer());\n            if (arrayBufferErr) {\n                throw new Error(`Could not load Buffer from ${url}`);\n            }\n            const buffer = bufferFromArrayBuffer(data);\n            return this.fromBuffer(buffer, options);\n        }\n        /**\n         * Create a Jimp instance from a bitmap.\n         * The difference between this and just using the constructor is that this will\n         * convert raw image data into the bitmap format that Jimp uses.\n         *\n         * @example\n         * ```ts\n         * import { Jimp } from \"jimp\";\n         *\n         * const image = Jimp.fromBitmap({\n         *   data: Buffer.from([\n         *     0xffffffff, 0xffffffff, 0xffffffff,\n         *     0xffffffff, 0xffffffff, 0xffffffff,\n         *     0xffffffff, 0xffffffff, 0xffffffff,\n         *   ]),\n         *   width: 3,\n         *   height: 3,\n         * });\n         * ```\n         */\n        static fromBitmap(bitmap) {\n            let data;\n            if (bitmap.data instanceof Buffer) {\n                data = Buffer.from(bitmap.data);\n            }\n            if (bitmap.data instanceof Uint8Array ||\n                bitmap.data instanceof Uint8ClampedArray) {\n                data = Buffer.from(bitmap.data.buffer);\n            }\n            if (Array.isArray(bitmap.data)) {\n                data = Buffer.concat(bitmap.data.map((hex) => Buffer.from(hex.toString(16).padStart(8, \"0\"), \"hex\")));\n            }\n            if (!data) {\n                throw new Error(\"data must be a Buffer\");\n            }\n            if (typeof bitmap.height !== \"number\" ||\n                typeof bitmap.width !== \"number\") {\n                throw new Error(\"bitmap must have width and height\");\n            }\n            return new CustomJimp({\n                height: bitmap.height,\n                width: bitmap.width,\n                data,\n            });\n        }\n        /**\n         * Parse a bitmap with the loaded image types.\n         *\n         * @param buffer Raw image data\n         * @example\n         * ```ts\n         * import { Jimp } from \"jimp\";\n         *\n         * const buffer = await fs.readFile(\"test/image.png\");\n         * const image = await Jimp.fromBuffer(buffer);\n         * ```\n         */\n        static async fromBuffer(buffer, options) {\n            const actualBuffer = buffer instanceof ArrayBuffer ? bufferFromArrayBuffer(buffer) : buffer;\n            const mime = await core_js_1.default.fromBuffer(actualBuffer);\n            if (!mime || !mime.mime) {\n                throw new Error(\"Could not find MIME for Buffer\");\n            }\n            const format = formats.find((format) => format.mime === mime.mime);\n            if (!format || !format.decode) {\n                throw new Error(`Mime type ${mime.mime} does not support decoding`);\n            }\n            const image = new CustomJimp(await format.decode(actualBuffer, options?.[format.mime]));\n            image.mime = mime.mime;\n            (0, image_bitmap_js_1.attemptExifRotate)(image, actualBuffer);\n            return image;\n        }\n        /**\n         * Nicely format Jimp object when sent to the console e.g. console.log(image)\n         * @returns Pretty printed jimp object\n         * @example\n         * ```ts\n         * import { Jimp } from \"jimp\";\n         *\n         * const image = await Jimp.read(\"test/image.png\");\n         *\n         * console.log(image);\n         * ```\n         */\n        inspect() {\n            return (\"<Jimp \" +\n                (this.bitmap === emptyBitmap\n                    ? \"pending...\"\n                    : this.bitmap.width + \"x\" + this.bitmap.height) +\n                \">\");\n        }\n        /**\n         * Nicely format Jimp object when converted to a string\n         * @returns pretty printed\n         */\n        toString() {\n            return \"[object Jimp]\";\n        }\n        /** Get the width of the image */\n        get width() {\n            return this.bitmap.width;\n        }\n        /** Get the height of the image */\n        get height() {\n            return this.bitmap.height;\n        }\n        /**\n         * Converts the Jimp instance to an image buffer\n         * @param mime The mime type to export to\n         * @param options The options to use when exporting\n         * @example\n         * ```ts\n         * import { Jimp } from \"jimp\";\n         * import { promises as fs } from \"fs\";\n         *\n         * const image = new Jimp({ width: 3, height: 3, color: 0xffffffff });\n         *\n         * await image.write(\"test/output.jpeg\", {\n         *   quality: 50,\n         * });\n         * ```\n         */\n        async getBuffer(mime, options) {\n            const format = this.formats.find((format) => format.mime === mime);\n            if (!format || !format.encode) {\n                throw new Error(`Unsupported MIME type: ${mime}`);\n            }\n            let outputImage;\n            if (format.hasAlpha) {\n                // eslint-disable-next-line @typescript-eslint/no-this-alias\n                outputImage = this;\n            }\n            else {\n                outputImage = new CustomJimp({\n                    width: this.bitmap.width,\n                    height: this.bitmap.height,\n                    color: this.background,\n                });\n                (0, composite_js_1.composite)(outputImage, this);\n            }\n            return format.encode(outputImage.bitmap, options);\n        }\n        /**\n         * Converts the image to a base 64 string\n         *\n         * @param mime The mime type to export to\n         * @param options The options to use when exporting\n         * @example\n         * ```ts\n         * import { Jimp } from \"jimp\";\n         *\n         * const image = Jimp.fromBuffer(Buffer.from([\n         *   0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,\n         *   0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,\n         *   0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,\n         * ]));\n         *\n         * const base64 = image.getBase64(\"image/jpeg\", {\n         *   quality: 50,\n         * });\n         * ```\n         */\n        async getBase64(mime, options) {\n            const data = await this.getBuffer(mime, options);\n            return \"data:\" + mime + \";base64,\" + data.toString(\"base64\");\n        }\n        /**\n         * Write the image to a file\n         * @param path the path to write the image to\n         * @param options the options to use when writing the image\n         * @example\n         * ```ts\n         * import { Jimp } from \"jimp\";\n         *\n         * const image = Jimp.fromBuffer(Buffer.from([\n         *   0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,\n         *   0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,\n         *   0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,\n         * ]));\n         *\n         * await image.write(\"test/output.png\");\n         * ```\n         */\n        async write(path, options) {\n            const mimeType = lite_js_1.default.getType(path);\n            await (0, file_ops_1.writeFile)(path, await this.getBuffer(mimeType, options));\n        }\n        /**\n         * Clone the image into a new Jimp instance.\n         * @param this\n         * @returns A new Jimp instance\n         * @example\n         * ```ts\n         * import { Jimp } from \"jimp\";\n         *\n         * const image = new Jimp({ width: 3, height: 3, color: 0xffffffff });\n         *\n         * const clone = image.clone();\n         * ```\n         */\n        clone() {\n            return new CustomJimp({\n                ...this.bitmap,\n                data: Buffer.from(this.bitmap.data),\n            });\n        }\n        /**\n         * Returns the offset of a pixel in the bitmap buffer\n         * @param x the x coordinate\n         * @param y the y coordinate\n         * @param edgeHandling (optional) define how to sum pixels from outside the border\n         * @returns the index of the pixel or -1 if not found\n         * @example\n         * ```ts\n         * import { Jimp } from \"jimp\";\n         *\n         * const image = new Jimp({ width: 3, height: 3, color: 0xffffffff });\n         *\n         * image.getPixelIndex(1, 1); // 2\n         * ```\n         */\n        getPixelIndex(x, y, edgeHandling) {\n            let xi;\n            let yi;\n            if (!edgeHandling) {\n                edgeHandling = types_1.Edge.EXTEND;\n            }\n            if (typeof x !== \"number\" || typeof y !== \"number\") {\n                throw new Error(\"x and y must be numbers\");\n            }\n            // round input\n            x = Math.round(x);\n            y = Math.round(y);\n            xi = x;\n            yi = y;\n            if (edgeHandling === types_1.Edge.EXTEND) {\n                if (x < 0)\n                    xi = 0;\n                if (x >= this.bitmap.width)\n                    xi = this.bitmap.width - 1;\n                if (y < 0)\n                    yi = 0;\n                if (y >= this.bitmap.height)\n                    yi = this.bitmap.height - 1;\n            }\n            if (edgeHandling === types_1.Edge.WRAP) {\n                if (x < 0) {\n                    xi = this.bitmap.width + x;\n                }\n                if (x >= this.bitmap.width) {\n                    xi = x % this.bitmap.width;\n                }\n                if (y < 0) {\n                    yi = this.bitmap.height + y;\n                }\n                if (y >= this.bitmap.height) {\n                    yi = y % this.bitmap.height;\n                }\n            }\n            let i = (this.bitmap.width * yi + xi) << 2;\n            // if out of bounds index is -1\n            if (xi < 0 || xi >= this.bitmap.width) {\n                i = -1;\n            }\n            if (yi < 0 || yi >= this.bitmap.height) {\n                i = -1;\n            }\n            return i;\n        }\n        /**\n         * Returns the hex color value of a pixel\n         * @param x the x coordinate\n         * @param y the y coordinate\n         * @returns the color of the pixel\n         * @example\n         * ```ts\n         * import { Jimp } from \"jimp\";\n         *\n         * const image = new Jimp({ width: 3, height: 3, color: 0xffffffff });\n         *\n         * image.getPixelColor(1, 1); // 0xffffffff\n         * ```\n         */\n        getPixelColor(x, y) {\n            if (typeof x !== \"number\" || typeof y !== \"number\") {\n                throw new Error(\"x and y must be numbers\");\n            }\n            const idx = this.getPixelIndex(x, y);\n            return this.bitmap.data.readUInt32BE(idx);\n        }\n        /**\n         * Sets the hex colour value of a pixel\n         *\n         * @param hex color to set\n         * @param x the x coordinate\n         * @param y the y coordinate\n         *\n         * @example\n         * ```ts\n         * import { Jimp } from \"jimp\";\n         *\n         * const image = new Jimp({ width: 3, height: 3, color: 0xffffffff });\n         *\n         * image.setPixelColor(0xff0000ff, 0, 0);\n         * ```\n         */\n        setPixelColor(hex, x, y) {\n            if (typeof hex !== \"number\" ||\n                typeof x !== \"number\" ||\n                typeof y !== \"number\") {\n                throw new Error(\"hex, x and y must be numbers\");\n            }\n            const idx = this.getPixelIndex(x, y);\n            this.bitmap.data.writeUInt32BE(hex, idx);\n            return this;\n        }\n        /**\n         * Determine if the image contains opaque pixels.\n         *\n         * @example\n         * ```ts\n         * import { Jimp } from \"jimp\";\n         *\n         * const image = new Jimp({ width: 3, height: 3, color: 0xffffffaa });\n         * const image2 = new Jimp({ width: 3, height: 3, color: 0xff0000ff });\n         *\n         * image.hasAlpha(); // false\n         * image2.hasAlpha(); // true\n         * ```\n         */\n        hasAlpha() {\n            const { width, height, data } = this.bitmap;\n            const byteLen = (width * height) << 2;\n            for (let idx = 3; idx < byteLen; idx += 4) {\n                if (data[idx] !== 0xff) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        /**\n         * Composites a source image over to this image respecting alpha channels\n         * @param src the source Jimp instance\n         * @param x the x position to blit the image\n         * @param y the y position to blit the image\n         * @param options determine what mode to use\n         * @example\n         * ```ts\n         * import { Jimp } from \"jimp\";\n         *\n         * const image = new Jimp({ width: 10, height: 10, color: 0xffffffff });\n         * const image2 = new Jimp({ width: 3, height: 3, color: 0xff0000ff });\n         *\n         * image.composite(image2, 3, 3);\n         * ```\n         */\n        composite(src, x = 0, y = 0, options = {}) {\n            return (0, composite_js_1.composite)(this, src, x, y, options);\n        }\n        scan(x, y, w, h, f) {\n            return (0, utils_1.scan)(this, x, y, w, h, f);\n        }\n        /**\n         * Iterate scan through a region of the bitmap\n         * @param x the x coordinate to begin the scan at\n         * @param y the y coordinate to begin the scan at\n         * @param w the width of the scan region\n         * @param h the height of the scan region\n         * @example\n         * ```ts\n         * import { Jimp } from \"jimp\";\n         *\n         * const image = new Jimp({ width: 3, height: 3, color: 0xffffffff });\n         *\n         * for (const { x, y, idx, image } of j.scanIterator()) {\n         *   // do something with the pixel\n         * }\n         * ```\n         */\n        scanIterator(x = 0, y = 0, w = this.bitmap.width, h = this.bitmap.height) {\n            if (typeof x !== \"number\" || typeof y !== \"number\") {\n                throw new Error(\"x and y must be numbers\");\n            }\n            if (typeof w !== \"number\" || typeof h !== \"number\") {\n                throw new Error(\"w and h must be numbers\");\n            }\n            return (0, utils_1.scanIterator)(this, x, y, w, h);\n        }\n    };\n    return CustomJimp;\n}\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BqaW1wK2NvcmVAMS42LjAvbm9kZV9tb2R1bGVzL0BqaW1wL2NvcmUvZGlzdC9jb21tb25qcy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGlCQUFpQixHQUFHLDBCQUEwQjtBQUM5QyxrQkFBa0I7QUFDbEIsZ0JBQWdCLG1CQUFPLENBQUMscUhBQWE7QUFDckMsZ0JBQWdCLG1CQUFPLENBQUMscUhBQWE7QUFDckMsa0NBQWtDLG1CQUFPLENBQUMseUdBQW1CO0FBQzdELHNCQUFzQixtQkFBTyxDQUFDLHNIQUFhO0FBQzNDLG1CQUFtQixtQkFBTyxDQUFDLDhIQUFnQjtBQUMzQyxrQ0FBa0MsbUJBQU8sQ0FBQyx5RkFBYztBQUN4RCx1QkFBdUIsbUJBQU8sQ0FBQyxzSUFBc0I7QUFDckQsMEJBQTBCLG1CQUFPLENBQUMsNElBQXlCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG1CQUFPLENBQUMsNElBQXlCO0FBQ3pELHNEQUFxRCxFQUFFLHFDQUFxQyxnREFBZ0QsRUFBQztBQUM3SSxxQkFBcUIsbUJBQU8sQ0FBQyxzSUFBc0I7QUFDbkQsNkNBQTRDLEVBQUUscUNBQXFDLG9DQUFvQyxFQUFDO0FBQ3hILGFBQWEsbUJBQU8sQ0FBQyxzSUFBc0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDRDQUE0QyxJQUFJO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyw2QkFBNkI7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLElBQUk7QUFDdkU7QUFDQTtBQUNBLCtDQUErQyxpQkFBaUIsVUFBVSxJQUFJO0FBQzlFO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxJQUFJO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxXQUFXO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQSxvQ0FBb0Msd0NBQXdDO0FBQzVFO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELEtBQUs7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0Esb0NBQW9DLHdDQUF3QztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0Esb0NBQW9DLHdDQUF3QztBQUM1RTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBLG9DQUFvQyx3Q0FBd0M7QUFDNUU7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQSxvQ0FBb0Msd0NBQXdDO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQSxvQ0FBb0Msd0NBQXdDO0FBQzVFLHFDQUFxQyx3Q0FBd0M7QUFDN0U7QUFDQSw2QkFBNkI7QUFDN0IsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQSw4QkFBOEIsZUFBZTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQSxvQ0FBb0MsMENBQTBDO0FBQzlFLHFDQUFxQyx3Q0FBd0M7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBLG9DQUFvQyx3Q0FBd0M7QUFDNUU7QUFDQSx3QkFBd0IsbUJBQW1CO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9taWtld2VzdGhhZC9EZXNrdG9wL1JlcG9zL3Nwb3JhZGljLWxhYnMtdGlsZS1leHRydWRlci9ub2RlX21vZHVsZXMvLnBucG0vQGppbXArY29yZUAxLjYuMC9ub2RlX21vZHVsZXMvQGppbXAvY29yZS9kaXN0L2NvbW1vbmpzL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNvbXBvc2l0ZSA9IGV4cG9ydHMuZ2V0RXhpZk9yaWVudGF0aW9uID0gdm9pZCAwO1xuZXhwb3J0cy5jcmVhdGVKaW1wID0gY3JlYXRlSmltcDtcbmNvbnN0IHR5cGVzXzEgPSByZXF1aXJlKFwiQGppbXAvdHlwZXNcIik7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIkBqaW1wL3V0aWxzXCIpO1xuY29uc3QgY29yZV9qc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJmaWxlLXR5cGUvY29yZS5qc1wiKSk7XG5jb25zdCBhd2FpdF90b19qc18xID0gcmVxdWlyZShcImF3YWl0LXRvLWpzXCIpO1xuY29uc3QgZmlsZV9vcHNfMSA9IHJlcXVpcmUoXCJAamltcC9maWxlLW9wc1wiKTtcbmNvbnN0IGxpdGVfanNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwibWltZS9saXRlLmpzXCIpKTtcbmNvbnN0IGNvbXBvc2l0ZV9qc18xID0gcmVxdWlyZShcIi4vdXRpbHMvY29tcG9zaXRlLmpzXCIpO1xuY29uc3QgaW1hZ2VfYml0bWFwX2pzXzEgPSByZXF1aXJlKFwiLi91dGlscy9pbWFnZS1iaXRtYXAuanNcIik7XG5jb25zdCBlbXB0eUJpdG1hcCA9IHtcbiAgICBkYXRhOiBCdWZmZXIuYWxsb2MoMCksXG4gICAgd2lkdGg6IDAsXG4gICAgaGVpZ2h0OiAwLFxufTtcbi8qKlxuICogUHJlcGFyZSBhIEJ1ZmZlciBvYmplY3QgZnJvbSB0aGUgYXJyYXlCdWZmZXIuXG4gKi9cbmZ1bmN0aW9uIGJ1ZmZlckZyb21BcnJheUJ1ZmZlcihhcnJheUJ1ZmZlcikge1xuICAgIGNvbnN0IGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYyhhcnJheUJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICBjb25zdCB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnVmZmVyLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGJ1ZmZlcltpXSA9IHZpZXdbaV07XG4gICAgfVxuICAgIHJldHVybiBidWZmZXI7XG59XG52YXIgaW1hZ2VfYml0bWFwX2pzXzIgPSByZXF1aXJlKFwiLi91dGlscy9pbWFnZS1iaXRtYXAuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXRFeGlmT3JpZW50YXRpb25cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGltYWdlX2JpdG1hcF9qc18yLmdldEV4aWZPcmllbnRhdGlvbjsgfSB9KTtcbnZhciBjb21wb3NpdGVfanNfMiA9IHJlcXVpcmUoXCIuL3V0aWxzL2NvbXBvc2l0ZS5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNvbXBvc2l0ZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29tcG9zaXRlX2pzXzIuY29tcG9zaXRlOyB9IH0pO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3V0aWxzL2NvbnN0YW50cy5qc1wiKSwgZXhwb3J0cyk7XG4vKipcbiAqIENyZWF0ZSBhIEppbXAgY2xhc3MgdGhhdCBzdXBwb3J0IHRoZSBnaXZlbiBpbWFnZSBmb3JtYXRzIGFuZCBtZXRob2RzXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUppbXAoeyBwbHVnaW5zOiBwbHVnaW5zQXJnLCBmb3JtYXRzOiBmb3JtYXRzQXJnLCB9ID0ge30pIHtcbiAgICBjb25zdCBwbHVnaW5zID0gcGx1Z2luc0FyZyB8fCBbXTtcbiAgICBjb25zdCBmb3JtYXRzID0gKGZvcm1hdHNBcmcgfHwgW10pLm1hcCgoZm9ybWF0KSA9PiBmb3JtYXQoKSk7XG4gICAgY29uc3QgQ3VzdG9tSmltcCA9IGNsYXNzIEppbXAge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGJpdG1hcCBkYXRhIG9mIHRoZSBpbWFnZVxuICAgICAgICAgKi9cbiAgICAgICAgYml0bWFwID0gZW1wdHlCaXRtYXA7XG4gICAgICAgIC8qKiAgRGVmYXVsdCBjb2xvciB0byB1c2UgZm9yIG5ldyBwaXhlbHMgKi9cbiAgICAgICAgYmFja2dyb3VuZCA9IDB4MDAwMDAwMDA7XG4gICAgICAgIC8qKiBGb3JtYXRzIHRoYXQgY2FuIGJlIHVzZWQgd2l0aCBKaW1wICovXG4gICAgICAgIGZvcm1hdHMgPSBbXTtcbiAgICAgICAgLyoqIFRoZSBvcmlnaW5hbCBNSU1FIHR5cGUgb2YgdGhlIGltYWdlICovXG4gICAgICAgIG1pbWU7XG4gICAgICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSBlbXB0eUJpdG1hcCkge1xuICAgICAgICAgICAgLy8gQWRkIHRoZSBmb3JtYXRzXG4gICAgICAgICAgICB0aGlzLmZvcm1hdHMgPSBmb3JtYXRzO1xuICAgICAgICAgICAgaWYgKFwiZGF0YVwiIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJpdG1hcCA9IG9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJpdG1hcCA9IHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogQnVmZmVyLmFsbG9jKG9wdGlvbnMud2lkdGggKiBvcHRpb25zLmhlaWdodCAqIDQpLFxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogb3B0aW9ucy53aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBvcHRpb25zLmhlaWdodCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmNvbG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYmFja2dyb3VuZCA9XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlb2Ygb3B0aW9ucy5jb2xvciA9PT0gXCJzdHJpbmdcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gKDAsIHV0aWxzXzEuY3NzQ29sb3JUb0hleCkob3B0aW9ucy5jb2xvcilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IG9wdGlvbnMuY29sb3I7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5iaXRtYXAuZGF0YS5sZW5ndGg7IGkgKz0gNCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5iaXRtYXAuZGF0YS53cml0ZVVJbnQzMkJFKHRoaXMuYmFja2dyb3VuZCwgaSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBZGQgdGhlIHBsdWdpbnNcbiAgICAgICAgICAgIGZvciAoY29uc3QgbWV0aG9kcyBvZiBwbHVnaW5zKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gbWV0aG9kcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzW2tleV0gPSAoLi4uYXJncykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gbWV0aG9kc1trZXldPy4odGhpcywgLi4uYXJncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHJlc3VsdCA9PT0gXCJvYmplY3RcIiAmJiBcImJpdG1hcFwiIGluIHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYml0bWFwID0gcmVzdWx0LmJpdG1hcDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGUgYSBKaW1wIGluc3RhbmNlIGZyb20gYSBVUkwsIGEgZmlsZSBwYXRoLCBvciBhIEJ1ZmZlclxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBgYGB0c1xuICAgICAgICAgKiBpbXBvcnQgeyBKaW1wIH0gZnJvbSBcImppbXBcIjtcbiAgICAgICAgICpcbiAgICAgICAgICogLy8gUmVhZCBmcm9tIGEgZmlsZSBwYXRoXG4gICAgICAgICAqIGNvbnN0IGltYWdlID0gYXdhaXQgSmltcC5yZWFkKFwidGVzdC9pbWFnZS5wbmdcIik7XG4gICAgICAgICAqXG4gICAgICAgICAqIC8vIFJlYWQgZnJvbSBhIFVSTFxuICAgICAgICAgKiBjb25zdCBpbWFnZSA9IGF3YWl0IEppbXAucmVhZChcImh0dHBzOi8vdXBsb2FkLndpa2ltZWRpYS5vcmcvd2lraXBlZGlhL2NvbW1vbnMvMC8wMS9Cb3QtVGVzdC5qcGdcIik7XG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGFzeW5jIHJlYWQodXJsLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKHVybCkgfHwgdXJsIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5mcm9tQnVmZmVyKHVybCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKDAsIGZpbGVfb3BzXzEuZXhpc3RzU3luYykodXJsKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZyb21CdWZmZXIoYXdhaXQgKDAsIGZpbGVfb3BzXzEucmVhZEZpbGUpKHVybCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgW2ZldGNoRXJyLCByZXNwb25zZV0gPSBhd2FpdCAoMCwgYXdhaXRfdG9fanNfMS50bykoZmV0Y2godXJsKSk7XG4gICAgICAgICAgICBpZiAoZmV0Y2hFcnIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBsb2FkIEJ1ZmZlciBmcm9tIFVSTDogJHt1cmx9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBIVFRQIFN0YXR1cyAke3Jlc3BvbnNlLnN0YXR1c30gZm9yIHVybCAke3VybH1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IFthcnJheUJ1ZmZlckVyciwgZGF0YV0gPSBhd2FpdCAoMCwgYXdhaXRfdG9fanNfMS50bykocmVzcG9uc2UuYXJyYXlCdWZmZXIoKSk7XG4gICAgICAgICAgICBpZiAoYXJyYXlCdWZmZXJFcnIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBsb2FkIEJ1ZmZlciBmcm9tICR7dXJsfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYnVmZmVyID0gYnVmZmVyRnJvbUFycmF5QnVmZmVyKGRhdGEpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZnJvbUJ1ZmZlcihidWZmZXIsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGUgYSBKaW1wIGluc3RhbmNlIGZyb20gYSBiaXRtYXAuXG4gICAgICAgICAqIFRoZSBkaWZmZXJlbmNlIGJldHdlZW4gdGhpcyBhbmQganVzdCB1c2luZyB0aGUgY29uc3RydWN0b3IgaXMgdGhhdCB0aGlzIHdpbGxcbiAgICAgICAgICogY29udmVydCByYXcgaW1hZ2UgZGF0YSBpbnRvIHRoZSBiaXRtYXAgZm9ybWF0IHRoYXQgSmltcCB1c2VzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBgYGB0c1xuICAgICAgICAgKiBpbXBvcnQgeyBKaW1wIH0gZnJvbSBcImppbXBcIjtcbiAgICAgICAgICpcbiAgICAgICAgICogY29uc3QgaW1hZ2UgPSBKaW1wLmZyb21CaXRtYXAoe1xuICAgICAgICAgKiAgIGRhdGE6IEJ1ZmZlci5mcm9tKFtcbiAgICAgICAgICogICAgIDB4ZmZmZmZmZmYsIDB4ZmZmZmZmZmYsIDB4ZmZmZmZmZmYsXG4gICAgICAgICAqICAgICAweGZmZmZmZmZmLCAweGZmZmZmZmZmLCAweGZmZmZmZmZmLFxuICAgICAgICAgKiAgICAgMHhmZmZmZmZmZiwgMHhmZmZmZmZmZiwgMHhmZmZmZmZmZixcbiAgICAgICAgICogICBdKSxcbiAgICAgICAgICogICB3aWR0aDogMyxcbiAgICAgICAgICogICBoZWlnaHQ6IDMsXG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKiBgYGBcbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBmcm9tQml0bWFwKGJpdG1hcCkge1xuICAgICAgICAgICAgbGV0IGRhdGE7XG4gICAgICAgICAgICBpZiAoYml0bWFwLmRhdGEgaW5zdGFuY2VvZiBCdWZmZXIpIHtcbiAgICAgICAgICAgICAgICBkYXRhID0gQnVmZmVyLmZyb20oYml0bWFwLmRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGJpdG1hcC5kYXRhIGluc3RhbmNlb2YgVWludDhBcnJheSB8fFxuICAgICAgICAgICAgICAgIGJpdG1hcC5kYXRhIGluc3RhbmNlb2YgVWludDhDbGFtcGVkQXJyYXkpIHtcbiAgICAgICAgICAgICAgICBkYXRhID0gQnVmZmVyLmZyb20oYml0bWFwLmRhdGEuYnVmZmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGJpdG1hcC5kYXRhKSkge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBCdWZmZXIuY29uY2F0KGJpdG1hcC5kYXRhLm1hcCgoaGV4KSA9PiBCdWZmZXIuZnJvbShoZXgudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDgsIFwiMFwiKSwgXCJoZXhcIikpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImRhdGEgbXVzdCBiZSBhIEJ1ZmZlclwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgYml0bWFwLmhlaWdodCAhPT0gXCJudW1iZXJcIiB8fFxuICAgICAgICAgICAgICAgIHR5cGVvZiBiaXRtYXAud2lkdGggIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJiaXRtYXAgbXVzdCBoYXZlIHdpZHRoIGFuZCBoZWlnaHRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IEN1c3RvbUppbXAoe1xuICAgICAgICAgICAgICAgIGhlaWdodDogYml0bWFwLmhlaWdodCxcbiAgICAgICAgICAgICAgICB3aWR0aDogYml0bWFwLndpZHRoLFxuICAgICAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogUGFyc2UgYSBiaXRtYXAgd2l0aCB0aGUgbG9hZGVkIGltYWdlIHR5cGVzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gYnVmZmVyIFJhdyBpbWFnZSBkYXRhXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIGBgYHRzXG4gICAgICAgICAqIGltcG9ydCB7IEppbXAgfSBmcm9tIFwiamltcFwiO1xuICAgICAgICAgKlxuICAgICAgICAgKiBjb25zdCBidWZmZXIgPSBhd2FpdCBmcy5yZWFkRmlsZShcInRlc3QvaW1hZ2UucG5nXCIpO1xuICAgICAgICAgKiBjb25zdCBpbWFnZSA9IGF3YWl0IEppbXAuZnJvbUJ1ZmZlcihidWZmZXIpO1xuICAgICAgICAgKiBgYGBcbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBhc3luYyBmcm9tQnVmZmVyKGJ1ZmZlciwgb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgYWN0dWFsQnVmZmVyID0gYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgPyBidWZmZXJGcm9tQXJyYXlCdWZmZXIoYnVmZmVyKSA6IGJ1ZmZlcjtcbiAgICAgICAgICAgIGNvbnN0IG1pbWUgPSBhd2FpdCBjb3JlX2pzXzEuZGVmYXVsdC5mcm9tQnVmZmVyKGFjdHVhbEJ1ZmZlcik7XG4gICAgICAgICAgICBpZiAoIW1pbWUgfHwgIW1pbWUubWltZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBmaW5kIE1JTUUgZm9yIEJ1ZmZlclwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGZvcm1hdCA9IGZvcm1hdHMuZmluZCgoZm9ybWF0KSA9PiBmb3JtYXQubWltZSA9PT0gbWltZS5taW1lKTtcbiAgICAgICAgICAgIGlmICghZm9ybWF0IHx8ICFmb3JtYXQuZGVjb2RlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBNaW1lIHR5cGUgJHttaW1lLm1pbWV9IGRvZXMgbm90IHN1cHBvcnQgZGVjb2RpbmdgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGltYWdlID0gbmV3IEN1c3RvbUppbXAoYXdhaXQgZm9ybWF0LmRlY29kZShhY3R1YWxCdWZmZXIsIG9wdGlvbnM/Lltmb3JtYXQubWltZV0pKTtcbiAgICAgICAgICAgIGltYWdlLm1pbWUgPSBtaW1lLm1pbWU7XG4gICAgICAgICAgICAoMCwgaW1hZ2VfYml0bWFwX2pzXzEuYXR0ZW1wdEV4aWZSb3RhdGUpKGltYWdlLCBhY3R1YWxCdWZmZXIpO1xuICAgICAgICAgICAgcmV0dXJuIGltYWdlO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOaWNlbHkgZm9ybWF0IEppbXAgb2JqZWN0IHdoZW4gc2VudCB0byB0aGUgY29uc29sZSBlLmcuIGNvbnNvbGUubG9nKGltYWdlKVxuICAgICAgICAgKiBAcmV0dXJucyBQcmV0dHkgcHJpbnRlZCBqaW1wIG9iamVjdFxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBgYGB0c1xuICAgICAgICAgKiBpbXBvcnQgeyBKaW1wIH0gZnJvbSBcImppbXBcIjtcbiAgICAgICAgICpcbiAgICAgICAgICogY29uc3QgaW1hZ2UgPSBhd2FpdCBKaW1wLnJlYWQoXCJ0ZXN0L2ltYWdlLnBuZ1wiKTtcbiAgICAgICAgICpcbiAgICAgICAgICogY29uc29sZS5sb2coaW1hZ2UpO1xuICAgICAgICAgKiBgYGBcbiAgICAgICAgICovXG4gICAgICAgIGluc3BlY3QoKSB7XG4gICAgICAgICAgICByZXR1cm4gKFwiPEppbXAgXCIgK1xuICAgICAgICAgICAgICAgICh0aGlzLmJpdG1hcCA9PT0gZW1wdHlCaXRtYXBcbiAgICAgICAgICAgICAgICAgICAgPyBcInBlbmRpbmcuLi5cIlxuICAgICAgICAgICAgICAgICAgICA6IHRoaXMuYml0bWFwLndpZHRoICsgXCJ4XCIgKyB0aGlzLmJpdG1hcC5oZWlnaHQpICtcbiAgICAgICAgICAgICAgICBcIj5cIik7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE5pY2VseSBmb3JtYXQgSmltcCBvYmplY3Qgd2hlbiBjb252ZXJ0ZWQgdG8gYSBzdHJpbmdcbiAgICAgICAgICogQHJldHVybnMgcHJldHR5IHByaW50ZWRcbiAgICAgICAgICovXG4gICAgICAgIHRvU3RyaW5nKCkge1xuICAgICAgICAgICAgcmV0dXJuIFwiW29iamVjdCBKaW1wXVwiO1xuICAgICAgICB9XG4gICAgICAgIC8qKiBHZXQgdGhlIHdpZHRoIG9mIHRoZSBpbWFnZSAqL1xuICAgICAgICBnZXQgd2lkdGgoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5iaXRtYXAud2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgLyoqIEdldCB0aGUgaGVpZ2h0IG9mIHRoZSBpbWFnZSAqL1xuICAgICAgICBnZXQgaGVpZ2h0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYml0bWFwLmhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQ29udmVydHMgdGhlIEppbXAgaW5zdGFuY2UgdG8gYW4gaW1hZ2UgYnVmZmVyXG4gICAgICAgICAqIEBwYXJhbSBtaW1lIFRoZSBtaW1lIHR5cGUgdG8gZXhwb3J0IHRvXG4gICAgICAgICAqIEBwYXJhbSBvcHRpb25zIFRoZSBvcHRpb25zIHRvIHVzZSB3aGVuIGV4cG9ydGluZ1xuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBgYGB0c1xuICAgICAgICAgKiBpbXBvcnQgeyBKaW1wIH0gZnJvbSBcImppbXBcIjtcbiAgICAgICAgICogaW1wb3J0IHsgcHJvbWlzZXMgYXMgZnMgfSBmcm9tIFwiZnNcIjtcbiAgICAgICAgICpcbiAgICAgICAgICogY29uc3QgaW1hZ2UgPSBuZXcgSmltcCh7IHdpZHRoOiAzLCBoZWlnaHQ6IDMsIGNvbG9yOiAweGZmZmZmZmZmIH0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiBhd2FpdCBpbWFnZS53cml0ZShcInRlc3Qvb3V0cHV0LmpwZWdcIiwge1xuICAgICAgICAgKiAgIHF1YWxpdHk6IDUwLFxuICAgICAgICAgKiB9KTtcbiAgICAgICAgICogYGBgXG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyBnZXRCdWZmZXIobWltZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgZm9ybWF0ID0gdGhpcy5mb3JtYXRzLmZpbmQoKGZvcm1hdCkgPT4gZm9ybWF0Lm1pbWUgPT09IG1pbWUpO1xuICAgICAgICAgICAgaWYgKCFmb3JtYXQgfHwgIWZvcm1hdC5lbmNvZGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIE1JTUUgdHlwZTogJHttaW1lfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IG91dHB1dEltYWdlO1xuICAgICAgICAgICAgaWYgKGZvcm1hdC5oYXNBbHBoYSkge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdGhpcy1hbGlhc1xuICAgICAgICAgICAgICAgIG91dHB1dEltYWdlID0gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG91dHB1dEltYWdlID0gbmV3IEN1c3RvbUppbXAoe1xuICAgICAgICAgICAgICAgICAgICB3aWR0aDogdGhpcy5iaXRtYXAud2lkdGgsXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogdGhpcy5iaXRtYXAuaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICBjb2xvcjogdGhpcy5iYWNrZ3JvdW5kLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICgwLCBjb21wb3NpdGVfanNfMS5jb21wb3NpdGUpKG91dHB1dEltYWdlLCB0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmb3JtYXQuZW5jb2RlKG91dHB1dEltYWdlLmJpdG1hcCwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnZlcnRzIHRoZSBpbWFnZSB0byBhIGJhc2UgNjQgc3RyaW5nXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBtaW1lIFRoZSBtaW1lIHR5cGUgdG8gZXhwb3J0IHRvXG4gICAgICAgICAqIEBwYXJhbSBvcHRpb25zIFRoZSBvcHRpb25zIHRvIHVzZSB3aGVuIGV4cG9ydGluZ1xuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBgYGB0c1xuICAgICAgICAgKiBpbXBvcnQgeyBKaW1wIH0gZnJvbSBcImppbXBcIjtcbiAgICAgICAgICpcbiAgICAgICAgICogY29uc3QgaW1hZ2UgPSBKaW1wLmZyb21CdWZmZXIoQnVmZmVyLmZyb20oW1xuICAgICAgICAgKiAgIDB4ZmYsIDB4MDAsIDB4MDAsIDB4MDAsIDB4ZmYsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAgICAqICAgMHhmZiwgMHgwMCwgMHgwMCwgMHgwMCwgMHhmZiwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgICAgICogICAweGZmLCAweDAwLCAweDAwLCAweDAwLCAweGZmLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgICAgKiBdKSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIGNvbnN0IGJhc2U2NCA9IGltYWdlLmdldEJhc2U2NChcImltYWdlL2pwZWdcIiwge1xuICAgICAgICAgKiAgIHF1YWxpdHk6IDUwLFxuICAgICAgICAgKiB9KTtcbiAgICAgICAgICogYGBgXG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyBnZXRCYXNlNjQobWltZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHRoaXMuZ2V0QnVmZmVyKG1pbWUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgcmV0dXJuIFwiZGF0YTpcIiArIG1pbWUgKyBcIjtiYXNlNjQsXCIgKyBkYXRhLnRvU3RyaW5nKFwiYmFzZTY0XCIpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXcml0ZSB0aGUgaW1hZ2UgdG8gYSBmaWxlXG4gICAgICAgICAqIEBwYXJhbSBwYXRoIHRoZSBwYXRoIHRvIHdyaXRlIHRoZSBpbWFnZSB0b1xuICAgICAgICAgKiBAcGFyYW0gb3B0aW9ucyB0aGUgb3B0aW9ucyB0byB1c2Ugd2hlbiB3cml0aW5nIHRoZSBpbWFnZVxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBgYGB0c1xuICAgICAgICAgKiBpbXBvcnQgeyBKaW1wIH0gZnJvbSBcImppbXBcIjtcbiAgICAgICAgICpcbiAgICAgICAgICogY29uc3QgaW1hZ2UgPSBKaW1wLmZyb21CdWZmZXIoQnVmZmVyLmZyb20oW1xuICAgICAgICAgKiAgIDB4ZmYsIDB4MDAsIDB4MDAsIDB4MDAsIDB4ZmYsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAgICAqICAgMHhmZiwgMHgwMCwgMHgwMCwgMHgwMCwgMHhmZiwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgICAgICogICAweGZmLCAweDAwLCAweDAwLCAweDAwLCAweGZmLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgICAgKiBdKSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIGF3YWl0IGltYWdlLndyaXRlKFwidGVzdC9vdXRwdXQucG5nXCIpO1xuICAgICAgICAgKiBgYGBcbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIHdyaXRlKHBhdGgsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IG1pbWVUeXBlID0gbGl0ZV9qc18xLmRlZmF1bHQuZ2V0VHlwZShwYXRoKTtcbiAgICAgICAgICAgIGF3YWl0ICgwLCBmaWxlX29wc18xLndyaXRlRmlsZSkocGF0aCwgYXdhaXQgdGhpcy5nZXRCdWZmZXIobWltZVR5cGUsIG9wdGlvbnMpKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQ2xvbmUgdGhlIGltYWdlIGludG8gYSBuZXcgSmltcCBpbnN0YW5jZS5cbiAgICAgICAgICogQHBhcmFtIHRoaXNcbiAgICAgICAgICogQHJldHVybnMgQSBuZXcgSmltcCBpbnN0YW5jZVxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBgYGB0c1xuICAgICAgICAgKiBpbXBvcnQgeyBKaW1wIH0gZnJvbSBcImppbXBcIjtcbiAgICAgICAgICpcbiAgICAgICAgICogY29uc3QgaW1hZ2UgPSBuZXcgSmltcCh7IHdpZHRoOiAzLCBoZWlnaHQ6IDMsIGNvbG9yOiAweGZmZmZmZmZmIH0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiBjb25zdCBjbG9uZSA9IGltYWdlLmNsb25lKCk7XG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKi9cbiAgICAgICAgY2xvbmUoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEN1c3RvbUppbXAoe1xuICAgICAgICAgICAgICAgIC4uLnRoaXMuYml0bWFwLFxuICAgICAgICAgICAgICAgIGRhdGE6IEJ1ZmZlci5mcm9tKHRoaXMuYml0bWFwLmRhdGEpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIG9mZnNldCBvZiBhIHBpeGVsIGluIHRoZSBiaXRtYXAgYnVmZmVyXG4gICAgICAgICAqIEBwYXJhbSB4IHRoZSB4IGNvb3JkaW5hdGVcbiAgICAgICAgICogQHBhcmFtIHkgdGhlIHkgY29vcmRpbmF0ZVxuICAgICAgICAgKiBAcGFyYW0gZWRnZUhhbmRsaW5nIChvcHRpb25hbCkgZGVmaW5lIGhvdyB0byBzdW0gcGl4ZWxzIGZyb20gb3V0c2lkZSB0aGUgYm9yZGVyXG4gICAgICAgICAqIEByZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgcGl4ZWwgb3IgLTEgaWYgbm90IGZvdW5kXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIGBgYHRzXG4gICAgICAgICAqIGltcG9ydCB7IEppbXAgfSBmcm9tIFwiamltcFwiO1xuICAgICAgICAgKlxuICAgICAgICAgKiBjb25zdCBpbWFnZSA9IG5ldyBKaW1wKHsgd2lkdGg6IDMsIGhlaWdodDogMywgY29sb3I6IDB4ZmZmZmZmZmYgfSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIGltYWdlLmdldFBpeGVsSW5kZXgoMSwgMSk7IC8vIDJcbiAgICAgICAgICogYGBgXG4gICAgICAgICAqL1xuICAgICAgICBnZXRQaXhlbEluZGV4KHgsIHksIGVkZ2VIYW5kbGluZykge1xuICAgICAgICAgICAgbGV0IHhpO1xuICAgICAgICAgICAgbGV0IHlpO1xuICAgICAgICAgICAgaWYgKCFlZGdlSGFuZGxpbmcpIHtcbiAgICAgICAgICAgICAgICBlZGdlSGFuZGxpbmcgPSB0eXBlc18xLkVkZ2UuRVhURU5EO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiB4ICE9PSBcIm51bWJlclwiIHx8IHR5cGVvZiB5ICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwieCBhbmQgeSBtdXN0IGJlIG51bWJlcnNcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyByb3VuZCBpbnB1dFxuICAgICAgICAgICAgeCA9IE1hdGgucm91bmQoeCk7XG4gICAgICAgICAgICB5ID0gTWF0aC5yb3VuZCh5KTtcbiAgICAgICAgICAgIHhpID0geDtcbiAgICAgICAgICAgIHlpID0geTtcbiAgICAgICAgICAgIGlmIChlZGdlSGFuZGxpbmcgPT09IHR5cGVzXzEuRWRnZS5FWFRFTkQpIHtcbiAgICAgICAgICAgICAgICBpZiAoeCA8IDApXG4gICAgICAgICAgICAgICAgICAgIHhpID0gMDtcbiAgICAgICAgICAgICAgICBpZiAoeCA+PSB0aGlzLmJpdG1hcC53aWR0aClcbiAgICAgICAgICAgICAgICAgICAgeGkgPSB0aGlzLmJpdG1hcC53aWR0aCAtIDE7XG4gICAgICAgICAgICAgICAgaWYgKHkgPCAwKVxuICAgICAgICAgICAgICAgICAgICB5aSA9IDA7XG4gICAgICAgICAgICAgICAgaWYgKHkgPj0gdGhpcy5iaXRtYXAuaGVpZ2h0KVxuICAgICAgICAgICAgICAgICAgICB5aSA9IHRoaXMuYml0bWFwLmhlaWdodCAtIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZWRnZUhhbmRsaW5nID09PSB0eXBlc18xLkVkZ2UuV1JBUCkge1xuICAgICAgICAgICAgICAgIGlmICh4IDwgMCkge1xuICAgICAgICAgICAgICAgICAgICB4aSA9IHRoaXMuYml0bWFwLndpZHRoICsgeDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHggPj0gdGhpcy5iaXRtYXAud2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgeGkgPSB4ICUgdGhpcy5iaXRtYXAud2lkdGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh5IDwgMCkge1xuICAgICAgICAgICAgICAgICAgICB5aSA9IHRoaXMuYml0bWFwLmhlaWdodCArIHk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh5ID49IHRoaXMuYml0bWFwLmhlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICB5aSA9IHkgJSB0aGlzLmJpdG1hcC5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGkgPSAodGhpcy5iaXRtYXAud2lkdGggKiB5aSArIHhpKSA8PCAyO1xuICAgICAgICAgICAgLy8gaWYgb3V0IG9mIGJvdW5kcyBpbmRleCBpcyAtMVxuICAgICAgICAgICAgaWYgKHhpIDwgMCB8fCB4aSA+PSB0aGlzLmJpdG1hcC53aWR0aCkge1xuICAgICAgICAgICAgICAgIGkgPSAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh5aSA8IDAgfHwgeWkgPj0gdGhpcy5iaXRtYXAuaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgaSA9IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIGhleCBjb2xvciB2YWx1ZSBvZiBhIHBpeGVsXG4gICAgICAgICAqIEBwYXJhbSB4IHRoZSB4IGNvb3JkaW5hdGVcbiAgICAgICAgICogQHBhcmFtIHkgdGhlIHkgY29vcmRpbmF0ZVxuICAgICAgICAgKiBAcmV0dXJucyB0aGUgY29sb3Igb2YgdGhlIHBpeGVsXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIGBgYHRzXG4gICAgICAgICAqIGltcG9ydCB7IEppbXAgfSBmcm9tIFwiamltcFwiO1xuICAgICAgICAgKlxuICAgICAgICAgKiBjb25zdCBpbWFnZSA9IG5ldyBKaW1wKHsgd2lkdGg6IDMsIGhlaWdodDogMywgY29sb3I6IDB4ZmZmZmZmZmYgfSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIGltYWdlLmdldFBpeGVsQ29sb3IoMSwgMSk7IC8vIDB4ZmZmZmZmZmZcbiAgICAgICAgICogYGBgXG4gICAgICAgICAqL1xuICAgICAgICBnZXRQaXhlbENvbG9yKHgsIHkpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgeCAhPT0gXCJudW1iZXJcIiB8fCB0eXBlb2YgeSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInggYW5kIHkgbXVzdCBiZSBudW1iZXJzXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaWR4ID0gdGhpcy5nZXRQaXhlbEluZGV4KHgsIHkpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYml0bWFwLmRhdGEucmVhZFVJbnQzMkJFKGlkeCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgdGhlIGhleCBjb2xvdXIgdmFsdWUgb2YgYSBwaXhlbFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gaGV4IGNvbG9yIHRvIHNldFxuICAgICAgICAgKiBAcGFyYW0geCB0aGUgeCBjb29yZGluYXRlXG4gICAgICAgICAqIEBwYXJhbSB5IHRoZSB5IGNvb3JkaW5hdGVcbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogYGBgdHNcbiAgICAgICAgICogaW1wb3J0IHsgSmltcCB9IGZyb20gXCJqaW1wXCI7XG4gICAgICAgICAqXG4gICAgICAgICAqIGNvbnN0IGltYWdlID0gbmV3IEppbXAoeyB3aWR0aDogMywgaGVpZ2h0OiAzLCBjb2xvcjogMHhmZmZmZmZmZiB9KTtcbiAgICAgICAgICpcbiAgICAgICAgICogaW1hZ2Uuc2V0UGl4ZWxDb2xvcigweGZmMDAwMGZmLCAwLCAwKTtcbiAgICAgICAgICogYGBgXG4gICAgICAgICAqL1xuICAgICAgICBzZXRQaXhlbENvbG9yKGhleCwgeCwgeSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBoZXggIT09IFwibnVtYmVyXCIgfHxcbiAgICAgICAgICAgICAgICB0eXBlb2YgeCAhPT0gXCJudW1iZXJcIiB8fFxuICAgICAgICAgICAgICAgIHR5cGVvZiB5ICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaGV4LCB4IGFuZCB5IG11c3QgYmUgbnVtYmVyc1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGlkeCA9IHRoaXMuZ2V0UGl4ZWxJbmRleCh4LCB5KTtcbiAgICAgICAgICAgIHRoaXMuYml0bWFwLmRhdGEud3JpdGVVSW50MzJCRShoZXgsIGlkeCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogRGV0ZXJtaW5lIGlmIHRoZSBpbWFnZSBjb250YWlucyBvcGFxdWUgcGl4ZWxzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBgYGB0c1xuICAgICAgICAgKiBpbXBvcnQgeyBKaW1wIH0gZnJvbSBcImppbXBcIjtcbiAgICAgICAgICpcbiAgICAgICAgICogY29uc3QgaW1hZ2UgPSBuZXcgSmltcCh7IHdpZHRoOiAzLCBoZWlnaHQ6IDMsIGNvbG9yOiAweGZmZmZmZmFhIH0pO1xuICAgICAgICAgKiBjb25zdCBpbWFnZTIgPSBuZXcgSmltcCh7IHdpZHRoOiAzLCBoZWlnaHQ6IDMsIGNvbG9yOiAweGZmMDAwMGZmIH0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiBpbWFnZS5oYXNBbHBoYSgpOyAvLyBmYWxzZVxuICAgICAgICAgKiBpbWFnZTIuaGFzQWxwaGEoKTsgLy8gdHJ1ZVxuICAgICAgICAgKiBgYGBcbiAgICAgICAgICovXG4gICAgICAgIGhhc0FscGhhKCkge1xuICAgICAgICAgICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0LCBkYXRhIH0gPSB0aGlzLmJpdG1hcDtcbiAgICAgICAgICAgIGNvbnN0IGJ5dGVMZW4gPSAod2lkdGggKiBoZWlnaHQpIDw8IDI7XG4gICAgICAgICAgICBmb3IgKGxldCBpZHggPSAzOyBpZHggPCBieXRlTGVuOyBpZHggKz0gNCkge1xuICAgICAgICAgICAgICAgIGlmIChkYXRhW2lkeF0gIT09IDB4ZmYpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb21wb3NpdGVzIGEgc291cmNlIGltYWdlIG92ZXIgdG8gdGhpcyBpbWFnZSByZXNwZWN0aW5nIGFscGhhIGNoYW5uZWxzXG4gICAgICAgICAqIEBwYXJhbSBzcmMgdGhlIHNvdXJjZSBKaW1wIGluc3RhbmNlXG4gICAgICAgICAqIEBwYXJhbSB4IHRoZSB4IHBvc2l0aW9uIHRvIGJsaXQgdGhlIGltYWdlXG4gICAgICAgICAqIEBwYXJhbSB5IHRoZSB5IHBvc2l0aW9uIHRvIGJsaXQgdGhlIGltYWdlXG4gICAgICAgICAqIEBwYXJhbSBvcHRpb25zIGRldGVybWluZSB3aGF0IG1vZGUgdG8gdXNlXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIGBgYHRzXG4gICAgICAgICAqIGltcG9ydCB7IEppbXAgfSBmcm9tIFwiamltcFwiO1xuICAgICAgICAgKlxuICAgICAgICAgKiBjb25zdCBpbWFnZSA9IG5ldyBKaW1wKHsgd2lkdGg6IDEwLCBoZWlnaHQ6IDEwLCBjb2xvcjogMHhmZmZmZmZmZiB9KTtcbiAgICAgICAgICogY29uc3QgaW1hZ2UyID0gbmV3IEppbXAoeyB3aWR0aDogMywgaGVpZ2h0OiAzLCBjb2xvcjogMHhmZjAwMDBmZiB9KTtcbiAgICAgICAgICpcbiAgICAgICAgICogaW1hZ2UuY29tcG9zaXRlKGltYWdlMiwgMywgMyk7XG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKi9cbiAgICAgICAgY29tcG9zaXRlKHNyYywgeCA9IDAsIHkgPSAwLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgICAgIHJldHVybiAoMCwgY29tcG9zaXRlX2pzXzEuY29tcG9zaXRlKSh0aGlzLCBzcmMsIHgsIHksIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIHNjYW4oeCwgeSwgdywgaCwgZikge1xuICAgICAgICAgICAgcmV0dXJuICgwLCB1dGlsc18xLnNjYW4pKHRoaXMsIHgsIHksIHcsIGgsIGYpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJdGVyYXRlIHNjYW4gdGhyb3VnaCBhIHJlZ2lvbiBvZiB0aGUgYml0bWFwXG4gICAgICAgICAqIEBwYXJhbSB4IHRoZSB4IGNvb3JkaW5hdGUgdG8gYmVnaW4gdGhlIHNjYW4gYXRcbiAgICAgICAgICogQHBhcmFtIHkgdGhlIHkgY29vcmRpbmF0ZSB0byBiZWdpbiB0aGUgc2NhbiBhdFxuICAgICAgICAgKiBAcGFyYW0gdyB0aGUgd2lkdGggb2YgdGhlIHNjYW4gcmVnaW9uXG4gICAgICAgICAqIEBwYXJhbSBoIHRoZSBoZWlnaHQgb2YgdGhlIHNjYW4gcmVnaW9uXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIGBgYHRzXG4gICAgICAgICAqIGltcG9ydCB7IEppbXAgfSBmcm9tIFwiamltcFwiO1xuICAgICAgICAgKlxuICAgICAgICAgKiBjb25zdCBpbWFnZSA9IG5ldyBKaW1wKHsgd2lkdGg6IDMsIGhlaWdodDogMywgY29sb3I6IDB4ZmZmZmZmZmYgfSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIGZvciAoY29uc3QgeyB4LCB5LCBpZHgsIGltYWdlIH0gb2Ygai5zY2FuSXRlcmF0b3IoKSkge1xuICAgICAgICAgKiAgIC8vIGRvIHNvbWV0aGluZyB3aXRoIHRoZSBwaXhlbFxuICAgICAgICAgKiB9XG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKi9cbiAgICAgICAgc2Nhbkl0ZXJhdG9yKHggPSAwLCB5ID0gMCwgdyA9IHRoaXMuYml0bWFwLndpZHRoLCBoID0gdGhpcy5iaXRtYXAuaGVpZ2h0KSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHggIT09IFwibnVtYmVyXCIgfHwgdHlwZW9mIHkgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ4IGFuZCB5IG11c3QgYmUgbnVtYmVyc1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdyAhPT0gXCJudW1iZXJcIiB8fCB0eXBlb2YgaCAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIncgYW5kIGggbXVzdCBiZSBudW1iZXJzXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICgwLCB1dGlsc18xLnNjYW5JdGVyYXRvcikodGhpcywgeCwgeSwgdywgaCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBDdXN0b21KaW1wO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@jimp+core@1.6.0/node_modules/@jimp/core/dist/commonjs/index.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/@jimp+core@1.6.0/node_modules/@jimp/core/dist/commonjs/utils/composite-modes.js":
/*!****************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@jimp+core@1.6.0/node_modules/@jimp/core/dist/commonjs/utils/composite-modes.js ***!
  \****************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.names = void 0;\nexports.srcOver = srcOver;\nexports.dstOver = dstOver;\nexports.multiply = multiply;\nexports.add = add;\nexports.screen = screen;\nexports.overlay = overlay;\nexports.darken = darken;\nexports.lighten = lighten;\nexports.hardLight = hardLight;\nexports.difference = difference;\nexports.exclusion = exclusion;\nfunction srcOver(src, dst, ops = 1) {\n    src.a *= ops;\n    const a = dst.a + src.a - dst.a * src.a;\n    const r = (src.r * src.a + dst.r * dst.a * (1 - src.a)) / a;\n    const g = (src.g * src.a + dst.g * dst.a * (1 - src.a)) / a;\n    const b = (src.b * src.a + dst.b * dst.a * (1 - src.a)) / a;\n    return { r, g, b, a };\n}\nfunction dstOver(src, dst, ops = 1) {\n    src.a *= ops;\n    const a = dst.a + src.a - dst.a * src.a;\n    const r = (dst.r * dst.a + src.r * src.a * (1 - dst.a)) / a;\n    const g = (dst.g * dst.a + src.g * src.a * (1 - dst.a)) / a;\n    const b = (dst.b * dst.a + src.b * src.a * (1 - dst.a)) / a;\n    return { r, g, b, a };\n}\nfunction multiply(src, dst, ops = 1) {\n    src.a *= ops;\n    const a = dst.a + src.a - dst.a * src.a;\n    const sra = src.r * src.a;\n    const sga = src.g * src.a;\n    const sba = src.b * src.a;\n    const dra = dst.r * dst.a;\n    const dga = dst.g * dst.a;\n    const dba = dst.b * dst.a;\n    const r = (sra * dra + sra * (1 - dst.a) + dra * (1 - src.a)) / a;\n    const g = (sga * dga + sga * (1 - dst.a) + dga * (1 - src.a)) / a;\n    const b = (sba * dba + sba * (1 - dst.a) + dba * (1 - src.a)) / a;\n    return { r, g, b, a };\n}\nfunction add(src, dst, ops = 1) {\n    src.a *= ops;\n    const a = dst.a + src.a - dst.a * src.a;\n    const sra = src.r * src.a;\n    const sga = src.g * src.a;\n    const sba = src.b * src.a;\n    const dra = dst.r * dst.a;\n    const dga = dst.g * dst.a;\n    const dba = dst.b * dst.a;\n    const r = (sra + dra) / a;\n    const g = (sga + dga) / a;\n    const b = (sba + dba) / a;\n    return { r, g, b, a };\n}\nfunction screen(src, dst, ops = 1) {\n    src.a *= ops;\n    const a = dst.a + src.a - dst.a * src.a;\n    const sra = src.r * src.a;\n    const sga = src.g * src.a;\n    const sba = src.b * src.a;\n    const dra = dst.r * dst.a;\n    const dga = dst.g * dst.a;\n    const dba = dst.b * dst.a;\n    const r = (sra * dst.a +\n        dra * src.a -\n        sra * dra +\n        sra * (1 - dst.a) +\n        dra * (1 - src.a)) /\n        a;\n    const g = (sga * dst.a +\n        dga * src.a -\n        sga * dga +\n        sga * (1 - dst.a) +\n        dga * (1 - src.a)) /\n        a;\n    const b = (sba * dst.a +\n        dba * src.a -\n        sba * dba +\n        sba * (1 - dst.a) +\n        dba * (1 - src.a)) /\n        a;\n    return { r, g, b, a };\n}\nfunction overlay(src, dst, ops = 1) {\n    src.a *= ops;\n    const a = dst.a + src.a - dst.a * src.a;\n    const sra = src.r * src.a;\n    const sga = src.g * src.a;\n    const sba = src.b * src.a;\n    const dra = dst.r * dst.a;\n    const dga = dst.g * dst.a;\n    const dba = dst.b * dst.a;\n    const r = (2 * dra <= dst.a\n        ? 2 * sra * dra + sra * (1 - dst.a) + dra * (1 - src.a)\n        : sra * (1 + dst.a) + dra * (1 + src.a) - 2 * dra * sra - dst.a * src.a) /\n        a;\n    const g = (2 * dga <= dst.a\n        ? 2 * sga * dga + sga * (1 - dst.a) + dga * (1 - src.a)\n        : sga * (1 + dst.a) + dga * (1 + src.a) - 2 * dga * sga - dst.a * src.a) /\n        a;\n    const b = (2 * dba <= dst.a\n        ? 2 * sba * dba + sba * (1 - dst.a) + dba * (1 - src.a)\n        : sba * (1 + dst.a) + dba * (1 + src.a) - 2 * dba * sba - dst.a * src.a) /\n        a;\n    return { r, g, b, a };\n}\nfunction darken(src, dst, ops = 1) {\n    src.a *= ops;\n    const a = dst.a + src.a - dst.a * src.a;\n    const sra = src.r * src.a;\n    const sga = src.g * src.a;\n    const sba = src.b * src.a;\n    const dra = dst.r * dst.a;\n    const dga = dst.g * dst.a;\n    const dba = dst.b * dst.a;\n    const r = (Math.min(sra * dst.a, dra * src.a) +\n        sra * (1 - dst.a) +\n        dra * (1 - src.a)) /\n        a;\n    const g = (Math.min(sga * dst.a, dga * src.a) +\n        sga * (1 - dst.a) +\n        dga * (1 - src.a)) /\n        a;\n    const b = (Math.min(sba * dst.a, dba * src.a) +\n        sba * (1 - dst.a) +\n        dba * (1 - src.a)) /\n        a;\n    return { r, g, b, a };\n}\nfunction lighten(src, dst, ops = 1) {\n    src.a *= ops;\n    const a = dst.a + src.a - dst.a * src.a;\n    const sra = src.r * src.a;\n    const sga = src.g * src.a;\n    const sba = src.b * src.a;\n    const dra = dst.r * dst.a;\n    const dga = dst.g * dst.a;\n    const dba = dst.b * dst.a;\n    const r = (Math.max(sra * dst.a, dra * src.a) +\n        sra * (1 - dst.a) +\n        dra * (1 - src.a)) /\n        a;\n    const g = (Math.max(sga * dst.a, dga * src.a) +\n        sga * (1 - dst.a) +\n        dga * (1 - src.a)) /\n        a;\n    const b = (Math.max(sba * dst.a, dba * src.a) +\n        sba * (1 - dst.a) +\n        dba * (1 - src.a)) /\n        a;\n    return { r, g, b, a };\n}\nfunction hardLight(src, dst, ops = 1) {\n    src.a *= ops;\n    const a = dst.a + src.a - dst.a * src.a;\n    const sra = src.r * src.a;\n    const sga = src.g * src.a;\n    const sba = src.b * src.a;\n    const dra = dst.r * dst.a;\n    const dga = dst.g * dst.a;\n    const dba = dst.b * dst.a;\n    const r = (2 * sra <= src.a\n        ? 2 * sra * dra + sra * (1 - dst.a) + dra * (1 - src.a)\n        : sra * (1 + dst.a) + dra * (1 + src.a) - 2 * dra * sra - dst.a * src.a) /\n        a;\n    const g = (2 * sga <= src.a\n        ? 2 * sga * dga + sga * (1 - dst.a) + dga * (1 - src.a)\n        : sga * (1 + dst.a) + dga * (1 + src.a) - 2 * dga * sga - dst.a * src.a) /\n        a;\n    const b = (2 * sba <= src.a\n        ? 2 * sba * dba + sba * (1 - dst.a) + dba * (1 - src.a)\n        : sba * (1 + dst.a) + dba * (1 + src.a) - 2 * dba * sba - dst.a * src.a) /\n        a;\n    return { r, g, b, a };\n}\nfunction difference(src, dst, ops = 1) {\n    src.a *= ops;\n    const a = dst.a + src.a - dst.a * src.a;\n    const sra = src.r * src.a;\n    const sga = src.g * src.a;\n    const sba = src.b * src.a;\n    const dra = dst.r * dst.a;\n    const dga = dst.g * dst.a;\n    const dba = dst.b * dst.a;\n    const r = (sra + dra - 2 * Math.min(sra * dst.a, dra * src.a)) / a;\n    const g = (sga + dga - 2 * Math.min(sga * dst.a, dga * src.a)) / a;\n    const b = (sba + dba - 2 * Math.min(sba * dst.a, dba * src.a)) / a;\n    return { r, g, b, a };\n}\nfunction exclusion(src, dst, ops = 1) {\n    src.a *= ops;\n    const a = dst.a + src.a - dst.a * src.a;\n    const sra = src.r * src.a;\n    const sga = src.g * src.a;\n    const sba = src.b * src.a;\n    const dra = dst.r * dst.a;\n    const dga = dst.g * dst.a;\n    const dba = dst.b * dst.a;\n    const r = (sra * dst.a +\n        dra * src.a -\n        2 * sra * dra +\n        sra * (1 - dst.a) +\n        dra * (1 - src.a)) /\n        a;\n    const g = (sga * dst.a +\n        dga * src.a -\n        2 * sga * dga +\n        sga * (1 - dst.a) +\n        dga * (1 - src.a)) /\n        a;\n    const b = (sba * dst.a +\n        dba * src.a -\n        2 * sba * dba +\n        sba * (1 - dst.a) +\n        dba * (1 - src.a)) /\n        a;\n    return { r, g, b, a };\n}\nexports.names = [\n    srcOver,\n    dstOver,\n    multiply,\n    add,\n    screen,\n    overlay,\n    darken,\n    lighten,\n    hardLight,\n    difference,\n    exclusion,\n];\n//# sourceMappingURL=composite-modes.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BqaW1wK2NvcmVAMS42LjAvbm9kZV9tb2R1bGVzL0BqaW1wL2NvcmUvZGlzdC9jb21tb25qcy91dGlscy9jb21wb3NpdGUtbW9kZXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsYUFBYTtBQUNiLGVBQWU7QUFDZixlQUFlO0FBQ2YsZ0JBQWdCO0FBQ2hCLFdBQVc7QUFDWCxjQUFjO0FBQ2QsZUFBZTtBQUNmLGNBQWM7QUFDZCxlQUFlO0FBQ2YsaUJBQWlCO0FBQ2pCLGtCQUFrQjtBQUNsQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvbWlrZXdlc3RoYWQvRGVza3RvcC9SZXBvcy9zcG9yYWRpYy1sYWJzLXRpbGUtZXh0cnVkZXIvbm9kZV9tb2R1bGVzLy5wbnBtL0BqaW1wK2NvcmVAMS42LjAvbm9kZV9tb2R1bGVzL0BqaW1wL2NvcmUvZGlzdC9jb21tb25qcy91dGlscy9jb21wb3NpdGUtbW9kZXMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLm5hbWVzID0gdm9pZCAwO1xuZXhwb3J0cy5zcmNPdmVyID0gc3JjT3ZlcjtcbmV4cG9ydHMuZHN0T3ZlciA9IGRzdE92ZXI7XG5leHBvcnRzLm11bHRpcGx5ID0gbXVsdGlwbHk7XG5leHBvcnRzLmFkZCA9IGFkZDtcbmV4cG9ydHMuc2NyZWVuID0gc2NyZWVuO1xuZXhwb3J0cy5vdmVybGF5ID0gb3ZlcmxheTtcbmV4cG9ydHMuZGFya2VuID0gZGFya2VuO1xuZXhwb3J0cy5saWdodGVuID0gbGlnaHRlbjtcbmV4cG9ydHMuaGFyZExpZ2h0ID0gaGFyZExpZ2h0O1xuZXhwb3J0cy5kaWZmZXJlbmNlID0gZGlmZmVyZW5jZTtcbmV4cG9ydHMuZXhjbHVzaW9uID0gZXhjbHVzaW9uO1xuZnVuY3Rpb24gc3JjT3ZlcihzcmMsIGRzdCwgb3BzID0gMSkge1xuICAgIHNyYy5hICo9IG9wcztcbiAgICBjb25zdCBhID0gZHN0LmEgKyBzcmMuYSAtIGRzdC5hICogc3JjLmE7XG4gICAgY29uc3QgciA9IChzcmMuciAqIHNyYy5hICsgZHN0LnIgKiBkc3QuYSAqICgxIC0gc3JjLmEpKSAvIGE7XG4gICAgY29uc3QgZyA9IChzcmMuZyAqIHNyYy5hICsgZHN0LmcgKiBkc3QuYSAqICgxIC0gc3JjLmEpKSAvIGE7XG4gICAgY29uc3QgYiA9IChzcmMuYiAqIHNyYy5hICsgZHN0LmIgKiBkc3QuYSAqICgxIC0gc3JjLmEpKSAvIGE7XG4gICAgcmV0dXJuIHsgciwgZywgYiwgYSB9O1xufVxuZnVuY3Rpb24gZHN0T3ZlcihzcmMsIGRzdCwgb3BzID0gMSkge1xuICAgIHNyYy5hICo9IG9wcztcbiAgICBjb25zdCBhID0gZHN0LmEgKyBzcmMuYSAtIGRzdC5hICogc3JjLmE7XG4gICAgY29uc3QgciA9IChkc3QuciAqIGRzdC5hICsgc3JjLnIgKiBzcmMuYSAqICgxIC0gZHN0LmEpKSAvIGE7XG4gICAgY29uc3QgZyA9IChkc3QuZyAqIGRzdC5hICsgc3JjLmcgKiBzcmMuYSAqICgxIC0gZHN0LmEpKSAvIGE7XG4gICAgY29uc3QgYiA9IChkc3QuYiAqIGRzdC5hICsgc3JjLmIgKiBzcmMuYSAqICgxIC0gZHN0LmEpKSAvIGE7XG4gICAgcmV0dXJuIHsgciwgZywgYiwgYSB9O1xufVxuZnVuY3Rpb24gbXVsdGlwbHkoc3JjLCBkc3QsIG9wcyA9IDEpIHtcbiAgICBzcmMuYSAqPSBvcHM7XG4gICAgY29uc3QgYSA9IGRzdC5hICsgc3JjLmEgLSBkc3QuYSAqIHNyYy5hO1xuICAgIGNvbnN0IHNyYSA9IHNyYy5yICogc3JjLmE7XG4gICAgY29uc3Qgc2dhID0gc3JjLmcgKiBzcmMuYTtcbiAgICBjb25zdCBzYmEgPSBzcmMuYiAqIHNyYy5hO1xuICAgIGNvbnN0IGRyYSA9IGRzdC5yICogZHN0LmE7XG4gICAgY29uc3QgZGdhID0gZHN0LmcgKiBkc3QuYTtcbiAgICBjb25zdCBkYmEgPSBkc3QuYiAqIGRzdC5hO1xuICAgIGNvbnN0IHIgPSAoc3JhICogZHJhICsgc3JhICogKDEgLSBkc3QuYSkgKyBkcmEgKiAoMSAtIHNyYy5hKSkgLyBhO1xuICAgIGNvbnN0IGcgPSAoc2dhICogZGdhICsgc2dhICogKDEgLSBkc3QuYSkgKyBkZ2EgKiAoMSAtIHNyYy5hKSkgLyBhO1xuICAgIGNvbnN0IGIgPSAoc2JhICogZGJhICsgc2JhICogKDEgLSBkc3QuYSkgKyBkYmEgKiAoMSAtIHNyYy5hKSkgLyBhO1xuICAgIHJldHVybiB7IHIsIGcsIGIsIGEgfTtcbn1cbmZ1bmN0aW9uIGFkZChzcmMsIGRzdCwgb3BzID0gMSkge1xuICAgIHNyYy5hICo9IG9wcztcbiAgICBjb25zdCBhID0gZHN0LmEgKyBzcmMuYSAtIGRzdC5hICogc3JjLmE7XG4gICAgY29uc3Qgc3JhID0gc3JjLnIgKiBzcmMuYTtcbiAgICBjb25zdCBzZ2EgPSBzcmMuZyAqIHNyYy5hO1xuICAgIGNvbnN0IHNiYSA9IHNyYy5iICogc3JjLmE7XG4gICAgY29uc3QgZHJhID0gZHN0LnIgKiBkc3QuYTtcbiAgICBjb25zdCBkZ2EgPSBkc3QuZyAqIGRzdC5hO1xuICAgIGNvbnN0IGRiYSA9IGRzdC5iICogZHN0LmE7XG4gICAgY29uc3QgciA9IChzcmEgKyBkcmEpIC8gYTtcbiAgICBjb25zdCBnID0gKHNnYSArIGRnYSkgLyBhO1xuICAgIGNvbnN0IGIgPSAoc2JhICsgZGJhKSAvIGE7XG4gICAgcmV0dXJuIHsgciwgZywgYiwgYSB9O1xufVxuZnVuY3Rpb24gc2NyZWVuKHNyYywgZHN0LCBvcHMgPSAxKSB7XG4gICAgc3JjLmEgKj0gb3BzO1xuICAgIGNvbnN0IGEgPSBkc3QuYSArIHNyYy5hIC0gZHN0LmEgKiBzcmMuYTtcbiAgICBjb25zdCBzcmEgPSBzcmMuciAqIHNyYy5hO1xuICAgIGNvbnN0IHNnYSA9IHNyYy5nICogc3JjLmE7XG4gICAgY29uc3Qgc2JhID0gc3JjLmIgKiBzcmMuYTtcbiAgICBjb25zdCBkcmEgPSBkc3QuciAqIGRzdC5hO1xuICAgIGNvbnN0IGRnYSA9IGRzdC5nICogZHN0LmE7XG4gICAgY29uc3QgZGJhID0gZHN0LmIgKiBkc3QuYTtcbiAgICBjb25zdCByID0gKHNyYSAqIGRzdC5hICtcbiAgICAgICAgZHJhICogc3JjLmEgLVxuICAgICAgICBzcmEgKiBkcmEgK1xuICAgICAgICBzcmEgKiAoMSAtIGRzdC5hKSArXG4gICAgICAgIGRyYSAqICgxIC0gc3JjLmEpKSAvXG4gICAgICAgIGE7XG4gICAgY29uc3QgZyA9IChzZ2EgKiBkc3QuYSArXG4gICAgICAgIGRnYSAqIHNyYy5hIC1cbiAgICAgICAgc2dhICogZGdhICtcbiAgICAgICAgc2dhICogKDEgLSBkc3QuYSkgK1xuICAgICAgICBkZ2EgKiAoMSAtIHNyYy5hKSkgL1xuICAgICAgICBhO1xuICAgIGNvbnN0IGIgPSAoc2JhICogZHN0LmEgK1xuICAgICAgICBkYmEgKiBzcmMuYSAtXG4gICAgICAgIHNiYSAqIGRiYSArXG4gICAgICAgIHNiYSAqICgxIC0gZHN0LmEpICtcbiAgICAgICAgZGJhICogKDEgLSBzcmMuYSkpIC9cbiAgICAgICAgYTtcbiAgICByZXR1cm4geyByLCBnLCBiLCBhIH07XG59XG5mdW5jdGlvbiBvdmVybGF5KHNyYywgZHN0LCBvcHMgPSAxKSB7XG4gICAgc3JjLmEgKj0gb3BzO1xuICAgIGNvbnN0IGEgPSBkc3QuYSArIHNyYy5hIC0gZHN0LmEgKiBzcmMuYTtcbiAgICBjb25zdCBzcmEgPSBzcmMuciAqIHNyYy5hO1xuICAgIGNvbnN0IHNnYSA9IHNyYy5nICogc3JjLmE7XG4gICAgY29uc3Qgc2JhID0gc3JjLmIgKiBzcmMuYTtcbiAgICBjb25zdCBkcmEgPSBkc3QuciAqIGRzdC5hO1xuICAgIGNvbnN0IGRnYSA9IGRzdC5nICogZHN0LmE7XG4gICAgY29uc3QgZGJhID0gZHN0LmIgKiBkc3QuYTtcbiAgICBjb25zdCByID0gKDIgKiBkcmEgPD0gZHN0LmFcbiAgICAgICAgPyAyICogc3JhICogZHJhICsgc3JhICogKDEgLSBkc3QuYSkgKyBkcmEgKiAoMSAtIHNyYy5hKVxuICAgICAgICA6IHNyYSAqICgxICsgZHN0LmEpICsgZHJhICogKDEgKyBzcmMuYSkgLSAyICogZHJhICogc3JhIC0gZHN0LmEgKiBzcmMuYSkgL1xuICAgICAgICBhO1xuICAgIGNvbnN0IGcgPSAoMiAqIGRnYSA8PSBkc3QuYVxuICAgICAgICA/IDIgKiBzZ2EgKiBkZ2EgKyBzZ2EgKiAoMSAtIGRzdC5hKSArIGRnYSAqICgxIC0gc3JjLmEpXG4gICAgICAgIDogc2dhICogKDEgKyBkc3QuYSkgKyBkZ2EgKiAoMSArIHNyYy5hKSAtIDIgKiBkZ2EgKiBzZ2EgLSBkc3QuYSAqIHNyYy5hKSAvXG4gICAgICAgIGE7XG4gICAgY29uc3QgYiA9ICgyICogZGJhIDw9IGRzdC5hXG4gICAgICAgID8gMiAqIHNiYSAqIGRiYSArIHNiYSAqICgxIC0gZHN0LmEpICsgZGJhICogKDEgLSBzcmMuYSlcbiAgICAgICAgOiBzYmEgKiAoMSArIGRzdC5hKSArIGRiYSAqICgxICsgc3JjLmEpIC0gMiAqIGRiYSAqIHNiYSAtIGRzdC5hICogc3JjLmEpIC9cbiAgICAgICAgYTtcbiAgICByZXR1cm4geyByLCBnLCBiLCBhIH07XG59XG5mdW5jdGlvbiBkYXJrZW4oc3JjLCBkc3QsIG9wcyA9IDEpIHtcbiAgICBzcmMuYSAqPSBvcHM7XG4gICAgY29uc3QgYSA9IGRzdC5hICsgc3JjLmEgLSBkc3QuYSAqIHNyYy5hO1xuICAgIGNvbnN0IHNyYSA9IHNyYy5yICogc3JjLmE7XG4gICAgY29uc3Qgc2dhID0gc3JjLmcgKiBzcmMuYTtcbiAgICBjb25zdCBzYmEgPSBzcmMuYiAqIHNyYy5hO1xuICAgIGNvbnN0IGRyYSA9IGRzdC5yICogZHN0LmE7XG4gICAgY29uc3QgZGdhID0gZHN0LmcgKiBkc3QuYTtcbiAgICBjb25zdCBkYmEgPSBkc3QuYiAqIGRzdC5hO1xuICAgIGNvbnN0IHIgPSAoTWF0aC5taW4oc3JhICogZHN0LmEsIGRyYSAqIHNyYy5hKSArXG4gICAgICAgIHNyYSAqICgxIC0gZHN0LmEpICtcbiAgICAgICAgZHJhICogKDEgLSBzcmMuYSkpIC9cbiAgICAgICAgYTtcbiAgICBjb25zdCBnID0gKE1hdGgubWluKHNnYSAqIGRzdC5hLCBkZ2EgKiBzcmMuYSkgK1xuICAgICAgICBzZ2EgKiAoMSAtIGRzdC5hKSArXG4gICAgICAgIGRnYSAqICgxIC0gc3JjLmEpKSAvXG4gICAgICAgIGE7XG4gICAgY29uc3QgYiA9IChNYXRoLm1pbihzYmEgKiBkc3QuYSwgZGJhICogc3JjLmEpICtcbiAgICAgICAgc2JhICogKDEgLSBkc3QuYSkgK1xuICAgICAgICBkYmEgKiAoMSAtIHNyYy5hKSkgL1xuICAgICAgICBhO1xuICAgIHJldHVybiB7IHIsIGcsIGIsIGEgfTtcbn1cbmZ1bmN0aW9uIGxpZ2h0ZW4oc3JjLCBkc3QsIG9wcyA9IDEpIHtcbiAgICBzcmMuYSAqPSBvcHM7XG4gICAgY29uc3QgYSA9IGRzdC5hICsgc3JjLmEgLSBkc3QuYSAqIHNyYy5hO1xuICAgIGNvbnN0IHNyYSA9IHNyYy5yICogc3JjLmE7XG4gICAgY29uc3Qgc2dhID0gc3JjLmcgKiBzcmMuYTtcbiAgICBjb25zdCBzYmEgPSBzcmMuYiAqIHNyYy5hO1xuICAgIGNvbnN0IGRyYSA9IGRzdC5yICogZHN0LmE7XG4gICAgY29uc3QgZGdhID0gZHN0LmcgKiBkc3QuYTtcbiAgICBjb25zdCBkYmEgPSBkc3QuYiAqIGRzdC5hO1xuICAgIGNvbnN0IHIgPSAoTWF0aC5tYXgoc3JhICogZHN0LmEsIGRyYSAqIHNyYy5hKSArXG4gICAgICAgIHNyYSAqICgxIC0gZHN0LmEpICtcbiAgICAgICAgZHJhICogKDEgLSBzcmMuYSkpIC9cbiAgICAgICAgYTtcbiAgICBjb25zdCBnID0gKE1hdGgubWF4KHNnYSAqIGRzdC5hLCBkZ2EgKiBzcmMuYSkgK1xuICAgICAgICBzZ2EgKiAoMSAtIGRzdC5hKSArXG4gICAgICAgIGRnYSAqICgxIC0gc3JjLmEpKSAvXG4gICAgICAgIGE7XG4gICAgY29uc3QgYiA9IChNYXRoLm1heChzYmEgKiBkc3QuYSwgZGJhICogc3JjLmEpICtcbiAgICAgICAgc2JhICogKDEgLSBkc3QuYSkgK1xuICAgICAgICBkYmEgKiAoMSAtIHNyYy5hKSkgL1xuICAgICAgICBhO1xuICAgIHJldHVybiB7IHIsIGcsIGIsIGEgfTtcbn1cbmZ1bmN0aW9uIGhhcmRMaWdodChzcmMsIGRzdCwgb3BzID0gMSkge1xuICAgIHNyYy5hICo9IG9wcztcbiAgICBjb25zdCBhID0gZHN0LmEgKyBzcmMuYSAtIGRzdC5hICogc3JjLmE7XG4gICAgY29uc3Qgc3JhID0gc3JjLnIgKiBzcmMuYTtcbiAgICBjb25zdCBzZ2EgPSBzcmMuZyAqIHNyYy5hO1xuICAgIGNvbnN0IHNiYSA9IHNyYy5iICogc3JjLmE7XG4gICAgY29uc3QgZHJhID0gZHN0LnIgKiBkc3QuYTtcbiAgICBjb25zdCBkZ2EgPSBkc3QuZyAqIGRzdC5hO1xuICAgIGNvbnN0IGRiYSA9IGRzdC5iICogZHN0LmE7XG4gICAgY29uc3QgciA9ICgyICogc3JhIDw9IHNyYy5hXG4gICAgICAgID8gMiAqIHNyYSAqIGRyYSArIHNyYSAqICgxIC0gZHN0LmEpICsgZHJhICogKDEgLSBzcmMuYSlcbiAgICAgICAgOiBzcmEgKiAoMSArIGRzdC5hKSArIGRyYSAqICgxICsgc3JjLmEpIC0gMiAqIGRyYSAqIHNyYSAtIGRzdC5hICogc3JjLmEpIC9cbiAgICAgICAgYTtcbiAgICBjb25zdCBnID0gKDIgKiBzZ2EgPD0gc3JjLmFcbiAgICAgICAgPyAyICogc2dhICogZGdhICsgc2dhICogKDEgLSBkc3QuYSkgKyBkZ2EgKiAoMSAtIHNyYy5hKVxuICAgICAgICA6IHNnYSAqICgxICsgZHN0LmEpICsgZGdhICogKDEgKyBzcmMuYSkgLSAyICogZGdhICogc2dhIC0gZHN0LmEgKiBzcmMuYSkgL1xuICAgICAgICBhO1xuICAgIGNvbnN0IGIgPSAoMiAqIHNiYSA8PSBzcmMuYVxuICAgICAgICA/IDIgKiBzYmEgKiBkYmEgKyBzYmEgKiAoMSAtIGRzdC5hKSArIGRiYSAqICgxIC0gc3JjLmEpXG4gICAgICAgIDogc2JhICogKDEgKyBkc3QuYSkgKyBkYmEgKiAoMSArIHNyYy5hKSAtIDIgKiBkYmEgKiBzYmEgLSBkc3QuYSAqIHNyYy5hKSAvXG4gICAgICAgIGE7XG4gICAgcmV0dXJuIHsgciwgZywgYiwgYSB9O1xufVxuZnVuY3Rpb24gZGlmZmVyZW5jZShzcmMsIGRzdCwgb3BzID0gMSkge1xuICAgIHNyYy5hICo9IG9wcztcbiAgICBjb25zdCBhID0gZHN0LmEgKyBzcmMuYSAtIGRzdC5hICogc3JjLmE7XG4gICAgY29uc3Qgc3JhID0gc3JjLnIgKiBzcmMuYTtcbiAgICBjb25zdCBzZ2EgPSBzcmMuZyAqIHNyYy5hO1xuICAgIGNvbnN0IHNiYSA9IHNyYy5iICogc3JjLmE7XG4gICAgY29uc3QgZHJhID0gZHN0LnIgKiBkc3QuYTtcbiAgICBjb25zdCBkZ2EgPSBkc3QuZyAqIGRzdC5hO1xuICAgIGNvbnN0IGRiYSA9IGRzdC5iICogZHN0LmE7XG4gICAgY29uc3QgciA9IChzcmEgKyBkcmEgLSAyICogTWF0aC5taW4oc3JhICogZHN0LmEsIGRyYSAqIHNyYy5hKSkgLyBhO1xuICAgIGNvbnN0IGcgPSAoc2dhICsgZGdhIC0gMiAqIE1hdGgubWluKHNnYSAqIGRzdC5hLCBkZ2EgKiBzcmMuYSkpIC8gYTtcbiAgICBjb25zdCBiID0gKHNiYSArIGRiYSAtIDIgKiBNYXRoLm1pbihzYmEgKiBkc3QuYSwgZGJhICogc3JjLmEpKSAvIGE7XG4gICAgcmV0dXJuIHsgciwgZywgYiwgYSB9O1xufVxuZnVuY3Rpb24gZXhjbHVzaW9uKHNyYywgZHN0LCBvcHMgPSAxKSB7XG4gICAgc3JjLmEgKj0gb3BzO1xuICAgIGNvbnN0IGEgPSBkc3QuYSArIHNyYy5hIC0gZHN0LmEgKiBzcmMuYTtcbiAgICBjb25zdCBzcmEgPSBzcmMuciAqIHNyYy5hO1xuICAgIGNvbnN0IHNnYSA9IHNyYy5nICogc3JjLmE7XG4gICAgY29uc3Qgc2JhID0gc3JjLmIgKiBzcmMuYTtcbiAgICBjb25zdCBkcmEgPSBkc3QuciAqIGRzdC5hO1xuICAgIGNvbnN0IGRnYSA9IGRzdC5nICogZHN0LmE7XG4gICAgY29uc3QgZGJhID0gZHN0LmIgKiBkc3QuYTtcbiAgICBjb25zdCByID0gKHNyYSAqIGRzdC5hICtcbiAgICAgICAgZHJhICogc3JjLmEgLVxuICAgICAgICAyICogc3JhICogZHJhICtcbiAgICAgICAgc3JhICogKDEgLSBkc3QuYSkgK1xuICAgICAgICBkcmEgKiAoMSAtIHNyYy5hKSkgL1xuICAgICAgICBhO1xuICAgIGNvbnN0IGcgPSAoc2dhICogZHN0LmEgK1xuICAgICAgICBkZ2EgKiBzcmMuYSAtXG4gICAgICAgIDIgKiBzZ2EgKiBkZ2EgK1xuICAgICAgICBzZ2EgKiAoMSAtIGRzdC5hKSArXG4gICAgICAgIGRnYSAqICgxIC0gc3JjLmEpKSAvXG4gICAgICAgIGE7XG4gICAgY29uc3QgYiA9IChzYmEgKiBkc3QuYSArXG4gICAgICAgIGRiYSAqIHNyYy5hIC1cbiAgICAgICAgMiAqIHNiYSAqIGRiYSArXG4gICAgICAgIHNiYSAqICgxIC0gZHN0LmEpICtcbiAgICAgICAgZGJhICogKDEgLSBzcmMuYSkpIC9cbiAgICAgICAgYTtcbiAgICByZXR1cm4geyByLCBnLCBiLCBhIH07XG59XG5leHBvcnRzLm5hbWVzID0gW1xuICAgIHNyY092ZXIsXG4gICAgZHN0T3ZlcixcbiAgICBtdWx0aXBseSxcbiAgICBhZGQsXG4gICAgc2NyZWVuLFxuICAgIG92ZXJsYXksXG4gICAgZGFya2VuLFxuICAgIGxpZ2h0ZW4sXG4gICAgaGFyZExpZ2h0LFxuICAgIGRpZmZlcmVuY2UsXG4gICAgZXhjbHVzaW9uLFxuXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbXBvc2l0ZS1tb2Rlcy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@jimp+core@1.6.0/node_modules/@jimp/core/dist/commonjs/utils/composite-modes.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/@jimp+core@1.6.0/node_modules/@jimp/core/dist/commonjs/utils/composite.js":
/*!**********************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@jimp+core@1.6.0/node_modules/@jimp/core/dist/commonjs/utils/composite.js ***!
  \**********************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.composite = composite;\nconst types_1 = __webpack_require__(/*! @jimp/types */ \"(ssr)/../../node_modules/.pnpm/@jimp+types@1.6.0/node_modules/@jimp/types/dist/commonjs/index.js\");\nconst constants_js_1 = __webpack_require__(/*! ./constants.js */ \"(ssr)/../../node_modules/.pnpm/@jimp+core@1.6.0/node_modules/@jimp/core/dist/commonjs/utils/constants.js\");\nconst compositeModes = __importStar(__webpack_require__(/*! ./composite-modes.js */ \"(ssr)/../../node_modules/.pnpm/@jimp+core@1.6.0/node_modules/@jimp/core/dist/commonjs/utils/composite-modes.js\"));\nconst utils_1 = __webpack_require__(/*! @jimp/utils */ \"(ssr)/../../node_modules/.pnpm/@jimp+utils@1.6.0/node_modules/@jimp/utils/dist/commonjs/index.js\");\nfunction composite(baseImage, src, x = 0, y = 0, options = {}) {\n    if (!(src instanceof baseImage.constructor)) {\n        throw new Error(\"The source must be a Jimp image\");\n    }\n    if (typeof x !== \"number\" || typeof y !== \"number\") {\n        throw new Error(\"x and y must be numbers\");\n    }\n    const { mode = constants_js_1.BlendMode.SRC_OVER } = options;\n    let { opacitySource = 1.0, opacityDest = 1.0 } = options;\n    if (typeof opacitySource !== \"number\" ||\n        opacitySource < 0 ||\n        opacitySource > 1) {\n        opacitySource = 1.0;\n    }\n    if (typeof opacityDest !== \"number\" || opacityDest < 0 || opacityDest > 1) {\n        opacityDest = 1.0;\n    }\n    const blendmode = compositeModes[mode];\n    // round input\n    x = Math.round(x);\n    y = Math.round(y);\n    if (opacityDest !== 1.0) {\n        baseImage.scan((_, __, idx) => {\n            const v = baseImage.bitmap.data[idx + 3] * opacityDest;\n            baseImage.bitmap.data[idx + 3] = v;\n        });\n    }\n    src.scan((sx, sy, idx) => {\n        const dstIdx = baseImage.getPixelIndex(x + sx, y + sy, types_1.Edge.CROP);\n        if (dstIdx === -1) {\n            // Skip target pixels outside of dst\n            return;\n        }\n        const blended = blendmode({\n            r: src.bitmap.data[idx + 0] / 255,\n            g: src.bitmap.data[idx + 1] / 255,\n            b: src.bitmap.data[idx + 2] / 255,\n            a: src.bitmap.data[idx + 3] / 255,\n        }, {\n            r: baseImage.bitmap.data[dstIdx + 0] / 255,\n            g: baseImage.bitmap.data[dstIdx + 1] / 255,\n            b: baseImage.bitmap.data[dstIdx + 2] / 255,\n            a: baseImage.bitmap.data[dstIdx + 3] / 255,\n        }, opacitySource);\n        baseImage.bitmap.data[dstIdx + 0] = (0, utils_1.limit255)(blended.r * 255);\n        baseImage.bitmap.data[dstIdx + 1] = (0, utils_1.limit255)(blended.g * 255);\n        baseImage.bitmap.data[dstIdx + 2] = (0, utils_1.limit255)(blended.b * 255);\n        baseImage.bitmap.data[dstIdx + 3] = (0, utils_1.limit255)(blended.a * 255);\n    });\n    return baseImage;\n}\n//# sourceMappingURL=composite.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BqaW1wK2NvcmVAMS42LjAvbm9kZV9tb2R1bGVzL0BqaW1wL2NvcmUvZGlzdC9jb21tb25qcy91dGlscy9jb21wb3NpdGUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDBDQUEwQyw0QkFBNEI7QUFDdEUsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGlCQUFpQjtBQUNqQixnQkFBZ0IsbUJBQU8sQ0FBQyxxSEFBYTtBQUNyQyx1QkFBdUIsbUJBQU8sQ0FBQyxnSUFBZ0I7QUFDL0Msb0NBQW9DLG1CQUFPLENBQUMsNElBQXNCO0FBQ2xFLGdCQUFnQixtQkFBTyxDQUFDLHFIQUFhO0FBQ3JDLDZEQUE2RDtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDJDQUEyQztBQUN2RCxVQUFVLHlDQUF5QztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvbWlrZXdlc3RoYWQvRGVza3RvcC9SZXBvcy9zcG9yYWRpYy1sYWJzLXRpbGUtZXh0cnVkZXIvbm9kZV9tb2R1bGVzLy5wbnBtL0BqaW1wK2NvcmVAMS42LjAvbm9kZV9tb2R1bGVzL0BqaW1wL2NvcmUvZGlzdC9jb21tb25qcy91dGlscy9jb21wb3NpdGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY29tcG9zaXRlID0gY29tcG9zaXRlO1xuY29uc3QgdHlwZXNfMSA9IHJlcXVpcmUoXCJAamltcC90eXBlc1wiKTtcbmNvbnN0IGNvbnN0YW50c19qc18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzLmpzXCIpO1xuY29uc3QgY29tcG9zaXRlTW9kZXMgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vY29tcG9zaXRlLW1vZGVzLmpzXCIpKTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiQGppbXAvdXRpbHNcIik7XG5mdW5jdGlvbiBjb21wb3NpdGUoYmFzZUltYWdlLCBzcmMsIHggPSAwLCB5ID0gMCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKCEoc3JjIGluc3RhbmNlb2YgYmFzZUltYWdlLmNvbnN0cnVjdG9yKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgc291cmNlIG11c3QgYmUgYSBKaW1wIGltYWdlXCIpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHggIT09IFwibnVtYmVyXCIgfHwgdHlwZW9mIHkgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwieCBhbmQgeSBtdXN0IGJlIG51bWJlcnNcIik7XG4gICAgfVxuICAgIGNvbnN0IHsgbW9kZSA9IGNvbnN0YW50c19qc18xLkJsZW5kTW9kZS5TUkNfT1ZFUiB9ID0gb3B0aW9ucztcbiAgICBsZXQgeyBvcGFjaXR5U291cmNlID0gMS4wLCBvcGFjaXR5RGVzdCA9IDEuMCB9ID0gb3B0aW9ucztcbiAgICBpZiAodHlwZW9mIG9wYWNpdHlTb3VyY2UgIT09IFwibnVtYmVyXCIgfHxcbiAgICAgICAgb3BhY2l0eVNvdXJjZSA8IDAgfHxcbiAgICAgICAgb3BhY2l0eVNvdXJjZSA+IDEpIHtcbiAgICAgICAgb3BhY2l0eVNvdXJjZSA9IDEuMDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvcGFjaXR5RGVzdCAhPT0gXCJudW1iZXJcIiB8fCBvcGFjaXR5RGVzdCA8IDAgfHwgb3BhY2l0eURlc3QgPiAxKSB7XG4gICAgICAgIG9wYWNpdHlEZXN0ID0gMS4wO1xuICAgIH1cbiAgICBjb25zdCBibGVuZG1vZGUgPSBjb21wb3NpdGVNb2Rlc1ttb2RlXTtcbiAgICAvLyByb3VuZCBpbnB1dFxuICAgIHggPSBNYXRoLnJvdW5kKHgpO1xuICAgIHkgPSBNYXRoLnJvdW5kKHkpO1xuICAgIGlmIChvcGFjaXR5RGVzdCAhPT0gMS4wKSB7XG4gICAgICAgIGJhc2VJbWFnZS5zY2FuKChfLCBfXywgaWR4KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB2ID0gYmFzZUltYWdlLmJpdG1hcC5kYXRhW2lkeCArIDNdICogb3BhY2l0eURlc3Q7XG4gICAgICAgICAgICBiYXNlSW1hZ2UuYml0bWFwLmRhdGFbaWR4ICsgM10gPSB2O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3JjLnNjYW4oKHN4LCBzeSwgaWR4KSA9PiB7XG4gICAgICAgIGNvbnN0IGRzdElkeCA9IGJhc2VJbWFnZS5nZXRQaXhlbEluZGV4KHggKyBzeCwgeSArIHN5LCB0eXBlc18xLkVkZ2UuQ1JPUCk7XG4gICAgICAgIGlmIChkc3RJZHggPT09IC0xKSB7XG4gICAgICAgICAgICAvLyBTa2lwIHRhcmdldCBwaXhlbHMgb3V0c2lkZSBvZiBkc3RcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBibGVuZGVkID0gYmxlbmRtb2RlKHtcbiAgICAgICAgICAgIHI6IHNyYy5iaXRtYXAuZGF0YVtpZHggKyAwXSAvIDI1NSxcbiAgICAgICAgICAgIGc6IHNyYy5iaXRtYXAuZGF0YVtpZHggKyAxXSAvIDI1NSxcbiAgICAgICAgICAgIGI6IHNyYy5iaXRtYXAuZGF0YVtpZHggKyAyXSAvIDI1NSxcbiAgICAgICAgICAgIGE6IHNyYy5iaXRtYXAuZGF0YVtpZHggKyAzXSAvIDI1NSxcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgcjogYmFzZUltYWdlLmJpdG1hcC5kYXRhW2RzdElkeCArIDBdIC8gMjU1LFxuICAgICAgICAgICAgZzogYmFzZUltYWdlLmJpdG1hcC5kYXRhW2RzdElkeCArIDFdIC8gMjU1LFxuICAgICAgICAgICAgYjogYmFzZUltYWdlLmJpdG1hcC5kYXRhW2RzdElkeCArIDJdIC8gMjU1LFxuICAgICAgICAgICAgYTogYmFzZUltYWdlLmJpdG1hcC5kYXRhW2RzdElkeCArIDNdIC8gMjU1LFxuICAgICAgICB9LCBvcGFjaXR5U291cmNlKTtcbiAgICAgICAgYmFzZUltYWdlLmJpdG1hcC5kYXRhW2RzdElkeCArIDBdID0gKDAsIHV0aWxzXzEubGltaXQyNTUpKGJsZW5kZWQuciAqIDI1NSk7XG4gICAgICAgIGJhc2VJbWFnZS5iaXRtYXAuZGF0YVtkc3RJZHggKyAxXSA9ICgwLCB1dGlsc18xLmxpbWl0MjU1KShibGVuZGVkLmcgKiAyNTUpO1xuICAgICAgICBiYXNlSW1hZ2UuYml0bWFwLmRhdGFbZHN0SWR4ICsgMl0gPSAoMCwgdXRpbHNfMS5saW1pdDI1NSkoYmxlbmRlZC5iICogMjU1KTtcbiAgICAgICAgYmFzZUltYWdlLmJpdG1hcC5kYXRhW2RzdElkeCArIDNdID0gKDAsIHV0aWxzXzEubGltaXQyNTUpKGJsZW5kZWQuYSAqIDI1NSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGJhc2VJbWFnZTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbXBvc2l0ZS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@jimp+core@1.6.0/node_modules/@jimp/core/dist/commonjs/utils/composite.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/@jimp+core@1.6.0/node_modules/@jimp/core/dist/commonjs/utils/constants.js":
/*!**********************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@jimp+core@1.6.0/node_modules/@jimp/core/dist/commonjs/utils/constants.js ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BlendMode = exports.VerticalAlign = exports.HorizontalAlign = void 0;\n/* Horizontal align modes for cover, contain, bit masks */\nvar HorizontalAlign;\n(function (HorizontalAlign) {\n    HorizontalAlign[HorizontalAlign[\"LEFT\"] = 1] = \"LEFT\";\n    HorizontalAlign[HorizontalAlign[\"CENTER\"] = 2] = \"CENTER\";\n    HorizontalAlign[HorizontalAlign[\"RIGHT\"] = 4] = \"RIGHT\";\n})(HorizontalAlign || (exports.HorizontalAlign = HorizontalAlign = {}));\n/* Vertical align modes for cover, contain, bit masks */\nvar VerticalAlign;\n(function (VerticalAlign) {\n    VerticalAlign[VerticalAlign[\"TOP\"] = 8] = \"TOP\";\n    VerticalAlign[VerticalAlign[\"MIDDLE\"] = 16] = \"MIDDLE\";\n    VerticalAlign[VerticalAlign[\"BOTTOM\"] = 32] = \"BOTTOM\";\n})(VerticalAlign || (exports.VerticalAlign = VerticalAlign = {}));\n/**\n * How to blend two images together\n */\nvar BlendMode;\n(function (BlendMode) {\n    /**\n     * Composite the source image over the destination image.\n     * This is the default value. It represents the most intuitive case, where shapes are painted on top of what is below, with transparent areas showing the destination layer.\n     */\n    BlendMode[\"SRC_OVER\"] = \"srcOver\";\n    /** Composite the source image under the destination image. */\n    BlendMode[\"DST_OVER\"] = \"dstOver\";\n    /**\n     * Multiply the color components of the source and destination images.\n     * This can only result in the same or darker colors (multiplying by white, 1.0, results in no change; multiplying by black, 0.0, results in black).\n     * When compositing two opaque images, this has similar effect to overlapping two transparencies on a projector.\n     *\n     * This mode is useful for coloring shadows.\n     */\n    BlendMode[\"MULTIPLY\"] = \"multiply\";\n    /**\n     * The Add mode adds the color information of the base layers and the blending layer.\n     * In digital terms, adding color increases the brightness.\n     */\n    BlendMode[\"ADD\"] = \"add\";\n    /**\n     * Multiply the inverse of the components of the source and destination images, and inverse the result.\n     * Inverting the components means that a fully saturated channel (opaque white) is treated as the value 0.0, and values normally treated as 0.0 (black, transparent) are treated as 1.0.\n     * This is essentially the same as modulate blend mode, but with the values of the colors inverted before the multiplication and the result being inverted back before rendering.\n     * This can only result in the same or lighter colors (multiplying by black, 1.0, results in no change; multiplying by white, 0.0, results in white). Similarly, in the alpha channel, it can only result in more opaque colors.\n     * This has similar effect to two projectors displaying their images on the same screen simultaneously.\n     */\n    BlendMode[\"SCREEN\"] = \"screen\";\n    /**\n     * Multiply the components of the source and destination images after adjusting them to favor the destination.\n     * Specifically, if the destination value is smaller, this multiplies it with the source value, whereas is the source value is smaller, it multiplies the inverse of the source value with the inverse of the destination value, then inverts the result.\n     * Inverting the components means that a fully saturated channel (opaque white) is treated as the value 0.0, and values normally treated as 0.0 (black, transparent) are treated as 1.0.\n     *\n     * The Overlay mode behaves like Screen mode in bright areas, and like Multiply mode in darker areas.\n     * With this mode, the bright areas will look brighter and the dark areas will look darker.\n     */\n    BlendMode[\"OVERLAY\"] = \"overlay\";\n    /**\n     * Composite the source and destination image by choosing the lowest value from each color channel.\n     * The opacity of the output image is computed in the same way as for srcOver.\n     */\n    BlendMode[\"DARKEN\"] = \"darken\";\n    /**\n     * Composite the source and destination image by choosing the highest value from each color channel.\n     * The opacity of the output image is computed in the same way as for srcOver.\n     */\n    BlendMode[\"LIGHTEN\"] = \"lighten\";\n    /**\n     * Multiply the components of the source and destination images after adjusting them to favor the source.\n     * Specifically, if the source value is smaller, this multiplies it with the destination value, whereas is the destination value is smaller, it multiplies the inverse of the destination value with the inverse of the source value, then inverts the result.\n     * Inverting the components means that a fully saturated channel (opaque white) is treated as the value 0.0, and values normally treated as 0.0 (black, transparent) are treated as 1.0.\n     *\n     * The effect of the Hard light mode depends on the density of the superimposed color. Using bright colors on the blending layer will create a brighter effect like the Screen modes, while dark colors will create darker colors like the Multiply mode.\n     */\n    BlendMode[\"HARD_LIGHT\"] = \"hardLight\";\n    /**\n     * Subtract the smaller value from the bigger value for each channel.\n     * Compositing black has no effect; compositing white inverts the colors of the other image.\n     * The opacity of the output image is computed in the same way as for srcOver.\n     * The effect is similar to exclusion but harsher.\n     */\n    BlendMode[\"DIFFERENCE\"] = \"difference\";\n    /**\n     * Subtract double the product of the two images from the sum of the two images.\n     * Compositing black has no effect; compositing white inverts the colors of the other image.\n     * The opacity of the output image is computed in the same way as for srcOver.\n     * The effect is similar to difference but softer.\n     */\n    BlendMode[\"EXCLUSION\"] = \"exclusion\";\n})(BlendMode || (exports.BlendMode = BlendMode = {}));\n//# sourceMappingURL=constants.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BqaW1wK2NvcmVAMS42LjAvbm9kZV9tb2R1bGVzL0BqaW1wL2NvcmUvZGlzdC9jb21tb25qcy91dGlscy9jb25zdGFudHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsaUJBQWlCLEdBQUcscUJBQXFCLEdBQUcsdUJBQXVCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsc0JBQXNCLHVCQUF1Qix1QkFBdUI7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxvQkFBb0IscUJBQXFCLHFCQUFxQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkdBQTJHO0FBQzNHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0R0FBNEc7QUFDNUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGdCQUFnQixpQkFBaUIsaUJBQWlCO0FBQ25EIiwic291cmNlcyI6WyIvVXNlcnMvbWlrZXdlc3RoYWQvRGVza3RvcC9SZXBvcy9zcG9yYWRpYy1sYWJzLXRpbGUtZXh0cnVkZXIvbm9kZV9tb2R1bGVzLy5wbnBtL0BqaW1wK2NvcmVAMS42LjAvbm9kZV9tb2R1bGVzL0BqaW1wL2NvcmUvZGlzdC9jb21tb25qcy91dGlscy9jb25zdGFudHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkJsZW5kTW9kZSA9IGV4cG9ydHMuVmVydGljYWxBbGlnbiA9IGV4cG9ydHMuSG9yaXpvbnRhbEFsaWduID0gdm9pZCAwO1xuLyogSG9yaXpvbnRhbCBhbGlnbiBtb2RlcyBmb3IgY292ZXIsIGNvbnRhaW4sIGJpdCBtYXNrcyAqL1xudmFyIEhvcml6b250YWxBbGlnbjtcbihmdW5jdGlvbiAoSG9yaXpvbnRhbEFsaWduKSB7XG4gICAgSG9yaXpvbnRhbEFsaWduW0hvcml6b250YWxBbGlnbltcIkxFRlRcIl0gPSAxXSA9IFwiTEVGVFwiO1xuICAgIEhvcml6b250YWxBbGlnbltIb3Jpem9udGFsQWxpZ25bXCJDRU5URVJcIl0gPSAyXSA9IFwiQ0VOVEVSXCI7XG4gICAgSG9yaXpvbnRhbEFsaWduW0hvcml6b250YWxBbGlnbltcIlJJR0hUXCJdID0gNF0gPSBcIlJJR0hUXCI7XG59KShIb3Jpem9udGFsQWxpZ24gfHwgKGV4cG9ydHMuSG9yaXpvbnRhbEFsaWduID0gSG9yaXpvbnRhbEFsaWduID0ge30pKTtcbi8qIFZlcnRpY2FsIGFsaWduIG1vZGVzIGZvciBjb3ZlciwgY29udGFpbiwgYml0IG1hc2tzICovXG52YXIgVmVydGljYWxBbGlnbjtcbihmdW5jdGlvbiAoVmVydGljYWxBbGlnbikge1xuICAgIFZlcnRpY2FsQWxpZ25bVmVydGljYWxBbGlnbltcIlRPUFwiXSA9IDhdID0gXCJUT1BcIjtcbiAgICBWZXJ0aWNhbEFsaWduW1ZlcnRpY2FsQWxpZ25bXCJNSURETEVcIl0gPSAxNl0gPSBcIk1JRERMRVwiO1xuICAgIFZlcnRpY2FsQWxpZ25bVmVydGljYWxBbGlnbltcIkJPVFRPTVwiXSA9IDMyXSA9IFwiQk9UVE9NXCI7XG59KShWZXJ0aWNhbEFsaWduIHx8IChleHBvcnRzLlZlcnRpY2FsQWxpZ24gPSBWZXJ0aWNhbEFsaWduID0ge30pKTtcbi8qKlxuICogSG93IHRvIGJsZW5kIHR3byBpbWFnZXMgdG9nZXRoZXJcbiAqL1xudmFyIEJsZW5kTW9kZTtcbihmdW5jdGlvbiAoQmxlbmRNb2RlKSB7XG4gICAgLyoqXG4gICAgICogQ29tcG9zaXRlIHRoZSBzb3VyY2UgaW1hZ2Ugb3ZlciB0aGUgZGVzdGluYXRpb24gaW1hZ2UuXG4gICAgICogVGhpcyBpcyB0aGUgZGVmYXVsdCB2YWx1ZS4gSXQgcmVwcmVzZW50cyB0aGUgbW9zdCBpbnR1aXRpdmUgY2FzZSwgd2hlcmUgc2hhcGVzIGFyZSBwYWludGVkIG9uIHRvcCBvZiB3aGF0IGlzIGJlbG93LCB3aXRoIHRyYW5zcGFyZW50IGFyZWFzIHNob3dpbmcgdGhlIGRlc3RpbmF0aW9uIGxheWVyLlxuICAgICAqL1xuICAgIEJsZW5kTW9kZVtcIlNSQ19PVkVSXCJdID0gXCJzcmNPdmVyXCI7XG4gICAgLyoqIENvbXBvc2l0ZSB0aGUgc291cmNlIGltYWdlIHVuZGVyIHRoZSBkZXN0aW5hdGlvbiBpbWFnZS4gKi9cbiAgICBCbGVuZE1vZGVbXCJEU1RfT1ZFUlwiXSA9IFwiZHN0T3ZlclwiO1xuICAgIC8qKlxuICAgICAqIE11bHRpcGx5IHRoZSBjb2xvciBjb21wb25lbnRzIG9mIHRoZSBzb3VyY2UgYW5kIGRlc3RpbmF0aW9uIGltYWdlcy5cbiAgICAgKiBUaGlzIGNhbiBvbmx5IHJlc3VsdCBpbiB0aGUgc2FtZSBvciBkYXJrZXIgY29sb3JzIChtdWx0aXBseWluZyBieSB3aGl0ZSwgMS4wLCByZXN1bHRzIGluIG5vIGNoYW5nZTsgbXVsdGlwbHlpbmcgYnkgYmxhY2ssIDAuMCwgcmVzdWx0cyBpbiBibGFjaykuXG4gICAgICogV2hlbiBjb21wb3NpdGluZyB0d28gb3BhcXVlIGltYWdlcywgdGhpcyBoYXMgc2ltaWxhciBlZmZlY3QgdG8gb3ZlcmxhcHBpbmcgdHdvIHRyYW5zcGFyZW5jaWVzIG9uIGEgcHJvamVjdG9yLlxuICAgICAqXG4gICAgICogVGhpcyBtb2RlIGlzIHVzZWZ1bCBmb3IgY29sb3Jpbmcgc2hhZG93cy5cbiAgICAgKi9cbiAgICBCbGVuZE1vZGVbXCJNVUxUSVBMWVwiXSA9IFwibXVsdGlwbHlcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgQWRkIG1vZGUgYWRkcyB0aGUgY29sb3IgaW5mb3JtYXRpb24gb2YgdGhlIGJhc2UgbGF5ZXJzIGFuZCB0aGUgYmxlbmRpbmcgbGF5ZXIuXG4gICAgICogSW4gZGlnaXRhbCB0ZXJtcywgYWRkaW5nIGNvbG9yIGluY3JlYXNlcyB0aGUgYnJpZ2h0bmVzcy5cbiAgICAgKi9cbiAgICBCbGVuZE1vZGVbXCJBRERcIl0gPSBcImFkZFwiO1xuICAgIC8qKlxuICAgICAqIE11bHRpcGx5IHRoZSBpbnZlcnNlIG9mIHRoZSBjb21wb25lbnRzIG9mIHRoZSBzb3VyY2UgYW5kIGRlc3RpbmF0aW9uIGltYWdlcywgYW5kIGludmVyc2UgdGhlIHJlc3VsdC5cbiAgICAgKiBJbnZlcnRpbmcgdGhlIGNvbXBvbmVudHMgbWVhbnMgdGhhdCBhIGZ1bGx5IHNhdHVyYXRlZCBjaGFubmVsIChvcGFxdWUgd2hpdGUpIGlzIHRyZWF0ZWQgYXMgdGhlIHZhbHVlIDAuMCwgYW5kIHZhbHVlcyBub3JtYWxseSB0cmVhdGVkIGFzIDAuMCAoYmxhY2ssIHRyYW5zcGFyZW50KSBhcmUgdHJlYXRlZCBhcyAxLjAuXG4gICAgICogVGhpcyBpcyBlc3NlbnRpYWxseSB0aGUgc2FtZSBhcyBtb2R1bGF0ZSBibGVuZCBtb2RlLCBidXQgd2l0aCB0aGUgdmFsdWVzIG9mIHRoZSBjb2xvcnMgaW52ZXJ0ZWQgYmVmb3JlIHRoZSBtdWx0aXBsaWNhdGlvbiBhbmQgdGhlIHJlc3VsdCBiZWluZyBpbnZlcnRlZCBiYWNrIGJlZm9yZSByZW5kZXJpbmcuXG4gICAgICogVGhpcyBjYW4gb25seSByZXN1bHQgaW4gdGhlIHNhbWUgb3IgbGlnaHRlciBjb2xvcnMgKG11bHRpcGx5aW5nIGJ5IGJsYWNrLCAxLjAsIHJlc3VsdHMgaW4gbm8gY2hhbmdlOyBtdWx0aXBseWluZyBieSB3aGl0ZSwgMC4wLCByZXN1bHRzIGluIHdoaXRlKS4gU2ltaWxhcmx5LCBpbiB0aGUgYWxwaGEgY2hhbm5lbCwgaXQgY2FuIG9ubHkgcmVzdWx0IGluIG1vcmUgb3BhcXVlIGNvbG9ycy5cbiAgICAgKiBUaGlzIGhhcyBzaW1pbGFyIGVmZmVjdCB0byB0d28gcHJvamVjdG9ycyBkaXNwbGF5aW5nIHRoZWlyIGltYWdlcyBvbiB0aGUgc2FtZSBzY3JlZW4gc2ltdWx0YW5lb3VzbHkuXG4gICAgICovXG4gICAgQmxlbmRNb2RlW1wiU0NSRUVOXCJdID0gXCJzY3JlZW5cIjtcbiAgICAvKipcbiAgICAgKiBNdWx0aXBseSB0aGUgY29tcG9uZW50cyBvZiB0aGUgc291cmNlIGFuZCBkZXN0aW5hdGlvbiBpbWFnZXMgYWZ0ZXIgYWRqdXN0aW5nIHRoZW0gdG8gZmF2b3IgdGhlIGRlc3RpbmF0aW9uLlxuICAgICAqIFNwZWNpZmljYWxseSwgaWYgdGhlIGRlc3RpbmF0aW9uIHZhbHVlIGlzIHNtYWxsZXIsIHRoaXMgbXVsdGlwbGllcyBpdCB3aXRoIHRoZSBzb3VyY2UgdmFsdWUsIHdoZXJlYXMgaXMgdGhlIHNvdXJjZSB2YWx1ZSBpcyBzbWFsbGVyLCBpdCBtdWx0aXBsaWVzIHRoZSBpbnZlcnNlIG9mIHRoZSBzb3VyY2UgdmFsdWUgd2l0aCB0aGUgaW52ZXJzZSBvZiB0aGUgZGVzdGluYXRpb24gdmFsdWUsIHRoZW4gaW52ZXJ0cyB0aGUgcmVzdWx0LlxuICAgICAqIEludmVydGluZyB0aGUgY29tcG9uZW50cyBtZWFucyB0aGF0IGEgZnVsbHkgc2F0dXJhdGVkIGNoYW5uZWwgKG9wYXF1ZSB3aGl0ZSkgaXMgdHJlYXRlZCBhcyB0aGUgdmFsdWUgMC4wLCBhbmQgdmFsdWVzIG5vcm1hbGx5IHRyZWF0ZWQgYXMgMC4wIChibGFjaywgdHJhbnNwYXJlbnQpIGFyZSB0cmVhdGVkIGFzIDEuMC5cbiAgICAgKlxuICAgICAqIFRoZSBPdmVybGF5IG1vZGUgYmVoYXZlcyBsaWtlIFNjcmVlbiBtb2RlIGluIGJyaWdodCBhcmVhcywgYW5kIGxpa2UgTXVsdGlwbHkgbW9kZSBpbiBkYXJrZXIgYXJlYXMuXG4gICAgICogV2l0aCB0aGlzIG1vZGUsIHRoZSBicmlnaHQgYXJlYXMgd2lsbCBsb29rIGJyaWdodGVyIGFuZCB0aGUgZGFyayBhcmVhcyB3aWxsIGxvb2sgZGFya2VyLlxuICAgICAqL1xuICAgIEJsZW5kTW9kZVtcIk9WRVJMQVlcIl0gPSBcIm92ZXJsYXlcIjtcbiAgICAvKipcbiAgICAgKiBDb21wb3NpdGUgdGhlIHNvdXJjZSBhbmQgZGVzdGluYXRpb24gaW1hZ2UgYnkgY2hvb3NpbmcgdGhlIGxvd2VzdCB2YWx1ZSBmcm9tIGVhY2ggY29sb3IgY2hhbm5lbC5cbiAgICAgKiBUaGUgb3BhY2l0eSBvZiB0aGUgb3V0cHV0IGltYWdlIGlzIGNvbXB1dGVkIGluIHRoZSBzYW1lIHdheSBhcyBmb3Igc3JjT3Zlci5cbiAgICAgKi9cbiAgICBCbGVuZE1vZGVbXCJEQVJLRU5cIl0gPSBcImRhcmtlblwiO1xuICAgIC8qKlxuICAgICAqIENvbXBvc2l0ZSB0aGUgc291cmNlIGFuZCBkZXN0aW5hdGlvbiBpbWFnZSBieSBjaG9vc2luZyB0aGUgaGlnaGVzdCB2YWx1ZSBmcm9tIGVhY2ggY29sb3IgY2hhbm5lbC5cbiAgICAgKiBUaGUgb3BhY2l0eSBvZiB0aGUgb3V0cHV0IGltYWdlIGlzIGNvbXB1dGVkIGluIHRoZSBzYW1lIHdheSBhcyBmb3Igc3JjT3Zlci5cbiAgICAgKi9cbiAgICBCbGVuZE1vZGVbXCJMSUdIVEVOXCJdID0gXCJsaWdodGVuXCI7XG4gICAgLyoqXG4gICAgICogTXVsdGlwbHkgdGhlIGNvbXBvbmVudHMgb2YgdGhlIHNvdXJjZSBhbmQgZGVzdGluYXRpb24gaW1hZ2VzIGFmdGVyIGFkanVzdGluZyB0aGVtIHRvIGZhdm9yIHRoZSBzb3VyY2UuXG4gICAgICogU3BlY2lmaWNhbGx5LCBpZiB0aGUgc291cmNlIHZhbHVlIGlzIHNtYWxsZXIsIHRoaXMgbXVsdGlwbGllcyBpdCB3aXRoIHRoZSBkZXN0aW5hdGlvbiB2YWx1ZSwgd2hlcmVhcyBpcyB0aGUgZGVzdGluYXRpb24gdmFsdWUgaXMgc21hbGxlciwgaXQgbXVsdGlwbGllcyB0aGUgaW52ZXJzZSBvZiB0aGUgZGVzdGluYXRpb24gdmFsdWUgd2l0aCB0aGUgaW52ZXJzZSBvZiB0aGUgc291cmNlIHZhbHVlLCB0aGVuIGludmVydHMgdGhlIHJlc3VsdC5cbiAgICAgKiBJbnZlcnRpbmcgdGhlIGNvbXBvbmVudHMgbWVhbnMgdGhhdCBhIGZ1bGx5IHNhdHVyYXRlZCBjaGFubmVsIChvcGFxdWUgd2hpdGUpIGlzIHRyZWF0ZWQgYXMgdGhlIHZhbHVlIDAuMCwgYW5kIHZhbHVlcyBub3JtYWxseSB0cmVhdGVkIGFzIDAuMCAoYmxhY2ssIHRyYW5zcGFyZW50KSBhcmUgdHJlYXRlZCBhcyAxLjAuXG4gICAgICpcbiAgICAgKiBUaGUgZWZmZWN0IG9mIHRoZSBIYXJkIGxpZ2h0IG1vZGUgZGVwZW5kcyBvbiB0aGUgZGVuc2l0eSBvZiB0aGUgc3VwZXJpbXBvc2VkIGNvbG9yLiBVc2luZyBicmlnaHQgY29sb3JzIG9uIHRoZSBibGVuZGluZyBsYXllciB3aWxsIGNyZWF0ZSBhIGJyaWdodGVyIGVmZmVjdCBsaWtlIHRoZSBTY3JlZW4gbW9kZXMsIHdoaWxlIGRhcmsgY29sb3JzIHdpbGwgY3JlYXRlIGRhcmtlciBjb2xvcnMgbGlrZSB0aGUgTXVsdGlwbHkgbW9kZS5cbiAgICAgKi9cbiAgICBCbGVuZE1vZGVbXCJIQVJEX0xJR0hUXCJdID0gXCJoYXJkTGlnaHRcIjtcbiAgICAvKipcbiAgICAgKiBTdWJ0cmFjdCB0aGUgc21hbGxlciB2YWx1ZSBmcm9tIHRoZSBiaWdnZXIgdmFsdWUgZm9yIGVhY2ggY2hhbm5lbC5cbiAgICAgKiBDb21wb3NpdGluZyBibGFjayBoYXMgbm8gZWZmZWN0OyBjb21wb3NpdGluZyB3aGl0ZSBpbnZlcnRzIHRoZSBjb2xvcnMgb2YgdGhlIG90aGVyIGltYWdlLlxuICAgICAqIFRoZSBvcGFjaXR5IG9mIHRoZSBvdXRwdXQgaW1hZ2UgaXMgY29tcHV0ZWQgaW4gdGhlIHNhbWUgd2F5IGFzIGZvciBzcmNPdmVyLlxuICAgICAqIFRoZSBlZmZlY3QgaXMgc2ltaWxhciB0byBleGNsdXNpb24gYnV0IGhhcnNoZXIuXG4gICAgICovXG4gICAgQmxlbmRNb2RlW1wiRElGRkVSRU5DRVwiXSA9IFwiZGlmZmVyZW5jZVwiO1xuICAgIC8qKlxuICAgICAqIFN1YnRyYWN0IGRvdWJsZSB0aGUgcHJvZHVjdCBvZiB0aGUgdHdvIGltYWdlcyBmcm9tIHRoZSBzdW0gb2YgdGhlIHR3byBpbWFnZXMuXG4gICAgICogQ29tcG9zaXRpbmcgYmxhY2sgaGFzIG5vIGVmZmVjdDsgY29tcG9zaXRpbmcgd2hpdGUgaW52ZXJ0cyB0aGUgY29sb3JzIG9mIHRoZSBvdGhlciBpbWFnZS5cbiAgICAgKiBUaGUgb3BhY2l0eSBvZiB0aGUgb3V0cHV0IGltYWdlIGlzIGNvbXB1dGVkIGluIHRoZSBzYW1lIHdheSBhcyBmb3Igc3JjT3Zlci5cbiAgICAgKiBUaGUgZWZmZWN0IGlzIHNpbWlsYXIgdG8gZGlmZmVyZW5jZSBidXQgc29mdGVyLlxuICAgICAqL1xuICAgIEJsZW5kTW9kZVtcIkVYQ0xVU0lPTlwiXSA9IFwiZXhjbHVzaW9uXCI7XG59KShCbGVuZE1vZGUgfHwgKGV4cG9ydHMuQmxlbmRNb2RlID0gQmxlbmRNb2RlID0ge30pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnN0YW50cy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@jimp+core@1.6.0/node_modules/@jimp/core/dist/commonjs/utils/constants.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/@jimp+core@1.6.0/node_modules/@jimp/core/dist/commonjs/utils/image-bitmap.js":
/*!*************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@jimp+core@1.6.0/node_modules/@jimp/core/dist/commonjs/utils/image-bitmap.js ***!
  \*************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getExifOrientation = getExifOrientation;\nexports.attemptExifRotate = attemptExifRotate;\nconst exif_parser_1 = __importDefault(__webpack_require__(/*! exif-parser */ \"(ssr)/../../node_modules/.pnpm/exif-parser@0.1.12/node_modules/exif-parser/index.js\"));\n/**\n * Obtains image orientation from EXIF metadata.\n *\n * @param img a Jimp image object\n * @returns a number 1-8 representing EXIF orientation,\n *          in particular 1 if orientation tag is missing\n */\nfunction getExifOrientation(img) {\n    const _exif = img._exif;\n    return (_exif && _exif.tags && _exif.tags.Orientation) || 1;\n}\n/**\n * Returns a function which translates EXIF-rotated coordinates into\n * non-rotated ones.\n *\n * Transformation reference: http://sylvana.net/jpegcrop/exif_orientation.html.\n *\n * @param img a Jimp image object\n * @returns transformation function for transformBitmap().\n */\nfunction getExifOrientationTransformation(img) {\n    const w = img.bitmap.width;\n    const h = img.bitmap.height;\n    switch (getExifOrientation(img)) {\n        case 1: // Horizontal (normal)\n            // does not need to be supported here\n            return null;\n        case 2: // Mirror horizontal\n            return function (x, y) {\n                return [w - x - 1, y];\n            };\n        case 3: // Rotate 180\n            return function (x, y) {\n                return [w - x - 1, h - y - 1];\n            };\n        case 4: // Mirror vertical\n            return function (x, y) {\n                return [x, h - y - 1];\n            };\n        case 5: // Mirror horizontal and rotate 270 CW\n            return function (x, y) {\n                return [y, x];\n            };\n        case 6: // Rotate 90 CW\n            return function (x, y) {\n                return [y, h - x - 1];\n            };\n        case 7: // Mirror horizontal and rotate 90 CW\n            return function (x, y) {\n                return [w - y - 1, h - x - 1];\n            };\n        case 8: // Rotate 270 CW\n            return function (x, y) {\n                return [w - y - 1, x];\n            };\n        default:\n            return null;\n    }\n}\n/**\n * Transforms bitmap in place (moves pixels around) according to given\n * transformation function.\n *\n * @param img a Jimp image object, which bitmap is supposed to\n *        be transformed\n * @param width bitmap width after the transformation\n * @param height bitmap height after the transformation\n * @param transformation transformation function which defines pixel\n *        mapping between new and source bitmap. It takes a pair of coordinates\n *        in the target, and returns a respective pair of coordinates in\n *        the source bitmap, i.e. has following form:\n *        `function(new_x, new_y) { return [src_x, src_y] }`.\n */\nfunction transformBitmap(img, width, height, transformation) {\n    // Underscore-prefixed values are related to the source bitmap\n    // Their counterparts with no prefix are related to the target bitmap\n    const _data = img.bitmap.data;\n    const _width = img.bitmap.width;\n    const data = Buffer.alloc(_data.length);\n    for (let x = 0; x < width; x++) {\n        for (let y = 0; y < height; y++) {\n            const [_x, _y] = transformation(x, y);\n            const idx = (width * y + x) << 2;\n            const _idx = (_width * _y + _x) << 2;\n            const pixel = _data.readUInt32BE(_idx);\n            data.writeUInt32BE(pixel, idx);\n        }\n    }\n    img.bitmap.data = data;\n    img.bitmap.width = width;\n    img.bitmap.height = height;\n    // @ts-expect-error Accessing private property\n    img._exif.tags.Orientation = 1;\n}\n/**\n * Automagically rotates an image based on its EXIF data (if present).\n * @param img  a Jimp image object\n */\nfunction exifRotate(img) {\n    if (getExifOrientation(img) < 2) {\n        return;\n    }\n    const transformation = getExifOrientationTransformation(img);\n    const swapDimensions = getExifOrientation(img) > 4;\n    const newWidth = swapDimensions ? img.bitmap.height : img.bitmap.width;\n    const newHeight = swapDimensions ? img.bitmap.width : img.bitmap.height;\n    if (transformation) {\n        transformBitmap(img, newWidth, newHeight, transformation);\n    }\n}\nasync function attemptExifRotate(image, buffer) {\n    try {\n        image._exif =\n            exif_parser_1.default.create(buffer).parse();\n        exifRotate(image); // EXIF data\n    }\n    catch {\n        // do nothing\n    }\n}\n//# sourceMappingURL=image-bitmap.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BqaW1wK2NvcmVAMS42LjAvbm9kZV9tb2R1bGVzL0BqaW1wL2NvcmUvZGlzdC9jb21tb25qcy91dGlscy9pbWFnZS1iaXRtYXAuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwwQkFBMEI7QUFDMUIseUJBQXlCO0FBQ3pCLHNDQUFzQyxtQkFBTyxDQUFDLHdHQUFhO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsdUJBQXVCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFdBQVc7QUFDL0Isd0JBQXdCLFlBQVk7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL21pa2V3ZXN0aGFkL0Rlc2t0b3AvUmVwb3Mvc3BvcmFkaWMtbGFicy10aWxlLWV4dHJ1ZGVyL25vZGVfbW9kdWxlcy8ucG5wbS9AamltcCtjb3JlQDEuNi4wL25vZGVfbW9kdWxlcy9AamltcC9jb3JlL2Rpc3QvY29tbW9uanMvdXRpbHMvaW1hZ2UtYml0bWFwLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXRFeGlmT3JpZW50YXRpb24gPSBnZXRFeGlmT3JpZW50YXRpb247XG5leHBvcnRzLmF0dGVtcHRFeGlmUm90YXRlID0gYXR0ZW1wdEV4aWZSb3RhdGU7XG5jb25zdCBleGlmX3BhcnNlcl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJleGlmLXBhcnNlclwiKSk7XG4vKipcbiAqIE9idGFpbnMgaW1hZ2Ugb3JpZW50YXRpb24gZnJvbSBFWElGIG1ldGFkYXRhLlxuICpcbiAqIEBwYXJhbSBpbWcgYSBKaW1wIGltYWdlIG9iamVjdFxuICogQHJldHVybnMgYSBudW1iZXIgMS04IHJlcHJlc2VudGluZyBFWElGIG9yaWVudGF0aW9uLFxuICogICAgICAgICAgaW4gcGFydGljdWxhciAxIGlmIG9yaWVudGF0aW9uIHRhZyBpcyBtaXNzaW5nXG4gKi9cbmZ1bmN0aW9uIGdldEV4aWZPcmllbnRhdGlvbihpbWcpIHtcbiAgICBjb25zdCBfZXhpZiA9IGltZy5fZXhpZjtcbiAgICByZXR1cm4gKF9leGlmICYmIF9leGlmLnRhZ3MgJiYgX2V4aWYudGFncy5PcmllbnRhdGlvbikgfHwgMTtcbn1cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHdoaWNoIHRyYW5zbGF0ZXMgRVhJRi1yb3RhdGVkIGNvb3JkaW5hdGVzIGludG9cbiAqIG5vbi1yb3RhdGVkIG9uZXMuXG4gKlxuICogVHJhbnNmb3JtYXRpb24gcmVmZXJlbmNlOiBodHRwOi8vc3lsdmFuYS5uZXQvanBlZ2Nyb3AvZXhpZl9vcmllbnRhdGlvbi5odG1sLlxuICpcbiAqIEBwYXJhbSBpbWcgYSBKaW1wIGltYWdlIG9iamVjdFxuICogQHJldHVybnMgdHJhbnNmb3JtYXRpb24gZnVuY3Rpb24gZm9yIHRyYW5zZm9ybUJpdG1hcCgpLlxuICovXG5mdW5jdGlvbiBnZXRFeGlmT3JpZW50YXRpb25UcmFuc2Zvcm1hdGlvbihpbWcpIHtcbiAgICBjb25zdCB3ID0gaW1nLmJpdG1hcC53aWR0aDtcbiAgICBjb25zdCBoID0gaW1nLmJpdG1hcC5oZWlnaHQ7XG4gICAgc3dpdGNoIChnZXRFeGlmT3JpZW50YXRpb24oaW1nKSkge1xuICAgICAgICBjYXNlIDE6IC8vIEhvcml6b250YWwgKG5vcm1hbClcbiAgICAgICAgICAgIC8vIGRvZXMgbm90IG5lZWQgdG8gYmUgc3VwcG9ydGVkIGhlcmVcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBjYXNlIDI6IC8vIE1pcnJvciBob3Jpem9udGFsXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW3cgLSB4IC0gMSwgeV07XG4gICAgICAgICAgICB9O1xuICAgICAgICBjYXNlIDM6IC8vIFJvdGF0ZSAxODBcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbdyAtIHggLSAxLCBoIC0geSAtIDFdO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgY2FzZSA0OiAvLyBNaXJyb3IgdmVydGljYWxcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbeCwgaCAtIHkgLSAxXTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgNTogLy8gTWlycm9yIGhvcml6b250YWwgYW5kIHJvdGF0ZSAyNzAgQ1dcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbeSwgeF07XG4gICAgICAgICAgICB9O1xuICAgICAgICBjYXNlIDY6IC8vIFJvdGF0ZSA5MCBDV1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFt5LCBoIC0geCAtIDFdO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgY2FzZSA3OiAvLyBNaXJyb3IgaG9yaXpvbnRhbCBhbmQgcm90YXRlIDkwIENXXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW3cgLSB5IC0gMSwgaCAtIHggLSAxXTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgODogLy8gUm90YXRlIDI3MCBDV1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFt3IC0geSAtIDEsIHhdO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cbi8qKlxuICogVHJhbnNmb3JtcyBiaXRtYXAgaW4gcGxhY2UgKG1vdmVzIHBpeGVscyBhcm91bmQpIGFjY29yZGluZyB0byBnaXZlblxuICogdHJhbnNmb3JtYXRpb24gZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIGltZyBhIEppbXAgaW1hZ2Ugb2JqZWN0LCB3aGljaCBiaXRtYXAgaXMgc3VwcG9zZWQgdG9cbiAqICAgICAgICBiZSB0cmFuc2Zvcm1lZFxuICogQHBhcmFtIHdpZHRoIGJpdG1hcCB3aWR0aCBhZnRlciB0aGUgdHJhbnNmb3JtYXRpb25cbiAqIEBwYXJhbSBoZWlnaHQgYml0bWFwIGhlaWdodCBhZnRlciB0aGUgdHJhbnNmb3JtYXRpb25cbiAqIEBwYXJhbSB0cmFuc2Zvcm1hdGlvbiB0cmFuc2Zvcm1hdGlvbiBmdW5jdGlvbiB3aGljaCBkZWZpbmVzIHBpeGVsXG4gKiAgICAgICAgbWFwcGluZyBiZXR3ZWVuIG5ldyBhbmQgc291cmNlIGJpdG1hcC4gSXQgdGFrZXMgYSBwYWlyIG9mIGNvb3JkaW5hdGVzXG4gKiAgICAgICAgaW4gdGhlIHRhcmdldCwgYW5kIHJldHVybnMgYSByZXNwZWN0aXZlIHBhaXIgb2YgY29vcmRpbmF0ZXMgaW5cbiAqICAgICAgICB0aGUgc291cmNlIGJpdG1hcCwgaS5lLiBoYXMgZm9sbG93aW5nIGZvcm06XG4gKiAgICAgICAgYGZ1bmN0aW9uKG5ld194LCBuZXdfeSkgeyByZXR1cm4gW3NyY194LCBzcmNfeV0gfWAuXG4gKi9cbmZ1bmN0aW9uIHRyYW5zZm9ybUJpdG1hcChpbWcsIHdpZHRoLCBoZWlnaHQsIHRyYW5zZm9ybWF0aW9uKSB7XG4gICAgLy8gVW5kZXJzY29yZS1wcmVmaXhlZCB2YWx1ZXMgYXJlIHJlbGF0ZWQgdG8gdGhlIHNvdXJjZSBiaXRtYXBcbiAgICAvLyBUaGVpciBjb3VudGVycGFydHMgd2l0aCBubyBwcmVmaXggYXJlIHJlbGF0ZWQgdG8gdGhlIHRhcmdldCBiaXRtYXBcbiAgICBjb25zdCBfZGF0YSA9IGltZy5iaXRtYXAuZGF0YTtcbiAgICBjb25zdCBfd2lkdGggPSBpbWcuYml0bWFwLndpZHRoO1xuICAgIGNvbnN0IGRhdGEgPSBCdWZmZXIuYWxsb2MoX2RhdGEubGVuZ3RoKTtcbiAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHdpZHRoOyB4KyspIHtcbiAgICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCBoZWlnaHQ7IHkrKykge1xuICAgICAgICAgICAgY29uc3QgW194LCBfeV0gPSB0cmFuc2Zvcm1hdGlvbih4LCB5KTtcbiAgICAgICAgICAgIGNvbnN0IGlkeCA9ICh3aWR0aCAqIHkgKyB4KSA8PCAyO1xuICAgICAgICAgICAgY29uc3QgX2lkeCA9IChfd2lkdGggKiBfeSArIF94KSA8PCAyO1xuICAgICAgICAgICAgY29uc3QgcGl4ZWwgPSBfZGF0YS5yZWFkVUludDMyQkUoX2lkeCk7XG4gICAgICAgICAgICBkYXRhLndyaXRlVUludDMyQkUocGl4ZWwsIGlkeCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaW1nLmJpdG1hcC5kYXRhID0gZGF0YTtcbiAgICBpbWcuYml0bWFwLndpZHRoID0gd2lkdGg7XG4gICAgaW1nLmJpdG1hcC5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciBBY2Nlc3NpbmcgcHJpdmF0ZSBwcm9wZXJ0eVxuICAgIGltZy5fZXhpZi50YWdzLk9yaWVudGF0aW9uID0gMTtcbn1cbi8qKlxuICogQXV0b21hZ2ljYWxseSByb3RhdGVzIGFuIGltYWdlIGJhc2VkIG9uIGl0cyBFWElGIGRhdGEgKGlmIHByZXNlbnQpLlxuICogQHBhcmFtIGltZyAgYSBKaW1wIGltYWdlIG9iamVjdFxuICovXG5mdW5jdGlvbiBleGlmUm90YXRlKGltZykge1xuICAgIGlmIChnZXRFeGlmT3JpZW50YXRpb24oaW1nKSA8IDIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB0cmFuc2Zvcm1hdGlvbiA9IGdldEV4aWZPcmllbnRhdGlvblRyYW5zZm9ybWF0aW9uKGltZyk7XG4gICAgY29uc3Qgc3dhcERpbWVuc2lvbnMgPSBnZXRFeGlmT3JpZW50YXRpb24oaW1nKSA+IDQ7XG4gICAgY29uc3QgbmV3V2lkdGggPSBzd2FwRGltZW5zaW9ucyA/IGltZy5iaXRtYXAuaGVpZ2h0IDogaW1nLmJpdG1hcC53aWR0aDtcbiAgICBjb25zdCBuZXdIZWlnaHQgPSBzd2FwRGltZW5zaW9ucyA/IGltZy5iaXRtYXAud2lkdGggOiBpbWcuYml0bWFwLmhlaWdodDtcbiAgICBpZiAodHJhbnNmb3JtYXRpb24pIHtcbiAgICAgICAgdHJhbnNmb3JtQml0bWFwKGltZywgbmV3V2lkdGgsIG5ld0hlaWdodCwgdHJhbnNmb3JtYXRpb24pO1xuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGF0dGVtcHRFeGlmUm90YXRlKGltYWdlLCBidWZmZXIpIHtcbiAgICB0cnkge1xuICAgICAgICBpbWFnZS5fZXhpZiA9XG4gICAgICAgICAgICBleGlmX3BhcnNlcl8xLmRlZmF1bHQuY3JlYXRlKGJ1ZmZlcikucGFyc2UoKTtcbiAgICAgICAgZXhpZlJvdGF0ZShpbWFnZSk7IC8vIEVYSUYgZGF0YVxuICAgIH1cbiAgICBjYXRjaCB7XG4gICAgICAgIC8vIGRvIG5vdGhpbmdcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbWFnZS1iaXRtYXAuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@jimp+core@1.6.0/node_modules/@jimp/core/dist/commonjs/utils/image-bitmap.js\n");

/***/ })

};
;